# VitePress Documentation - Version 3.0

Generated from VitePress documentation v3.0 for LLM consumption

<!-- Generated file - do not edit directly -->
<!-- Generated at: 2025-06-22T18:59:54.154Z -->
<!-- Sections: 88 -->

# Getting Started

Avo is a tool that helps developers and teams build apps 10x faster. It takes the things we always build for every app and abstracts them in familiar configuration files.

It has three main parts:

1. [The CRUD UI](#_1-the-crud-ui)
2. [Dashboards](#_2-dashboards)
3. [The custom content](#_3-the-custom-content)

## 1. The CRUD UI

If before, we built apps by creating layouts, adding controller methods to extract _data_ from the database, display it on the screen, worrying how we present it to the user, capture the users input as best we can and writing logic to send that data back to the database, Avo takes a different approach.

It only needs to know what kind of data you need to expose and what type it is. After that, it takes care of the rest.
You **tell it** you need to manage Users, Projects, Products, or any other types of data and what properties they have; `first_name` as `text`, `birthday` as `date`, `cover_photo` as `file` and so on.

There are the basic fields like text, textarea, select and boolean, and the more complex ones like trix, markdown, gravatar, and boolean_group. There's even an amazing file field that's tightly integrated with `Active Storage`. **You've never added files integration as easy as this before.**

## 2. Dashboards

Most apps need a way of displaying the stats in an aggregated form. Using the same configuration-based approach, Avo makes it so easy to display data in metric cards, charts, and even lets you take over using partial cards.

## 3. Custom content
Avo is a shell in which you develop your app. It offers a familiar DSL to configure the app you're building, but sometimes you might have custom needs. That's where the custom content comes in.

You can extend Avo in different layers. For example, in the CRUD UI, you may add Custom fields that slot in perfectly in the current panels and in each view. You can also add Resource tools to control the experience using standard Rails partials completely.

You can even create Custom tools where you can add all the content you need using Rails partials or View Components.

Most of the places where records are listed like Has many associations, attach modals, search, and more are scopable to meet your multi-tenancy scenarios.

Most of the views you see are exportable using the `eject` command.

StimulusJS is deeply baked into the CRUD UI and helps you extend the UI and make a complete experience for your users.

## Seamless upgrades

Avo comes packaged as a [gem](https://rubygems.org/gems/avo). Therefore, it does not pollute your app with its internal files. Instead, everything is tucked away neatly in the package.

That makes for a beautiful upgrade experience. You hit `bundle update avo` and get the newest and best of Avo without any file conflicts.

## Next up

Please take your time and read the documentation pages to see how Avo interacts with your app and how one should use it.

1. Install Avo in your app
1. Set up the current user
1. Create a Resource
1. Set up authorization
1. Set up licensing
1. [Explore the live demo app](https://main.avodemo.com/)
1. Explore these docs
1. Enjoy building your app without ever worrying about the admin layer ever again
1. Explore the FAQ pages for guides on how to set up your Avo instance.

## Walkthrough videos

### Build a blog admin panel

<br/>

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/WgNK-oINFww" title="Build a production-ready blog admin panel" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

### Build a booking app

<br/>

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/BK47E7TMXn0" title="Build a booking app in less than an hour" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

---

# Avo 3

Avo 3 is the version of Avo we always wanted to build. It condenses all the learnings we had for the past three years into a few cool packages.

We would like to thank our community for all the support they've given and all the feedback and contributions!

## Changes

You'll find all the new changes in the Avo 2 to Avo 3 upgrade section.

## New features & big changes

##### Enterprise features
<LicenseReq license="enterprise" size="xs" />

- Audit Logging
- Role-Based Access Control

##### Advanced license features
<LicenseReq license="advanced" size="xs" />

- Dynamic filters
- Custom dynamic filters
- Custom controls on everywhere (<Index />, <Show />, <Edit />,and `Row`)
- Resource scopes
- Kanban boards
- Collaboration

##### Pro license features
<LicenseReq license="pro" size="xs" />

- Resource Cards
- Record preview on Index

##### Community license features
<LicenseReq license="community" size="xs" />

- Custom fields from template
- Custom resource view components for <Index />, <Show />, and <Edit />
- Custom components for fields
- Intelligent `view` object and new `display` view option
- Better TailwindCSS integration
- New `def fields` API
- New `def index|show|edit_fields` API
- Plugins API
- Testing helpers
- Eject command improvements
- Panel layout improvements
- Action link generator
- StimulusJS in actions
- [Array Adapter](https://docs.avohq.io/3.0/array-resources.html)
- GitHub-style Markdown editor
- Avo Meta
- Multiple actions flows
- Intelligent resource title

##### Coming soon

- Theming
- Dynamic fields
- Nested record creation
- Resource tools in fields

Avo 3 is not finished yet. We will continue to provide the same cadence of one release every ~~two~~ four weeks you are used to. Some the things we want to focus on in the near future are:

Please follow our [Roadmap](https://avohq.io/roadmap) for more information about that.

## Features moved from one tier to another

### Features moved from Pro to Advanced
<LicenseReq license="pro" size="xs" /> -> <LicenseReq license="advanced" size="xs" />

- `show_controls`

### Features moved from Pro to Community
<LicenseReq license="pro" size="xs" /> -> <LicenseReq license="community" size="xs" />

- Custom fields
- Custom tools
- Resource tools
- Tags field
- Localization
- Stimulus JS integration
- Branding

## Repos and packages

Avo 3 has been divided into various repositories and packages, organized by the specific feature or tier they are intended for. Within this structure, there are three main packages available: `avo`, `avo-pro`, and `avo-advanced`. Depending on your license, you need to manually include one of these packages in your `Gemfile`. Note that both `avo-pro` and `avo-advanced` come with additional packages that serve as their dependencies.

## Feedback

I'd love it if we could have an open forum with the open beta program. Please use the [GitHub Discussions](https://avo.cool/chat) forum for that

## Documentation

We started the process to redo and reorganize the 3.0 docs, so if we missed anything, please let us know.

## What next?

1. Install Avo 3
1. Follow the upgrade guide if you're upgrading from Avo 2
1. [Experience the new features](#new-features)
1. [Provide feedback and ask for support](https://github.com/avo-hq/avo/issues/new?assignees=&labels=Avo%203)

---

# Upgrade guide

We'll update this page when we release new Avo 3 versions.

If you're looking for the Avo 2 to Avo 3 upgrade guide, please visit the dedicated page.

## Upgrade to `avo-kanban` `0.1.18`

### TL;DR

`resource.title` is now used consistently across the Kanban board for all display purposes.

**Action required:**
Remove `to_combobox_display` from all models and transfer its logic to `resource.title`.

---

### Changes

**1. Removed `to_combobox_display` usage**
- This method can now be removed from the model.
- Instead, the `resource.title` is being used for display purposes.
- **Action required:** Remove `to_combobox_display` from all models, *but only* if it's used exclusively for Avo Kanban. If it's used elsewhere, keep it.
- Ensure that `resource.title` is configured consistently using the same logic previously implemented in `to_combobox_display`.

For example:

```ruby
# app/models/car.rb
class Car < ApplicationRecord
  # Remove this and configure the resource.title instead
  def to_combobox_display # [!code --]
    "#{make} #{model}" # [!code --]
  end # [!code --]
end

# app/avo/resources/car.rb
class Avo::Resources::Car < Avo::BaseResource
  self.search = {
    query: -> {
      query.ransack(id_eq: params[:q], make_cont: params[:q], model_cont: params[:q], m: "or").result(distinct: false)
    }
  }

  # Same logic as in the model, but accessed through the record.make and record.model
  self.title = -> { "#{record.make} #{record.model}" } # [!code ++]

  def fields = discover_columns
end
```

**2. Added validation for item and column IDs before sending requests**
- Previously, a request to add items was being triggered when the combobox input lost focus, even when no column ID was present.
- This led to incomplete data being sent to the server, resulting in a 500 error.
- **Action required:** None, this is an internal fix to prevent malformed requests.

**3. Using `resource.title` instead of `record.name` for display** each item title on the columns.
- Rendering was breaking in some cases because certain models did not implement the `name` method.
- Switching to `resource.title` resolves this issue.
- **Action required:** None, this was a fix. Just ensure `resource.title` is properly configured, as it will now be the display value.

## Upgrade to 3.18.0

<Option name="read_only and disabled options on has_one fields">

The `read_only` and `disabled` options were interfering with the rendering of attach/create buttons on `has_one` fields, while leaving other association fields like `has_many` unaffected. To preserve consistency, these options have been excised from the attach/create functionality. The attach/create operations are now controlled exclusively by authorization.

### Breaking Changes

- The `read_only` and `disabled` options no longer influence the behavior of `has_one` fields.
- Attach/create actions are now controlled solely via authorization. For further details, refer to:
  - [attach_{association}?](https://docs.avohq.io/3.0/authorization.html#attach_association)
  - [create_{association}?](https://docs.avohq.io/3.0/authorization.html#create_association)

### Steps to Update

Please **search for all `has_one` fields** that still utilize the `read_only` or `disabled` options and update them with the appropriate authorization methods as outlined above.

</Option>

<Option name="Avo's mounting point update">

We have refactored how Avo and its engines are mounted, eliminating the need for options like `mount_avo_engines` and custom engine mounting via `Avo.mount_engines`.

As a result, both `mount_avo_engines` and `Avo.mount_engines` are now obsolete. The new mounting approach simplifies integration and removes the need for custom logic.

### Breaking Change
- `mount_avo_engines` and `Avo.mount_engines` are obsolete and should no longer be used.
- Replace Avo mounting point with the new `mount_avo` approach.

### Steps to Update
1. **Remove all references** to `mount_avo_engines` and `Avo.mount_engines` from your application.
2. **Update your `routes.rb` file** by replacing:
   - `mount Avo::Engine, at: Avo.configuration.root_path` â†’ with â†’ `mount_avo`
   - If using a custom path (`mount Avo::Engine, at: "custom/path"`), replace it with `mount_avo at: "custom/path"`

By following these steps, your application will be fully compatible with the new mounting strategy.

```ruby
# config/routes.rb
Rails.application.routes.draw do
  mount Avo::Engine, at: Avo.configuration.root_path # [!code --]
  mount_avo # [!code ++]
end
```

```ruby
# config/routes.rb
Rails.application.routes.draw do
  mount Avo::Engine, at: "custom/path" # [!code --]
  mount_avo at: "custom/path" # [!code ++]
end
```

</Option>

<Option name="Preview Policy">

As of <Version version="3.18.0" />, a new policy method is available: `preview?`.

This method determines whether a preview request is authorized.

**Breaking Change:** Previously, the preview endpoint was always authorized.
Now, access is denied unless the `preview?` policy method explicitly returns `true`.

### Steps to Update

To maintain the previous behavior of preview fields, add the `preview?`
method returning `true` in your base policy class:

```ruby
# app/policies/application_policy.rb
class ApplicationPolicy
  def preview? = true
end
```

You can now refine this method to restrict access for specific users or even default it to `false`. The example above simply ensures that behavior remains unchanged after upgrading.

</Option>

<Option name="Deprecation of row">

The `row` DSL has been available but undocumented for some time. As of <Version version="3.18.0" />, it has been officially deprecated in favor of `cluster`, which is now properly documented here.

### Steps to Update

Replace all `row do` with `cluster do`.

```ruby
# app/avo/resources/user.rb
class Avo::Resources::Person < Avo::BaseResource
  def fields
    panel "Address" do
      row do # [!code --]
      cluster do # [!code ++]
        field :street_address, stacked: true do
          "1234 Elm Street"
        end

        field :city, stacked: true do
          "Los Angeles"
        end

        field :zip_code, stacked: true do
          "15234"
        end
      end
    end
  end
end
```

</Option>

## Upgrade from 3.16.2 to 3.16.3

<Option name="Row controls configuration">

This release introduces a breaking change to the way resource row controls configuration is handled. If you previously customized row controls placement, you'll need to update your configurations to match the new API.

### What changed?

The previous configuration methods have been replaced with a new structure to provide better flexibility and consistency.

#### Previous configuration (obsolete)

Global configuration:
```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.resource_controls_placement = :left
end
```

Resource configuration:
```ruby{3}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  self.controls_placement = :left
end
```

#### New configuration
Global configuration:
```ruby{3-5}
# config/initializers/avo.rb
Avo.configure do |config|
  config.resource_row_controls_config = {
    placement: :left,
  }
end
```

Resource configuration:
```ruby{3-5}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  self.row_controls_config = {
    placement: :left,
  }
end
```

</Option>

<Option name="Associations Fields Structural Updates">

We've introduced enhancements and adjustments to the association fields (`has_many`, `has_and_belongs_to_many`, etc.) to improve functionality, maintainability, and consistency. While these changes are not breaking, it's important to be aware of the following:

- **Customizations & Monkey Patches**: If you've implemented any monkey patches or custom overrides for association fields or their related classes, ensure these customizations still function as intended.
- **Impact Areas**: These adjustments might affect areas where the internal structure or behavior of association fields was previously relied upon. Although core functionality remains intact, custom modifications may require a review.

**Recommended Actions**:
- Audit any custom patches or overrides tied to association fields.
- Test the relevant functionality in your project after upgrading.

For additional context and technical details, refer to the related pull request: [#3469](https://github.com/avo-hq/avo/pull/3469).

</Option>

## Upgrade from 3.16.1 to 3.16.2

<Option name="markdown renamed to easy_mde">

We added a new GitHub-inspired `markdown` field which supports ActiveStorage and gives us better control over the whole experience.

This lead to us renaming the old `markdown` field to `easy_mde` and naming this new one `markdown`.
If you'd like your app to work the same as before, rename all your `:markdown` field to `:easy_mde`.
Otherwise leave them like that and enjoy the new field.

</Option>

## Upgrade from 3.15.3 to 3.15.4

The `config.cache_resource_filters` option is now **obsolete** and has been replaced with `config.persistence`. If you previously had:

```ruby
config.cache_resource_filters = true
```

You should update your configuration to:

```ruby
config.persistence = { driver: :session }
```

This updated setting preserves the same behavior, ensuring resource filters and association pagination states persist across requests for a consistent user experience. For additional details, refer to the `persistence` documentation.

---

### Persistent Pagination Behavior

By default, pagination settings for associations are no longer stored in the session. If your application requires persistent pagination, you must explicitly enable the `persistence` configuration:

```ruby
Avo.configure do |config|
  config.persistence = { driver: :session }
end
```

---

:::warning
**Important**:
When enabling this feature, it is strongly recommended to **update the session store** to avoid potential cookie overflow errors. The default Rails **cookie store** has a size limit of 4096 bytes, and persisting multiple pagination states or filters can exceed this limit. For more information, refer to the `persistence` configuration documentation.
:::

## Upgrade from 3.14.0 to 3.14.1

Weâ€™ve introduced the `associations_lookup_list_limit` configuration option to prevent crashing when listing associations on large collections. The new default limit is set to a `1000` records.

```ruby
config.associations_lookup_list_limit = 1000
```

## Upgrade from 3.13.6 to 3.13.7

The `implicit_authorization` option has been renamed to `explicit_authorization` to better align with the feature's functionality. The underlying logic remains unchanged, so you only need to perform a rename if you're already using it.

```ruby
config.implicit_authorization = true # [!code --]
config.explicit_authorization = true # [!code ++]
```

## Upgrade from 3.13.3 to 3.13.4

<Option name="`implicit_authorization`">

:::warning Option Renamed
<VersionReq version="3.13.7" /> this option was renamed to `explicit_authorization`.
:::

Weâ€™ve introduced the `implicit_authorization` configuration option to enhance the security of your applications. This option allows you to define how missing policy classes or methods are handled. When set to `true`, any action without an explicitly defined policy will automatically be denied, ensuring that unprotected actions are not unintentionally accessible. This new behavior offers a more secure approach for authorization.

For new applications, `implicit_authorization` is enabled by default, but existing applications will retain the legacy behavior (`false`), allowing missing policies or methods to authorize actions. We encourage you to adopt this new setting by enabling `implicit_authorization`, as it provides greater control over your authorization flow and reduces the risk of unauthorized access due to missing policies. Before enabling it, be sure to review your policy classes to ensure all necessary methods are defined, preventing any unintended access restrictions.

We highly recommend taking a moment to read through the entire `implicit_authorization` documentation section before making any changes. Understanding this feature is crucial to ensuring your application's security and functionality, so donâ€™t skip it!
</Option>

## Upgrade from 3.11.7 to 3.11.8
<Option name="Dynamic filters query">

<VersionReq version="3.11.8" /> the default filtering system is no longer applied when a `query` is specified on a dynamic filter.

</Option>

## Upgrade from 3.10.10 to 3.11.3
<Option name="Unexpected behavior">

Between versions <Version version="3.10.10" /> and <Version version="3.11.2" /> you might encounter some unexpected behavior, such as issues with applying dynamic filters or duplicated flash messages. This occurs specifically when the cookie that stores the sidebar status (open/close) is missing.

However, if the browser already has this cookie from a previous interaction, the issue does not occur.This issue is resolved <VersionReq version="3.11.3" />, so we recommend updating directly to that version.
</Option>

## Upgrade from 3.10.9 to 3.10.10
<Option name="Array filter">

Custom dynamic filter type `array` was duplicated and is now obsolete in favor of `tags`.

```ruby
def filters
  dynamic_filter :the_filter,
    type: :array # [!code --]
    type: :tags # [!code ++]
```
</Option>

## Upgrade from 3.10.6 to 3.10.7
<Option name="Boolean field">

In versions lower than <Version version="3.10.6" />, boolean fields with a `nil` value were represented by a red X, which could be misleading. <VersionReq version="3.10.7" /> when a boolean field has a `nil` value, it is displayed with a dash (`â€”`) instead of a red X.
</Option>

## Upgrade from 3.10 to 3.11

### Actions no longer need to be registered inside actions method

Actions inside customizable blocks no longer need to be declared in the `actions` method.

```ruby
# Before

class Avo::Resources::Fish < Avo::BaseResource
  self.title = :name

  self.show_controls = -> do
    # In order to use it here
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, arguments: {
      action_on_show_controls: "Will use this arguments"
    }
  end

  # ðŸ‘‡ Also declare it here ðŸ‘‡
  def actions
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, arguments: {
      action_on_show_controls: "Will use this arguments"
    }
  end
end

# After

class Avo::Resources::Fish < Avo::BaseResource
  self.title = :name

  self.show_controls = -> do
    # In order to use it here
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, arguments: {
      action_on_show_controls: "Will use this arguments"
    }
  end

  # ðŸ‘‡ No need to declare it here ðŸ‘‡
  def actions
  end
end
```

## Upgrade from 3.9.2 to 3.10
Deprecated `fetch_labels` option in favor of `format_using` on tags field.

## Upgrade from 3.9.1 to 3.9.2

We tweaked the way `locales` and i18n work with Avo.
In theory nothing should change in your setup, but please read the guide once more to see how it works.

## Upgrade from 3.7.4 to 3.9.1

:::warning Update to Rails 7.2 or greater
Rails 7.1 has a [bug](https://github.com/rails/rails/issues/51910) ([explanation](https://github.com/avo-hq/avo/issues/2844)) which would break path helpers for nested mounted engines.
:::

### Steps to update

1. Update `avo`, `avo-pro`, or `avo-advanced` to version `3.9.1`
2. Update `rails` to at least `7.2.0.beta2` (or greater when available)
3. Run `bundle update rails avo-advanced`

```ruby
# Gemfile

# Use Rails 7.2 or greater
gem "rails", ">= 7.2.0.beta2"

# or

# You can also run off `main`
gem "rails", github: "rails/rails", branch: "main"

# Update Avo
gem "avo-advanced", ">= 3.9.1"

# Use `ransack` version `4.2.0` for searching
gem "ransack", ">= 4.2.0"

# This version of acts-as-taggable-on is compatible with
# Follow this PR to get the fix in the library
# https://github.com/mbleigh/acts-as-taggable-on/pull/1126
gem "acts-as-taggable-on", github: "avo-hq/acts-as-taggable-on"
```

```bash
bundle update rails avo-advanced
```

## Skip versions 3.8.x and 3.9.0

From Avo 3.7.4 you should update straight to `3.9.1`.
The other intermediary versions introduced a bug when we tried to improve support for Rails 7.1+

More on that on this [issue](https://github.com/avo-hq/avo/issues/2844).

## Upgrade from 3.6.1 to 3.6.2

<Option name="Cache">

From version `3.6.1` to version `3.6.2` table cache logic suffered some changes. Old cached table may break with this change, we recommend to clear cache on production after upgrade (`Rails.cache.clear`).

Versions `3.6.2` / `3.6.3` have some issues around cache, we recommend to upgrade directly to `3.6.4`.
</Option>

## Upgrade from 3.5.4 to 3.5.5
<Option name="Record errors">

With version `3.5.5` we introduced a stricter error check. Now when the record has any error attached the save action will fail automatically. This allow you to do things like:

```ruby
before_update do
  if validation_fail?
    errors.add(:field_id, "Error message")
  end
end
```

</Option>

## Upgrade from 3.4.2 to 3.4.3
<Option name="`turbo` configuration">

In version `3.4.2` we introduced turbo configuration with `instantclick` option. We decided that `instant_click` is a more appropriate name.

```ruby
config.turbo = {
  instantclick: true  # [!code --]
  instant_click: true # [!code ++]
}
```
</Option>

## Upgrade from 3.4.1 to 3.4.2
<Option name="Basic Filters URL param changed to `encoded_filters`">

When we added the Dynamic Filters feature, by mistake we introduced a bug where you couldn't use the Basic and Dynamic Filters together because they are both using the `filters` URL param.

This is not what we intended.

To fix this we are changing the URL param of the Basic Filters from `filters` to `encoded_filters` so now you can have a URL with both filters.

```md
# Before
https://example.com/avo/resources/users?filters[first_name][contains][]=Jason&page=1&filters=eyJBdm86OkZpbHRlcnM6OklzQWRtaW4iOlsiYWRtaW5zIl19

# After
https://example.com/avo/resources/users?filters[first_name][contains][]=Jason&page=1&encoded_filters=eyJBdm86OkZpbHRlcnM6OklzQWRtaW4iOlsiYWRtaW5zIl19
```
### What to do?

If you have hardcoded links where you reference the `filters` param, change that to `encoded_filters`.
These links might be in Tools, Resource Tools, Menu Items, or regular view partials (yes, basically anywhere you might have added them ðŸ«¤).

A quick search through your codebase should reveal them.
</Option>

<Option name="Add `active_record_extended` gem to your `Gemfile`">

In order to extend Avo's filtering capabilities for arrays and tags fields, we use the [`active_record_extended`](https://github.com/GeorgeKaraszi/ActiveRecordExtended) gem.

This gem uses postgres and was breaking for those who use any other database like `sqlite`.

If you want to keep `Contained in` option on arrays and tags filters you should include the `active_record_extended` gem to your `Gemfile`.
</Option>

<Option name="Multiple action flux">

First iteration of multiple action flux was using `redirect_to` with `turbo_frame: "actions_show"`. With the update to turbo 8 the redirect was giving some troubles and we decided that is time to improve this experience with a proper response type, `navigate_to_action`.

If you have a multiple action flux implemented with `redirect_to` you should change it to `navigate_to_action`.

</Option>

<Option name="Action `link_arguments` method">

Action `link_arguments` method handles the `arguments` encoding and encryption internally now so you only need to pass the `arguments` as a hash and the returned `path` will already include the encoded arguments.

```ruby{20,21,22,23,25}
field :name,
  as: :text,
  filterable: true,
  name: "name (click to edit)",
  only_on: :index do

  arguments = Base64.encode64 Avo::Services::EncryptionService.encrypt( # [!code --]
    message: {                                                          # [!code --]
      cities: Array[resource.record.id],                                # [!code --]
      render_name: true                                                 # [!code --]
    },                                                                  # [!code --]
    purpose: :action_arguments                                          # [!code --]
  )                                                                     # [!code --]

  arguments = {                                                         # [!code ++]
    cities: Array[resource.record.id],                                  # [!code ++]
    render_name: true                                                   # [!code ++]
  }                                                                     # [!code ++]

  path, data = Avo::Actions::City::Update.link_arguments(
    resource: resource,
    arguments: arguments
  )

  link_to resource.record.name, path, data: data
end
```

</Option>

<Option name="`resource.record` or `record` as `nil` on visibility blocks">

You may notice that `resource.record == nil` on some visibility blocks. That happens when evaluating the field visibility to render header columns. On index, there is no record.

This is a consequence of a bug fix where `resource.record` was wrongly storing the last record of the index table.

Check [this discussion](https://github.com/avo-hq/avo/issues/2544) for more details
</Option>

## Upgrade from 3.3.0 to 3.4.0

Ruby 3.0 is end-of-life and we pushed some code that only works with Ruby 3.1.

## Upgrade from 3.2.2 to 3.3.0
<Option name="`may_download_file` deprecated">

Actions now fully operate with turbo leading to the deprecation of `may_download_file` option. It can be safely removed from all actions.
</Option>

<Option name="Status field `failed_when` and `loading_when` default to and empty array">

We found [some issues](https://github.com/avo-hq/avo/pull/2316) with declaring defaults to `failed_when` and `loading_when` field options so we are now defaulting them to empty arrays.

If you need that behavior back, add it to your fields.

```ruby{3,4}
field :status,
  as: :status,
  failed_when: [:failed],
  loading_when: [:waiting, :running]
```
</Option>

<Option name="Scopes namespace change">

Scopes changed namespace from `Avo::Pro::Scopes` to `Avo::Advanced::Scopes`.
</Option>

<Option name="TailwindCSS integration">

The symlink generated by `avo:sym_link` task was renamed from `tmp/avo/base.css` to `tmp/avo/avo.base.css`. If your application has the TailwindCSS integration generated before Avo `3.3.0` you should replace `@import '../../../../tmp/avo/base.css';` with `'../../../../tmp/avo/avo.base.css';` in `app/assets/stylesheets/avo/avo.tailwind.css`.

```css
/* app/assets/stylesheets/avo/avo.tailwind.css */

@import '../../../../tmp/avo/base.css'; // [!code --]
@import '../../../../tmp/avo/avo.base.css'; // [!code ++]
```
</Option>

## Upgrade from 3.1.3 to 3.1.4

<Option name="`Avo::Filters::BaseFilter.decode_filters`">

We removed the rescue that would return `{}` on parsing error. This rescue block was occasionally concealing pertinent errors. Ensure that when invoking `Avo::Filters::BaseFilter.decode_filters` the argument is not `nil` and has been encoded using the `Avo::Filters::BaseFilter.encode_filters` method.
</Option>

## Upgrade from 3.0.1.beta24 to 3.0.2

<Option name="Sidebar should be declared inside a panel">

We introduced the `main_panel` option and also refactored the way that fields are fetched from the resource, now we allow multiple sidebars per panel but each sidebar should be defined inside a `panel` or `main_panel` block.

We suggest to read panels and sidebars sections for more information and to be aware of the new possibilities.
</Option>

<Option name="Dashboards visibility and authorization">

Previously, if the `visible` attribute was set to `false` on dashboards, visiting them was impossible because the controller would trigger a "Not found" error. In cases where `authorize` returned `false`, the controller would block access but still keep the dashboard visible.

This behavior has been enhanced. Now, even if `visible` is set to `false`, the dashboard remains accessible but won't appear in the menu. Additionally, if `authorize` returns `false`, the dashboards are now hidden.
</Option>

<Option name="Actions">

We've internally implemented some changes around actions to resolve certain bugs. No action is needed from your end, but if you happen to notice any anomalies in the actions flow, please get in touch with us so we can address them promptly. Thank you.
</Option>

<Option name="Attachments eager load">

Attachments are no longer automatically eager loading. If you want to eager load attachments there are at least two ways:

### Use `self.includes` option

```ruby
class Avo::Resources::PhotoComment < Avo::BaseResource
  self.includes = [:user, [photo_attachment: :blob]]

  def fields
    field :user, as: :belongs_to
    field :photo, as: :file, is_image: true
  end
```

### Use `self.index_query` option
```ruby
class Avo::Resources::Product < Avo::BaseResource
   self.index_query = -> {
    query.includes image_attachment: :blob
  }

  def fields
    field :image, as: :file, is_image: true
  end
```

</Option>

## Upgrade from 3.0.1.beta23 to 3.0.1.beta24

<Option name="Cards">

With the new feature that allow cards on resources  we've realized that it's no longer logical to retain cards within the `Dashboard` namespace scope. Consequently, each card is now located within the `Avo::Cards` namespace.

```ruby
# Before
class Avo::Cards::AmountRaised < Avo::Dashboards::MetricCard
class Avo::Cards::ExampleAreaChart < Avo::Dashboards::ChartkickCard
class Avo::Cards::ExampleBarChart < Avo::Dashboards::ChartkickCard
# ...

# After
class Avo::Cards::AmountRaised < Avo::Cards::MetricCard
class Avo::Cards::ExampleAreaChart < Avo::Cards::ChartkickCard
class Avo::Cards::ExampleBarChart < Avo::Cards::ChartkickCard
# ...

```

</Option>

## Upgrade from 3.0.1.beta22 to 3.0.1.beta23

<Option name="Caching">

Since there are many available cache stores and we were allowing only few we changed the way of computing the cache store to be used by Avo.

One of our concerns was to maintain the status quo, but if you notice any caching issues there is a new configurable option `config.cache_store` that allows you to tell Avo what `cache_store` to use.

Check cache page for more details.

</Option>

## Upgrade from 3.0.1.beta8 to 3.0.1.beta9

<Option name="Heading as field">

Heading option changed declaration mode, one of the main reasons for this change is to be able to generate a clear `data-field-id` on the DOM

For more information about `heading` field syntax check `heading` field's documentation.
:::code-group
```ruby [Before]
heading "personal information"
heading "contact"
heading '<div class="underline uppercase font-bold">DEV</div>', as_html: true
```

```ruby [After]
field :personal_information, as: :heading       # data-field-id == "personal_information"
field :heading, as: :heading, label: "Contact"  # data-field-id == "heading"
field :dev, as: :heading, as_html: true, label: '<div class="underline uppercase font-bold">DEV</div>'
```
:::

</Option>

<Option name="Badge field `secondary` option renamed to `neutral`">

We believe that the term `neutral` better reflects the intended use.

:::code-group
```ruby {8} [Before]
field :stage,
  as: :badge,
  options: {
    info: [:discovery, :idea],
    success: :done,
    warning: "on hold",
    danger: :cancelled,
    secondary: :drafting
  }
```

```ruby {8} [After]
field :stage,
  as: :badge,
  options: {
    info: [:discovery, :idea],
    success: :done,
    warning: "on hold",
    danger: :cancelled,
    neutral: :drafting
  }
```
:::
</Option>

<Option name="Rename `link_to_resource` to `link_to_record`">

`link_to_resource` was renamed to `link_to_record`.
:::code-group
```ruby {3-4} [Before]
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_resource: true
    field :email, as: :gravatar, link_to_resource: true
  end
end
```

```ruby {3-4} [After]
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :gravatar, link_to_record: true
  end
end
```
:::
</Option>

## Upgrade from 3.0.1.beta5 to 3.0.1.beta6

<Option name="The status field changed behavior">

Before, for the status you'd set the `failed` and `loading` states and everything else fell under `success`. That felt unnatural. We needed a `neutral` state.
Now we changed the field so you'll set the `failed`, `loading`, and `success` values and the rest fall under `neutral`.

```ruby
# Before
field :status,
  as: :status,
  failed_when: :failed,
  loading_when: :loading

# After
field :status,
  as: :status,
  failed_when: :failed,
  loading_when: :loading
  success_when: :deployed # specify the success state
```
</Option>

---

# Upgrade guide

The upgrade process from Avo 2 to Avo 3 has quite a few steps, but you'll soon figure out that the API hasn't changed all that much. We moved a few things around and made others more consistent.

Depending on how you use Avo you might not need to do all the steps.

:::warning
The `show_controls` feature has been moved from the Pro to the Advanced tier.

The `show_controls` feature was in beta since launch. We introduced options for the <Index />, and <Edit /> views, and for the row controls.

Based on how much it took to build the feature, the maintenance perspective and the value it brings we have decided that it's best suited for the Advanced tier.
:::

## Upgrade from 2.x to 3.x

:::info Ensure you meet the technical requirements
Avo now requires Ruby 3.1 and Rails 6.1
:::

:::info Ensure you have a token for `Pro` or `Advanced` versions.
Avo 3 requires a new v3 license key. Your v2 license key won't work. Please purchase and Avo 3 license from [avohq.io/pricing](https://avohq.io/pricing).
:::

:::info Upgrade from a v2 license to a v3 license

~~Because we switched Stripe accounts, the subscription upgrade process is not an automated one.~~

We upgraded all Avo 2 Pro licenses to Avo 3 Pro licenses without any cost additions.

If you had an Avo 2 license, you received an email about that and instructions on next steps.

Thank you for being an awesome customer!
:::

## Use the automatic upgrade tool

:::danger The upgrade tool

 - is experimental
 - doesn't cover all the required steps
 - might produce unwanted artifacts

**Back-up your code before using the tool.**
:::

To use the upgrade tool add `gem 'avo_upgrade'` to your `Gemfile` and run `bundle install`.

```ruby
group :development do
  gem "avo_upgrade"
end
```

Next you should run the `bin/rails avo:upgrade:2_to_3` command and go through the process.

Ideally, you'd run the command with a clean tree and then make the last adjustments manually. The command will tell you what those the last adjustments are that you have to do manually.

When that command finished you can safely remove `gem "avo_upgrade"` from your `Gemfile`.

## Upgrade steps

Each paragraph will guide you through the upgrade process for each individual change.

Most of these steps are breaking changes so you'll need to apply them if you're using the feature.

<Option name="Update your `Gemfile`">

The Avo gem comes in three flavors now. Community, Pro, or Advanced.

You should add the one you use in your `Gemfile`. If you use Pro or Advanced you don't have to add `avo` too. Each gem adds their own dependencies.

Add only one of the ones below.

:::warning
If you want to install `avo-pro` or `avo-advanced` please ensure you have a [valid Avo 3 license](https://avohq.io/pricing) and you take the required steps to authenticate with `packager.dev`.
:::
</Option>

<Option name="The status field changed behavior">

Before, for the status you'd set the `failed` and `loading` states and everything else fell under `success`. That felt unnatural. We needed a `neutral` state.
Now we changed the field so you'll set the `failed`, `loading`, and `success` values and the rest fall under `neutral`.

```ruby
# Before
field :status,
  as: :status,
  failed_when: :failed,
  loading_when: :loading

# After
field :status,
  as: :status,
  failed_when: :failed,
  loading_when: :loading
  success_when: :deployed # specify the success state
```
</Option>

<Option name="`heading` has become a field type">

Before, a heading used the `heading` method with a text string or HTML string as an argument.
Now, it is a field type with an ID. It supports rendering as text and as HTML.

### Actions to take

Rename `heading` to `field`. Give the field an ID and add the `as: :heading` argument.

```ruby
# Before
heading 'User Information'

# After
field :user_information, as: :heading
# or...
field :some_id, as: :heading, label: 'User Information'

# Before
heading '<div class="underline uppercase font-bold">User Information</div>', as_html: true

# After
field :some_id, as: :heading, as_html: true do
  '<div class="underline uppercase font-bold">User Information</div>'
end
```
</Option>

<Option name="Moved some globals from `Avo::App` to `Avo::Current`">

### Actions to take

Rename the following:

- `Avo::App.context`      -> `Avo::Current.context`
- `Avo::App.params`       -> `Avo::Current.params`
- `Avo::App.request`      -> `Avo::Current.request`
- `Avo::App.view_context` -> `Avo::Current.view_context`
- `Avo::App.current_user` -> `Avo::Current.user`

Make note of the `current_user` to `user` rename.
</Option>

<Option name="Renamed `model` to `record` across all configuration files">

The `model` naming is a bit off. You never know if you're mentioning the model class or the instantiated database record, so we changed it to `record` (Pundit calls it a record too). One of the places you'll see it the most is when you reference it off of the `resource` (`resource.model`).

### Actions to take

Rename `resource.model` to `resource.record`.

You might have the `model` referenced in other places too. Try to replace it with `record`.
If you find it in other places, please send them our way so we can update this doc for a more consistent API. Thank you!
</Option>

<Option name="Remove block (lambda) arguments">

All block arguments are removed from Avo. We did this in order to make blocks more consistent and to improve future compatibility. All the arguments that were previously available as arguments, are present inside the block.

We don't have a complete list of blocks but we'll try to give you a few examples:

 - Field options: `visible`, `readonly`, `disabled`, `format_using`, etc.
 - Select field `options` option
 - Resource options: `index_query`, `search_query`, `find_record_method`, etc.
 - Actions, Dashboards, and Cards `self.visible`
 - anything that you are passing as a block should be without arguments

**As a general rule, we removed all block arguments. If we missed any, so please send them our way so we can update this guide.** Thank you!

### Actions to take

Remove the arguments from blocks

```ruby
# Before
self.visible = ->(resource:) {}

# After
self.visible = -> {}

# Before
field :name, as: :text, default: ->(resource:) {something}, format_using: ->(value:) {}, visible: ->(resource:) {}

# After
field :name, as: :text, default: -> {something}, format_using: -> {}, visible: -> {}

# Before
field :level, as: :select, options: ->(model:, resource:, field:, view:) do
    {
      Beginner: :beginner,
      Intermediate: :intermediate,
      Advanced: :advanced,
    }
  end

# After
field :level, as: :select, options: -> do
    {
      Beginner: :beginner,
      Intermediate: :intermediate,
      Advanced: :advanced,
    }
  end
```
</Option>

<Option name="Swap `disabled` and `readonly` field options">

We received some feedback in v2.x that the `disabled` field option does not protect against DOM field manipulation when the form is submitted, so we introduced the `readonly` option that protects against that.

After a short [research](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/readonly) we soon found out that HTML does it the other way around. `disabled` protects against that and `readonly` doesn't.
So, we are switching them to better comply with the standards.

### Actions to take

Swap those two

```ruby
field :name,
  as: :text,
  disabled: -> { !Avo::Current.user.is_admin? } // [!code --]
  readonly: -> { !Avo::Current.user.is_admin? } // [!code ++]

field :hidden_info,
  as: :text,
  readonly: -> { !Avo::Current.user.is_admin? } // [!code --]
  disabled: -> { !Avo::Current.user.is_admin? } // [!code ++]
```
</Option>

<Option name="Removed `index_text_align` option">

Same behavior from `index_text_align` can be achieved using `html` and `class` options.

### Actions to take
Replace `index_text_align` with `html` option:

```ruby
# Before
field :users_required, as: :number, index_text_align: :right

# After
field :users_required, as: :number, html: {index: {wrapper: {classes: "text-right"}}}
```
</Option>

<Option name="Renamed `resolve_query_scope` to `index_query` in resources">

The new method name `index_query` speaks more about what it does and the rest of the changes brings it more inline with the other APIs

### Actions to take

- rename `resolve_query_scope` to `index_query`
- remove the `(model_class:)` block argument
- rename `model_class` inside the block to `query`

```ruby
# Before
self.resolve_query_scope = ->(model_class:) do
  model_class.order(last_name: :asc)
end

# After
self.index_query = -> do
  query.order(last_name: :asc)
end
```
</Option>

<Option name="Removed `resolve_find_scope` in favor of `find_record_method`">

The new `find_record_method` method works better as it enables you to use custom find matchers.

### Actions to take

- rename `resolve_query_scope` to `index_query`
- remove the `(model_class:, id:, params:)` block arguments
- rename `model_class` inside the block to `query`
- add the `.find` matcher

```ruby
# Before
self.resolve_find_scope = ->(model_class:) do
  model_class.friendly
end

# After
self.find_record_method = -> do
  query.friendly.find id
end
```
</Option>

<Option name="Refactor the grid view API">

We removed the old `grid do` block to `self.grid_view` to fall more inline with `self.map_view` and others.

The `card` block will cycle through all of your records and you need to return a hash with the following keys `title`, `body`, `cover_url`.

You may also return an `html` option to apply html properties to the card elements.

```ruby
self.grid_view = {
  card: -> do
    {
      cover_url:
        if record.cover_photo.attached?
          main_app.url_for(record.cover_photo.url)
        end,
      title: record.name,
      body: ActionView::Base.full_sanitizer.sanitize(record.body).truncate(120)
    }
  end,
  html: -> do
    {
      title: {
        index: {
          wrapper: {
            classes: "bg-blue-50 rounded-md p-2"
          }
        }
      },
      body: {
        index: {
          wrapper: {
            classes: "bg-gray-50 rounded-md p-1"
          }
        }
      }
    }
  end
}
```
</Option>

<Option name="Refactored the search API">

In Avo 2, the search options were scattered around multiple places. The query was used from the `search_query`, the record description was taken from an arbitrary `as_description: true` field option, the `as_label` option was used to display the record title in the search results, and other mis-aligned places.

In Avo 3 we brought all those things in a single `self.search` option.

The `self.search[:item]` block will go through each of the found records where you have to return a hash with the following keys `title`, `description`, `image_url`, `image_format`.

- `self.search_query` moved to `self.search[:query]`. (remove `self.search_query` from the resource file)
- `scope` that was accessible inside old `self.search_query` moved to `query` and it's inside `self.search[:query]` (check code example below)
- `self.search_query_help` moved to `self.search[:help]`. (remove `self.search_query_help` from the resource file)
- `self.hide_from_global_search` moved to `self.search[:hide_on_global]`. (remove `self.hide_from_global_search` from the resource file)
- `self.search_result_path` moved to `self.search[:result_path]`. (remove `self.search_result_path` from the resource file)
- the search item `title` is going to be the `self.title` by default but you can configure it in `item`.
- `as_description: true` is `self.search[:item][:description]`. (remove `as_description: true` from fields)
- `as_avatar: true` is `self.search[:item][:image_url]`. (remove `as_avatar:` from fields)
- `as_avatar: :rounded` is `self.search[:item][:image_format]`
- `as_label: true` is `self.search[:item][:title]`. (remove `as_label:` from fields)

```ruby
class Avo::Resources::User < Avo::BaseResource
  self.search = {
    query: -> {
      query.order(created_at: :desc)
        .ransack(first_name_cont: params[:q], last_name_cont: params[:q], m: "or")
        .result(distinct: false)
    },
    item: -> do
      {
        title: record.name,
        description: "This user has the following roles: #{record.roles.select { |key, value| value }.keys.join(", ")}",
        image_url: main_app.url_for(record.cover_photo) if record.cover_photo.attached?,
        image_format: :rounded
      }
    end
    help: -> { "- Search by first name or last name." },
    hide_on_global: true,
    result_path: -> { avo.resources_city_path record, custom: "yup" }
  }
end
```
</Option>

<Option name="Rename Avo configuration classes">

We are falling more in line with how Rails and zeitwerk autoloads classes. We do this to avoid some issues like class conflicts and difficult to remember naming schemes.

The old naming scheme: `{NAME}{TYPE}` (`UserResource`)
The new naming scheme: `Avo::{TYPE}::{Name}` (`Avo::Resources::User`)

In a similar fashion you should update the filename too: `app/avo/resources/user_resource.rb` -> `app/avo/resources/user.rb`.

### Actions to take

Rename the your configuration classes to include the full path:

::: code-group

```ruby [Resources]
# Before
# /app/avo/resources/user_resource.rb
class UserResource < Avo::BaseResource
end

# After
# /app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
end
```

```ruby [Actions]
# Before
# /app/avo/actions/export_action.rb
class ExportAction < Avo::BaseAction
end

# After
# /app/avo/actions/export.rb
class Avo::Actions::Export < Avo::BaseAction
end
```

```ruby [Filters]
# Before
# /app/avo/filters/name_filter.rb
class NameFilter < Avo::BaseFilter
end

# After
# /app/avo/filters/name.rb
class Avo::Filters::Name < Avo::BaseFilter
end
```

```ruby [Dashboards]
# Before
# /app/avo/dashboards/sales_dashboard.rb
class SalesDashboard < Avo::BaseResource
end

# After
# /app/avo/dashboards/sales.rb
class Avo::Dashboards::Sales < Avo::Dashboards::BaseDashboard
end
```

```ruby [Cards]
# Before
# /app/avo/cards/users_count_card.rb
class UsersCountCard < Avo::Dashboards::MetricCard
end

# After
# /app/avo/cards/users_count.rb
class Avo::Cards::UsersCount < Avo::Cards::MetricCard
end
```

```ruby [Resource tools]
# Before
# /app/avo/resource_tools/comments_resource_tool.rb
class CommentsResourceTool < Avo::BaseResourceTool
end

# After
# /app/avo/resource_tools/comments.rb
class Avo::ResourceTools::Comments < Avo::BaseResourceTool
end
```

```ruby [Custom fields]
# Before
# /app/avo/fields/color_picker_field.rb
class ColorPickerField < Avo::Fields::BaseField
end

# After
# /app/avo/fields/color_picker_field.rb
class Avo::Fields::ColorPickerField < Avo::Fields::BaseField
end
```
:::
</Option>

<Option name="Use the `def fields` API">

We are introducing a new API for declaring fields. This brings many improvements from easier maintenance, better control, better composition, and more.

```ruby
# Before
class Avo::Resources::Team < Avo::BaseResource
  self.title = :name

  field :id, as: :id, filterable: true
  field :name, as: :text, sortable: true, show_on: :preview, filterable: true

  tabs do
    tab "Info" do
      panel do
        field :created_at, as: :date_time, filterable: true
      end
    end
  end

  sidebar do
    field :updated_at, as: :date_time, filterable: true
  end

  panel "Logo" do
    field :logo, as: :external_image, hide_on: :show, as_avatar: :rounded
  end

  tool Avo::ResourceTools::TeamTool
end

# After
class Avo::Resources::Team < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, filterable: true
    field :name, as: :text, sortable: true, show_on: :preview, filterable: true

    tabs do
      tab "Info" do
        panel do
          field :created_at, as: :date_time, filterable: true
        end
      end
    end

    sidebar do
      field :updated_at, as: :date_time, filterable: true
    end

    panel "Logo" do
      field :logo, as: :external_image, hide_on: :show, as_avatar: :rounded
    end

    tool Avo::ResourceTools::TeamTool
  end
end
```

This will enable us to provide request specific data to the field configuration like `current_user` and `params` and will enable you to have better composition.

```ruby
class Avo::Resources::Team < Avo::BaseResource
  self.title = :name

  def admin_fields
    field :created_at, as: :date_time, filterable: true
  end

  def fields
    field :id, as: :id, filterable: true
    field :name, as: :text, sortable: true, show_on: :preview, filterable: true
    field :logo, as: :external_image, hide_on: :show, as_avatar: :rounded do
      if record.url
        "//logo.clearbit.com/#{URI.parse(record.url).host}?size=180"
      end
    end

    # request-time data
    if current_user.is_admin?
      # better composition
      admin_fields
    end
  end
end
```

### Actions to take

Wrap all `field`, `tabs`, `tab`, `panel`, `sidebar`, and `tool` declarations from Resource and Action files into one `def fields` method.
</Option>

<Option name="Use the `def actions` API">

Similar to how we added the `def fields` wrapper to fields you should now wrap all actions in an `actions` method.

```ruby{3,8-10}
# Before
class Avo::Resources::User < Avo::BaseResource
  action Avo::Actions::Dummy
end

# After
class Avo::Resources::User < Avo::BaseResource
  def actions
    action Avo::Actions::Dummy
  end
end
```
</Option>

<Option name="Use the `def filters` API">

Similar to how we added the `def fields` wrapper to fields you should now wrap all filters in an `filters` method.

```ruby{3,8-10}
# Before
class Avo::Resources::User < Avo::BaseResource
  filter Avo::Filters::IsAdmin
end

# After
class Avo::Resources::User < Avo::BaseResource
  def filters
    filter Avo::Filters::IsAdmin
  end
end
```
</Option>

<Option name="Use the `def scopes` API">

Similar to how we added the `def fields` wrapper to fields you should now wrap all scopes in an `scopes` method.

```ruby{3,8-10}
# Before
class Avo::Resources::User < Avo::BaseResource
  scope Avo::Scopes::Active
end

# After
class Avo::Resources::User < Avo::BaseResource
  def scopes
    scope Avo::Scopes::Active
  end
end
```
</Option>

<Option name="Wrap all Dashboard `card` and `divider` definitions inside one `def cards` method">

After the `def fields` refactor we did the same in dashboard files. Instead of declaring the cards in the class directly, you should do it in the `def cards` method.

```ruby{6-9,17-22}
# Before
class Avo::Dashboards::Dashy < AvoDashboards::BaseDashboard
  self.id = "dashy"
  self.name = "Dashy"

  card Avo::Cards::ExampleMetric, visible: -> { true }
  card Avo::Cards::ExampleAreaChart
  divider
  card Avo::Cards::ExampleScatterChart
end

# After
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  self.id = "dashy"
  self.name = "Dashy"

  def cards
    card Avo::Cards::ExampleMetric, visible: -> { true }
    card Avo::Cards::ExampleAreaChart
    divider
    card Avo::Cards::ExampleScatterChart
  end
end
```
</Option>

<Option name="`tool` is declared inside the `def fields` method">

In Avo 3 you'll be able to insert resource tools in-between fields, tabs and panels, so now, the `tool`s must be called inside the `fields` method. This feature is unreleased yet, but you should make the change now so it'll be seamless when we add it.

### Actions to take

```ruby{8,17}
# Before
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true, sortable: false
    field :email, as: :gravatar, link_to_record: true, as_avatar: :circle, only_on: :index
  end

  tool Avo::ResourceTools::UserTool
end

# After
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true, sortable: false
    field :email, as: :gravatar, link_to_record: true, as_avatar: :circle, only_on: :index

    tool Avo::ResourceTools::UserTool
  end
end
```
</Option>

<Option name="Remove `tabs_style` from the `tabs` declaration">

We streamlined tabs and kept only the `:pills` style so now we only have one style of tabs.

### Actions to take

Remove `tabs_style` from the `tabs` declaration

```ruby
# Before
tabs tabs_style: :pills do
  # tabs here
end

# After
tabs do
  # tabs here
end
```
</Option>

---

# Untitled Section

---

# Best practices

Due of the dynamic nature of Ruby, Rails, and Avo, you might be tempted to do a few things differently than how we envisioned them to be done.
It's ok if you want to keep doing them like that, but they might not be the most the optimum way of running Avo.

Here's a collection of best practices that we'd like you to know about.

## Avoiding `n+1` using `self.includes`

`n+1` issues happen, but they are pretty simple to mitigate using Avo.

Each resource has the `self.includes` option that helps you eager-load associations.

:::info Detailed documentation
`self.includes`
:::

## Avoid using `if/else` statements in `def fields`

You might be tempted to using `if/else` statements inside the `def fields` method.
This practice is discouraged and we'll try to explain why here.

Because of checks Avo makes during the request lifecycle, we need to know exactly which fields you have defined for your resource, no matter if they should be hidden or not to a user or in a certain scenario.

The alternative is to use the `visible` field option which will add the field on the list, but keep it hidden from the user based on the computed value.

### Example:

```ruby
# Scenario 1
def fields
  if params[:special_case].present?
    field :special_field, as: :text
  else
    field :regular_field, as: :text
  end
end

# Scenario 2
def fields
  field :special_field, as: :text, visible: -> { params[:special_case].present? }
  field :regular_field, as: :text, visible: -> { params[:special_case].present? }
end
```

In the first scenario, where we use the `if/else` statements, depending on how the `params` are set, the fields list will be `[special_field]` or `[regular_field]`, but never both.
This will lead to many issues like filters not being visible, params not being properly permitted, and more.

In the second scenario, the field list will always be `[special_field, regular_field]` with different visibility rules.
Now Avo will know they are both there and set up the request and UI properly.

So, please use the `visibility` option and avoid `if/else` in `def fields` whenever possible.

## Add an index on the `created_at` column

Avo, by default, sorts the the record on the <Index /> view by the `created_at` attribute, so it's a good idea to add an index for that column.

```ruby
# Example migration
class AddIndexOnUsersCreatedAt < ActiveRecord::Migration[7.1]
  def change
    add_index :users, :created_at
  end
end
```

---

# Code editors and LLM setup

Use `https://avohq.io/llms.txt` to setup your LLM integration in Cursor, VSCode, and other code editors.

It's a compact, text version of Avo's docs to help AI generate accurate Avo code based on your prompt.

```bash
https://avohq.io/llms.txt
```

## Pick your tool

<EditorList />

<br>

> [!INFO] Thanks DaisyUI!
> We sourced most of these docs from [DaisyUI's excellent editors page](https://daisyui.com/docs/editor/)

---

# Getting Started

Avo is a tool that helps developers and teams build apps 10x faster. It takes the things we always build for every app and abstracts them in familiar configuration files.

It has three main parts:

1. [The CRUD UI](#_1-the-crud-ui)
2. [Dashboards](#_2-dashboards)
3. [The custom content](#_3-the-custom-content)

## 1. The CRUD UI

If before, we built apps by creating layouts, adding controller methods to extract _data_ from the database, display it on the screen, worrying how we present it to the user, capture the users input as best we can and writing logic to send that data back to the database, Avo takes a different approach.

It only needs to know what kind of data you need to expose and what type it is. After that, it takes care of the rest.
You **tell it** you need to manage Users, Projects, Products, or any other types of data and what properties they have; `first_name` as `text`, `birthday` as `date`, `cover_photo` as `file` and so on.

There are the basic fields like text, textarea, select and boolean, and the more complex ones like trix, markdown, gravatar, and boolean_group. There's even an amazing file field that's tightly integrated with `Active Storage`. **You've never added files integration as easy as this before.**

## 2. Dashboards

Most apps need a way of displaying the stats in an aggregated form. Using the same configuration-based approach, Avo makes it so easy to display data in metric cards, charts, and even lets you take over using partial cards.

## 3. Custom content
Avo is a shell in which you develop your app. It offers a familiar DSL to configure the app you're building, but sometimes you might have custom needs. That's where the custom content comes in.

You can extend Avo in different layers. For example, in the CRUD UI, you may add Custom fields that slot in perfectly in the current panels and in each view. You can also add Resource tools to control the experience using standard Rails partials completely.

You can even create Custom tools where you can add all the content you need using Rails partials or View Components.

Most of the places where records are listed like Has many associations, attach modals, search, and more are scopable to meet your multi-tenancy scenarios.

Most of the views you see are exportable using the `eject` command.

StimulusJS is deeply baked into the CRUD UI and helps you extend the UI and make a complete experience for your users.

## Seamless upgrades

Avo comes packaged as a [gem](https://rubygems.org/gems/avo). Therefore, it does not pollute your app with its internal files. Instead, everything is tucked away neatly in the package.

That makes for a beautiful upgrade experience. You hit `bundle update avo` and get the newest and best of Avo without any file conflicts.

## Next up

Please take your time and read the documentation pages to see how Avo interacts with your app and how one should use it.

1. Install Avo in your app
1. Set up the current user
1. Create a Resource
1. Set up authorization
1. Set up licensing
1. [Explore the live demo app](https://main.avodemo.com/)
1. Explore these docs
1. Enjoy building your app without ever worrying about the admin layer ever again
1. Explore the FAQ pages for guides on how to set up your Avo instance.

## Walkthrough videos

### Build a blog admin panel

<br/>

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/WgNK-oINFww" title="Build a production-ready blog admin panel" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

### Build a booking app

<br/>

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/BK47E7TMXn0" title="Build a booking app in less than an hour" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>
</div>

---

# Avo â¤ï¸ Rails & Hotwire

In order to provide this all-in-one full-interface experience, we are using Rails' built-in [engines functionality](https://guides.rubyonrails.org/engines.html).

## Avo as a Rails engine

Avo is a **Ruby on Rails engine** that runs isolated and side-by-side with your app. You configure it using a familiar DSL and sometimes regular Rails code through controller methods and partials.

Avo's philosophy is to have as little business logic in your app as possible and give the developer the right tools to extend the functionality when needed.

That means we use a few files to configure most of the interface. When that configuration is not enough, we enable the developer to export (eject) partials or even generate new ones for their total control.

### Prepend engine name in URL path helpers

Because it's a **Rails engine** you'll have to follow a few engine rules. One of them is that [routes are isolated](https://guides.rubyonrails.org/engines.html#routes). That means that whenever you're using Rails' [path helpers](https://guides.rubyonrails.org/routing.html#generating-paths-and-urls-from-code) you'll need to prepend the name of the engine. For example, Avo's name is `avo,` and your app's engine name is `main_app`.

```ruby
# When referencing an Avo route, use avo
link_to 'Users', avo.resources_users_path
link_to user.name, avo.resources_user_path(user)

# When referencing a path for your app, use main_app
link_to "Contact", main_app.contact_path
link_to post.name, main_app.posts_path(post)
```

### Use your helpers inside Avo

This is something that we'd like to improve in the future, but the flow right now is to 1. include the helper module inside the controller you need it for and then 2. reference the methods from the `view_context.controller` object in resource files or any other place you'd need them.

```ruby{3-5,10,16}
# app/helpers/application_helper.rb
module ApplicationHelper
  def render_copyright_info
    "Copyright #{Date.today.year}"
  end
end

# app/controller/avo/products_controller.rb
class Avo::ProductsController < Avo::ResourcesController
  include ApplicationHelper
end

# app/avo/resources/products_resource.rb
class ProductsResource < Avo::BaseResource
  field :copyright, as: :text do
    view_context.controller.render_copyright_info
  end
end
```

## Hotwire

Avo's built with Hotwire, so anytime you'd like to use Turbo Frames, that's supported out of the box.

## StimulusJS

Avo comes loaded with Stimulus JS and has a quite deep integration with it by providing useful built-in helpers that improve the development experience.

Please follow the Stimulus JS guide that takes an in-depth look at all the possible ways of extending the UI.

---

# Upgrade guide

We'll update this page when we release new Avo 3 versions.

If you're looking for the Avo 2 to Avo 3 upgrade guide, please visit the dedicated page.

## Upgrade to `avo-kanban` `0.1.18`

### TL;DR

`resource.title` is now used consistently across the Kanban board for all display purposes.

**Action required:**
Remove `to_combobox_display` from all models and transfer its logic to `resource.title`.

---

### Changes

**1. Removed `to_combobox_display` usage**
- This method can now be removed from the model.
- Instead, the `resource.title` is being used for display purposes.
- **Action required:** Remove `to_combobox_display` from all models, *but only* if it's used exclusively for Avo Kanban. If it's used elsewhere, keep it.
- Ensure that `resource.title` is configured consistently using the same logic previously implemented in `to_combobox_display`.

For example:

```ruby
# app/models/car.rb
class Car < ApplicationRecord
  # Remove this and configure the resource.title instead
  def to_combobox_display # [!code --]
    "#{make} #{model}" # [!code --]
  end # [!code --]
end

# app/avo/resources/car.rb
class Avo::Resources::Car < Avo::BaseResource
  self.search = {
    query: -> {
      query.ransack(id_eq: params[:q], make_cont: params[:q], model_cont: params[:q], m: "or").result(distinct: false)
    }
  }

  # Same logic as in the model, but accessed through the record.make and record.model
  self.title = -> { "#{record.make} #{record.model}" } # [!code ++]

  def fields = discover_columns
end
```

**2. Added validation for item and column IDs before sending requests**
- Previously, a request to add items was being triggered when the combobox input lost focus, even when no column ID was present.
- This led to incomplete data being sent to the server, resulting in a 500 error.
- **Action required:** None, this is an internal fix to prevent malformed requests.

**3. Using `resource.title` instead of `record.name` for display** each item title on the columns.
- Rendering was breaking in some cases because certain models did not implement the `name` method.
- Switching to `resource.title` resolves this issue.
- **Action required:** None, this was a fix. Just ensure `resource.title` is properly configured, as it will now be the display value.

## Upgrade to 3.18.0

<Option name="read_only and disabled options on has_one fields">

The `read_only` and `disabled` options were interfering with the rendering of attach/create buttons on `has_one` fields, while leaving other association fields like `has_many` unaffected. To preserve consistency, these options have been excised from the attach/create functionality. The attach/create operations are now controlled exclusively by authorization.

### Breaking Changes

- The `read_only` and `disabled` options no longer influence the behavior of `has_one` fields.
- Attach/create actions are now controlled solely via authorization. For further details, refer to:
  - [attach_{association}?](https://docs.avohq.io/3.0/authorization.html#attach_association)
  - [create_{association}?](https://docs.avohq.io/3.0/authorization.html#create_association)

### Steps to Update

Please **search for all `has_one` fields** that still utilize the `read_only` or `disabled` options and update them with the appropriate authorization methods as outlined above.

</Option>

<Option name="Avo's mounting point update">

We have refactored how Avo and its engines are mounted, eliminating the need for options like `mount_avo_engines` and custom engine mounting via `Avo.mount_engines`.

As a result, both `mount_avo_engines` and `Avo.mount_engines` are now obsolete. The new mounting approach simplifies integration and removes the need for custom logic.

### Breaking Change
- `mount_avo_engines` and `Avo.mount_engines` are obsolete and should no longer be used.
- Replace Avo mounting point with the new `mount_avo` approach.

### Steps to Update
1. **Remove all references** to `mount_avo_engines` and `Avo.mount_engines` from your application.
2. **Update your `routes.rb` file** by replacing:
   - `mount Avo::Engine, at: Avo.configuration.root_path` â†’ with â†’ `mount_avo`
   - If using a custom path (`mount Avo::Engine, at: "custom/path"`), replace it with `mount_avo at: "custom/path"`

By following these steps, your application will be fully compatible with the new mounting strategy.

```ruby
# config/routes.rb
Rails.application.routes.draw do
  mount Avo::Engine, at: Avo.configuration.root_path # [!code --]
  mount_avo # [!code ++]
end
```

```ruby
# config/routes.rb
Rails.application.routes.draw do
  mount Avo::Engine, at: "custom/path" # [!code --]
  mount_avo at: "custom/path" # [!code ++]
end
```

</Option>

<Option name="Preview Policy">

As of <Version version="3.18.0" />, a new policy method is available: `preview?`.

This method determines whether a preview request is authorized.

**Breaking Change:** Previously, the preview endpoint was always authorized.
Now, access is denied unless the `preview?` policy method explicitly returns `true`.

### Steps to Update

To maintain the previous behavior of preview fields, add the `preview?`
method returning `true` in your base policy class:

```ruby
# app/policies/application_policy.rb
class ApplicationPolicy
  def preview? = true
end
```

You can now refine this method to restrict access for specific users or even default it to `false`. The example above simply ensures that behavior remains unchanged after upgrading.

</Option>

<Option name="Deprecation of row">

The `row` DSL has been available but undocumented for some time. As of <Version version="3.18.0" />, it has been officially deprecated in favor of `cluster`, which is now properly documented here.

### Steps to Update

Replace all `row do` with `cluster do`.

```ruby
# app/avo/resources/user.rb
class Avo::Resources::Person < Avo::BaseResource
  def fields
    panel "Address" do
      row do # [!code --]
      cluster do # [!code ++]
        field :street_address, stacked: true do
          "1234 Elm Street"
        end

        field :city, stacked: true do
          "Los Angeles"
        end

        field :zip_code, stacked: true do
          "15234"
        end
      end
    end
  end
end
```

</Option>

## Upgrade from 3.16.2 to 3.16.3

<Option name="Row controls configuration">

This release introduces a breaking change to the way resource row controls configuration is handled. If you previously customized row controls placement, you'll need to update your configurations to match the new API.

### What changed?

The previous configuration methods have been replaced with a new structure to provide better flexibility and consistency.

#### Previous configuration (obsolete)

Global configuration:
```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.resource_controls_placement = :left
end
```

Resource configuration:
```ruby{3}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  self.controls_placement = :left
end
```

#### New configuration
Global configuration:
```ruby{3-5}
# config/initializers/avo.rb
Avo.configure do |config|
  config.resource_row_controls_config = {
    placement: :left,
  }
end
```

Resource configuration:
```ruby{3-5}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  self.row_controls_config = {
    placement: :left,
  }
end
```

</Option>

<Option name="Associations Fields Structural Updates">

We've introduced enhancements and adjustments to the association fields (`has_many`, `has_and_belongs_to_many`, etc.) to improve functionality, maintainability, and consistency. While these changes are not breaking, it's important to be aware of the following:

- **Customizations & Monkey Patches**: If you've implemented any monkey patches or custom overrides for association fields or their related classes, ensure these customizations still function as intended.
- **Impact Areas**: These adjustments might affect areas where the internal structure or behavior of association fields was previously relied upon. Although core functionality remains intact, custom modifications may require a review.

**Recommended Actions**:
- Audit any custom patches or overrides tied to association fields.
- Test the relevant functionality in your project after upgrading.

For additional context and technical details, refer to the related pull request: [#3469](https://github.com/avo-hq/avo/pull/3469).

</Option>

## Upgrade from 3.16.1 to 3.16.2

<Option name="markdown renamed to easy_mde">

We added a new GitHub-inspired `markdown` field which supports ActiveStorage and gives us better control over the whole experience.

This lead to us renaming the old `markdown` field to `easy_mde` and naming this new one `markdown`.
If you'd like your app to work the same as before, rename all your `:markdown` field to `:easy_mde`.
Otherwise leave them like that and enjoy the new field.

</Option>

## Upgrade from 3.15.3 to 3.15.4

The `config.cache_resource_filters` option is now **obsolete** and has been replaced with `config.persistence`. If you previously had:

```ruby
config.cache_resource_filters = true
```

You should update your configuration to:

```ruby
config.persistence = { driver: :session }
```

This updated setting preserves the same behavior, ensuring resource filters and association pagination states persist across requests for a consistent user experience. For additional details, refer to the `persistence` documentation.

---

### Persistent Pagination Behavior

By default, pagination settings for associations are no longer stored in the session. If your application requires persistent pagination, you must explicitly enable the `persistence` configuration:

```ruby
Avo.configure do |config|
  config.persistence = { driver: :session }
end
```

---

:::warning
**Important**:
When enabling this feature, it is strongly recommended to **update the session store** to avoid potential cookie overflow errors. The default Rails **cookie store** has a size limit of 4096 bytes, and persisting multiple pagination states or filters can exceed this limit. For more information, refer to the `persistence` configuration documentation.
:::

## Upgrade from 3.14.0 to 3.14.1

Weâ€™ve introduced the `associations_lookup_list_limit` configuration option to prevent crashing when listing associations on large collections. The new default limit is set to a `1000` records.

```ruby
config.associations_lookup_list_limit = 1000
```

## Upgrade from 3.13.6 to 3.13.7

The `implicit_authorization` option has been renamed to `explicit_authorization` to better align with the feature's functionality. The underlying logic remains unchanged, so you only need to perform a rename if you're already using it.

```ruby
config.implicit_authorization = true # [!code --]
config.explicit_authorization = true # [!code ++]
```

## Upgrade from 3.13.3 to 3.13.4

<Option name="`implicit_authorization`">

:::warning Option Renamed
<VersionReq version="3.13.7" /> this option was renamed to `explicit_authorization`.
:::

Weâ€™ve introduced the `implicit_authorization` configuration option to enhance the security of your applications. This option allows you to define how missing policy classes or methods are handled. When set to `true`, any action without an explicitly defined policy will automatically be denied, ensuring that unprotected actions are not unintentionally accessible. This new behavior offers a more secure approach for authorization.

For new applications, `implicit_authorization` is enabled by default, but existing applications will retain the legacy behavior (`false`), allowing missing policies or methods to authorize actions. We encourage you to adopt this new setting by enabling `implicit_authorization`, as it provides greater control over your authorization flow and reduces the risk of unauthorized access due to missing policies. Before enabling it, be sure to review your policy classes to ensure all necessary methods are defined, preventing any unintended access restrictions.

We highly recommend taking a moment to read through the entire `implicit_authorization` documentation section before making any changes. Understanding this feature is crucial to ensuring your application's security and functionality, so donâ€™t skip it!
</Option>

## Upgrade from 3.11.7 to 3.11.8
<Option name="Dynamic filters query">

<VersionReq version="3.11.8" /> the default filtering system is no longer applied when a `query` is specified on a dynamic filter.

</Option>

## Upgrade from 3.10.10 to 3.11.3
<Option name="Unexpected behavior">

Between versions <Version version="3.10.10" /> and <Version version="3.11.2" /> you might encounter some unexpected behavior, such as issues with applying dynamic filters or duplicated flash messages. This occurs specifically when the cookie that stores the sidebar status (open/close) is missing.

However, if the browser already has this cookie from a previous interaction, the issue does not occur.This issue is resolved <VersionReq version="3.11.3" />, so we recommend updating directly to that version.
</Option>

## Upgrade from 3.10.9 to 3.10.10
<Option name="Array filter">

Custom dynamic filter type `array` was duplicated and is now obsolete in favor of `tags`.

```ruby
def filters
  dynamic_filter :the_filter,
    type: :array # [!code --]
    type: :tags # [!code ++]
```
</Option>

## Upgrade from 3.10.6 to 3.10.7
<Option name="Boolean field">

In versions lower than <Version version="3.10.6" />, boolean fields with a `nil` value were represented by a red X, which could be misleading. <VersionReq version="3.10.7" /> when a boolean field has a `nil` value, it is displayed with a dash (`â€”`) instead of a red X.
</Option>

## Upgrade from 3.10 to 3.11

### Actions no longer need to be registered inside actions method

Actions inside customizable blocks no longer need to be declared in the `actions` method.

```ruby
# Before

class Avo::Resources::Fish < Avo::BaseResource
  self.title = :name

  self.show_controls = -> do
    # In order to use it here
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, arguments: {
      action_on_show_controls: "Will use this arguments"
    }
  end

  # ðŸ‘‡ Also declare it here ðŸ‘‡
  def actions
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, arguments: {
      action_on_show_controls: "Will use this arguments"
    }
  end
end

# After

class Avo::Resources::Fish < Avo::BaseResource
  self.title = :name

  self.show_controls = -> do
    # In order to use it here
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, arguments: {
      action_on_show_controls: "Will use this arguments"
    }
  end

  # ðŸ‘‡ No need to declare it here ðŸ‘‡
  def actions
  end
end
```

## Upgrade from 3.9.2 to 3.10
Deprecated `fetch_labels` option in favor of `format_using` on tags field.

## Upgrade from 3.9.1 to 3.9.2

We tweaked the way `locales` and i18n work with Avo.
In theory nothing should change in your setup, but please read the guide once more to see how it works.

## Upgrade from 3.7.4 to 3.9.1

:::warning Update to Rails 7.2 or greater
Rails 7.1 has a [bug](https://github.com/rails/rails/issues/51910) ([explanation](https://github.com/avo-hq/avo/issues/2844)) which would break path helpers for nested mounted engines.
:::

### Steps to update

1. Update `avo`, `avo-pro`, or `avo-advanced` to version `3.9.1`
2. Update `rails` to at least `7.2.0.beta2` (or greater when available)
3. Run `bundle update rails avo-advanced`

```ruby
# Gemfile

# Use Rails 7.2 or greater
gem "rails", ">= 7.2.0.beta2"

# or

# You can also run off `main`
gem "rails", github: "rails/rails", branch: "main"

# Update Avo
gem "avo-advanced", ">= 3.9.1"

# Use `ransack` version `4.2.0` for searching
gem "ransack", ">= 4.2.0"

# This version of acts-as-taggable-on is compatible with
# Follow this PR to get the fix in the library
# https://github.com/mbleigh/acts-as-taggable-on/pull/1126
gem "acts-as-taggable-on", github: "avo-hq/acts-as-taggable-on"
```

```bash
bundle update rails avo-advanced
```

## Skip versions 3.8.x and 3.9.0

From Avo 3.7.4 you should update straight to `3.9.1`.
The other intermediary versions introduced a bug when we tried to improve support for Rails 7.1+

More on that on this [issue](https://github.com/avo-hq/avo/issues/2844).

## Upgrade from 3.6.1 to 3.6.2

<Option name="Cache">

From version `3.6.1` to version `3.6.2` table cache logic suffered some changes. Old cached table may break with this change, we recommend to clear cache on production after upgrade (`Rails.cache.clear`).

Versions `3.6.2` / `3.6.3` have some issues around cache, we recommend to upgrade directly to `3.6.4`.
</Option>

## Upgrade from 3.5.4 to 3.5.5
<Option name="Record errors">

With version `3.5.5` we introduced a stricter error check. Now when the record has any error attached the save action will fail automatically. This allow you to do things like:

```ruby
before_update do
  if validation_fail?
    errors.add(:field_id, "Error message")
  end
end
```

</Option>

## Upgrade from 3.4.2 to 3.4.3
<Option name="`turbo` configuration">

In version `3.4.2` we introduced turbo configuration with `instantclick` option. We decided that `instant_click` is a more appropriate name.

```ruby
config.turbo = {
  instantclick: true  # [!code --]
  instant_click: true # [!code ++]
}
```
</Option>

## Upgrade from 3.4.1 to 3.4.2
<Option name="Basic Filters URL param changed to `encoded_filters`">

When we added the Dynamic Filters feature, by mistake we introduced a bug where you couldn't use the Basic and Dynamic Filters together because they are both using the `filters` URL param.

This is not what we intended.

To fix this we are changing the URL param of the Basic Filters from `filters` to `encoded_filters` so now you can have a URL with both filters.

```md
# Before
https://example.com/avo/resources/users?filters[first_name][contains][]=Jason&page=1&filters=eyJBdm86OkZpbHRlcnM6OklzQWRtaW4iOlsiYWRtaW5zIl19

# After
https://example.com/avo/resources/users?filters[first_name][contains][]=Jason&page=1&encoded_filters=eyJBdm86OkZpbHRlcnM6OklzQWRtaW4iOlsiYWRtaW5zIl19
```
### What to do?

If you have hardcoded links where you reference the `filters` param, change that to `encoded_filters`.
These links might be in Tools, Resource Tools, Menu Items, or regular view partials (yes, basically anywhere you might have added them ðŸ«¤).

A quick search through your codebase should reveal them.
</Option>

<Option name="Add `active_record_extended` gem to your `Gemfile`">

In order to extend Avo's filtering capabilities for arrays and tags fields, we use the [`active_record_extended`](https://github.com/GeorgeKaraszi/ActiveRecordExtended) gem.

This gem uses postgres and was breaking for those who use any other database like `sqlite`.

If you want to keep `Contained in` option on arrays and tags filters you should include the `active_record_extended` gem to your `Gemfile`.
</Option>

<Option name="Multiple action flux">

First iteration of multiple action flux was using `redirect_to` with `turbo_frame: "actions_show"`. With the update to turbo 8 the redirect was giving some troubles and we decided that is time to improve this experience with a proper response type, `navigate_to_action`.

If you have a multiple action flux implemented with `redirect_to` you should change it to `navigate_to_action`.

</Option>

<Option name="Action `link_arguments` method">

Action `link_arguments` method handles the `arguments` encoding and encryption internally now so you only need to pass the `arguments` as a hash and the returned `path` will already include the encoded arguments.

```ruby{20,21,22,23,25}
field :name,
  as: :text,
  filterable: true,
  name: "name (click to edit)",
  only_on: :index do

  arguments = Base64.encode64 Avo::Services::EncryptionService.encrypt( # [!code --]
    message: {                                                          # [!code --]
      cities: Array[resource.record.id],                                # [!code --]
      render_name: true                                                 # [!code --]
    },                                                                  # [!code --]
    purpose: :action_arguments                                          # [!code --]
  )                                                                     # [!code --]

  arguments = {                                                         # [!code ++]
    cities: Array[resource.record.id],                                  # [!code ++]
    render_name: true                                                   # [!code ++]
  }                                                                     # [!code ++]

  path, data = Avo::Actions::City::Update.link_arguments(
    resource: resource,
    arguments: arguments
  )

  link_to resource.record.name, path, data: data
end
```

</Option>

<Option name="`resource.record` or `record` as `nil` on visibility blocks">

You may notice that `resource.record == nil` on some visibility blocks. That happens when evaluating the field visibility to render header columns. On index, there is no record.

This is a consequence of a bug fix where `resource.record` was wrongly storing the last record of the index table.

Check [this discussion](https://github.com/avo-hq/avo/issues/2544) for more details
</Option>

## Upgrade from 3.3.0 to 3.4.0

Ruby 3.0 is end-of-life and we pushed some code that only works with Ruby 3.1.

## Upgrade from 3.2.2 to 3.3.0
<Option name="`may_download_file` deprecated">

Actions now fully operate with turbo leading to the deprecation of `may_download_file` option. It can be safely removed from all actions.
</Option>

<Option name="Status field `failed_when` and `loading_when` default to and empty array">

We found [some issues](https://github.com/avo-hq/avo/pull/2316) with declaring defaults to `failed_when` and `loading_when` field options so we are now defaulting them to empty arrays.

If you need that behavior back, add it to your fields.

```ruby{3,4}
field :status,
  as: :status,
  failed_when: [:failed],
  loading_when: [:waiting, :running]
```
</Option>

<Option name="Scopes namespace change">

Scopes changed namespace from `Avo::Pro::Scopes` to `Avo::Advanced::Scopes`.
</Option>

<Option name="TailwindCSS integration">

The symlink generated by `avo:sym_link` task was renamed from `tmp/avo/base.css` to `tmp/avo/avo.base.css`. If your application has the TailwindCSS integration generated before Avo `3.3.0` you should replace `@import '../../../../tmp/avo/base.css';` with `'../../../../tmp/avo/avo.base.css';` in `app/assets/stylesheets/avo/avo.tailwind.css`.

```css
/* app/assets/stylesheets/avo/avo.tailwind.css */

@import '../../../../tmp/avo/base.css'; // [!code --]
@import '../../../../tmp/avo/avo.base.css'; // [!code ++]
```
</Option>

## Upgrade from 3.1.3 to 3.1.4

<Option name="`Avo::Filters::BaseFilter.decode_filters`">

We removed the rescue that would return `{}` on parsing error. This rescue block was occasionally concealing pertinent errors. Ensure that when invoking `Avo::Filters::BaseFilter.decode_filters` the argument is not `nil` and has been encoded using the `Avo::Filters::BaseFilter.encode_filters` method.
</Option>

## Upgrade from 3.0.1.beta24 to 3.0.2

<Option name="Sidebar should be declared inside a panel">

We introduced the `main_panel` option and also refactored the way that fields are fetched from the resource, now we allow multiple sidebars per panel but each sidebar should be defined inside a `panel` or `main_panel` block.

We suggest to read panels and sidebars sections for more information and to be aware of the new possibilities.
</Option>

<Option name="Dashboards visibility and authorization">

Previously, if the `visible` attribute was set to `false` on dashboards, visiting them was impossible because the controller would trigger a "Not found" error. In cases where `authorize` returned `false`, the controller would block access but still keep the dashboard visible.

This behavior has been enhanced. Now, even if `visible` is set to `false`, the dashboard remains accessible but won't appear in the menu. Additionally, if `authorize` returns `false`, the dashboards are now hidden.
</Option>

<Option name="Actions">

We've internally implemented some changes around actions to resolve certain bugs. No action is needed from your end, but if you happen to notice any anomalies in the actions flow, please get in touch with us so we can address them promptly. Thank you.
</Option>

<Option name="Attachments eager load">

Attachments are no longer automatically eager loading. If you want to eager load attachments there are at least two ways:

### Use `self.includes` option

```ruby
class Avo::Resources::PhotoComment < Avo::BaseResource
  self.includes = [:user, [photo_attachment: :blob]]

  def fields
    field :user, as: :belongs_to
    field :photo, as: :file, is_image: true
  end
```

### Use `self.index_query` option
```ruby
class Avo::Resources::Product < Avo::BaseResource
   self.index_query = -> {
    query.includes image_attachment: :blob
  }

  def fields
    field :image, as: :file, is_image: true
  end
```

</Option>

## Upgrade from 3.0.1.beta23 to 3.0.1.beta24

<Option name="Cards">

With the new feature that allow cards on resources  we've realized that it's no longer logical to retain cards within the `Dashboard` namespace scope. Consequently, each card is now located within the `Avo::Cards` namespace.

```ruby
# Before
class Avo::Cards::AmountRaised < Avo::Dashboards::MetricCard
class Avo::Cards::ExampleAreaChart < Avo::Dashboards::ChartkickCard
class Avo::Cards::ExampleBarChart < Avo::Dashboards::ChartkickCard
# ...

# After
class Avo::Cards::AmountRaised < Avo::Cards::MetricCard
class Avo::Cards::ExampleAreaChart < Avo::Cards::ChartkickCard
class Avo::Cards::ExampleBarChart < Avo::Cards::ChartkickCard
# ...

```

</Option>

## Upgrade from 3.0.1.beta22 to 3.0.1.beta23

<Option name="Caching">

Since there are many available cache stores and we were allowing only few we changed the way of computing the cache store to be used by Avo.

One of our concerns was to maintain the status quo, but if you notice any caching issues there is a new configurable option `config.cache_store` that allows you to tell Avo what `cache_store` to use.

Check cache page for more details.

</Option>

## Upgrade from 3.0.1.beta8 to 3.0.1.beta9

<Option name="Heading as field">

Heading option changed declaration mode, one of the main reasons for this change is to be able to generate a clear `data-field-id` on the DOM

For more information about `heading` field syntax check `heading` field's documentation.
:::code-group
```ruby [Before]
heading "personal information"
heading "contact"
heading '<div class="underline uppercase font-bold">DEV</div>', as_html: true
```

```ruby [After]
field :personal_information, as: :heading       # data-field-id == "personal_information"
field :heading, as: :heading, label: "Contact"  # data-field-id == "heading"
field :dev, as: :heading, as_html: true, label: '<div class="underline uppercase font-bold">DEV</div>'
```
:::

</Option>

<Option name="Badge field `secondary` option renamed to `neutral`">

We believe that the term `neutral` better reflects the intended use.

:::code-group
```ruby {8} [Before]
field :stage,
  as: :badge,
  options: {
    info: [:discovery, :idea],
    success: :done,
    warning: "on hold",
    danger: :cancelled,
    secondary: :drafting
  }
```

```ruby {8} [After]
field :stage,
  as: :badge,
  options: {
    info: [:discovery, :idea],
    success: :done,
    warning: "on hold",
    danger: :cancelled,
    neutral: :drafting
  }
```
:::
</Option>

<Option name="Rename `link_to_resource` to `link_to_record`">

`link_to_resource` was renamed to `link_to_record`.
:::code-group
```ruby {3-4} [Before]
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_resource: true
    field :email, as: :gravatar, link_to_resource: true
  end
end
```

```ruby {3-4} [After]
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :gravatar, link_to_record: true
  end
end
```
:::
</Option>

## Upgrade from 3.0.1.beta5 to 3.0.1.beta6

<Option name="The status field changed behavior">

Before, for the status you'd set the `failed` and `loading` states and everything else fell under `success`. That felt unnatural. We needed a `neutral` state.
Now we changed the field so you'll set the `failed`, `loading`, and `success` values and the rest fall under `neutral`.

```ruby
# Before
field :status,
  as: :status,
  failed_when: :failed,
  loading_when: :loading

# After
field :status,
  as: :status,
  failed_when: :failed,
  loading_when: :loading
  success_when: :deployed # specify the success state
```
</Option>

---

# Installation

## Requirements

- Ruby on Rails >= 6.1
- Ruby >= 3.1
- `api_only` set to `false`. More here.
- `propshaft` or `sprockets` gem
- Have the `secret_key_base` defined in  any of the following `ENV["SECRET_KEY_BASE"]`, `Rails.application.credentials.secret_key_base`, or `Rails.application.secrets.secret_key_base`

:::warning Zeitwerk autoloading is required.
When adding Avo to a Rails app that was previously a Rails 5 app you must ensure that it uses zeitwerk for autoloading and Rails 6.1 or higher defaults.

```ruby
# config/application.rb
config.autoloader = :zeitwerk
config.load_defaults 6.1 # 6.1 or higher, depending on your rails version
```
:::

## Installing Avo

### 1. One-command install

Use [this](https://railsbytes.com/public/templates/zyvsME) app template for a one-liner install process.

Run this command which will run all the required steps to install Avo in your app.

```
bin/rails app:template LOCATION='https://avohq.io/app-template'
```

### 2. Manual, step by step.

1. Add the appropiate Avo gem to the `Gemfile`

:::info
Please use this guide to find the best authentication strategy for your use-case.
:::

2. Run `bundle install`.
3. Run `bin/rails generate avo:install` to generate the initializer and add Avo to the `routes.rb` file.
4. Generate an Avo Resource

:::info
This will mount the app under `/avo` path. Visit the link to see the result.
:::

### 3. In popular Rails starter kits

We have integrations with the most popular starter kits.

#### Bullet Train

Avo comes pre-installed in all new Bullet Train applications.

I you have a Bullet Train app and you'd like to add Avo, please user [this template](https://avohq.io/templates/bullet-train).

```ruby
bin/rails app:template LOCATION=https://v3.avohq.io/templates/bullet-train.template
```

#### Jumpstart Pro

To install Avo in a Jumpstart Pro app use [this template](https://avohq.io/templates/jumpstart-pro).

```ruby
bin/rails app:template LOCATION=https://v3.avohq.io/templates/jumpstart-pro.template
```

## Install from GitHub

You may also install Avo from GitHub but when you do that you must compile the assets yourself. You do that using the `rake avo:build-assets` command.
When pushing to production, make sure you build the assets on deploy time using this task.

```ruby
# Rakefile
Rake::Task["assets:precompile"].enhance do
  Rake::Task["avo:build-assets"].execute
end
```

:::info
If you don't have the `assets:precompile` step in your deployment process, please adjust that with a different step you might have like `db:migrate`.
:::

## Mount Avo to a subdomain

You can use the regular `host` constraint in the `routes.rb` file.

```ruby
constraint host: 'avo' do
  mount_avo at: '/'
end
```

## Next steps

Please follow the next steps to ensure your app is secured and you have access to all the features you need.

1. Set up authentication and tell Avo who is your `current_user`. This step is required for the authorization feature to work.
1. Set up authorization. Don't let your data be exposed. Give users access to the data they need to see.
1. Set up licensing.

---

# Gem server authentication

Avo comes in a few tiers. The Community tier which comes as a free gem available on rubygems.org and a few paid tiers which come in private gems hosted on our own private gems server (packager.dev).

In order to have access to the paid gems you must authenticate using the **Gem Server Token** found on your [license page](https://v3.avohq.io/licenses).

There are a few ways to do that, but we will focus on the most important and secure ones for [on the server and CI systems](#on-the-server-and-ci-systems) and [on your local development environment](#on-your-local-development-environment).

:::info
We'll use the `xxx` notiation instead of the actual gem server token.
:::

## On the server and CI systems

:::info Recommendation
This is the recommended way for most use cases.
:::

The best way to do it is to register this environment variable so bundler knows to use it when pulling packages from [`packager.dev`](https://packager.dev).

```bash
export BUNDLE_PACKAGER__DEV=xxx
# or
BUNDLE_PACKAGER__DEV=xxx bundle install
```

Each hosting service will have their own way to add environment variables. Check out how to do it on [Heroku](#Heroku), [Hatchbox](#Hatchbox), [Docker](#docker_and_docker_compose), [Kamal](#Kamal) or [GitHub Actions](#git_hub_actions).

:::warning Warning about using the `.env` file
You might be tempted to add the token to your `.env` file, as you might do with your Rails app.
That will not work because `bundler` will not automatically load those environment variables.

You should add the environment variable through the service dedicated page or by running the `export` command before `bundle install`.
:::

## On your local development environment

For your local development environment you should add the token to the default bundler configuration.
This way `bundler` is aware of it without having to specify it in the `Gemfile`.

```bash
bundle config set --global https://packager.dev/avo-hq/ xxx
```

## Add Avo to your `Gemfile`

Now you are ready to add Avo to your `Gemfile`.

Now you can run `bundle install` and `bundler` will pick it up and use it to authenticate on the server.

<Option name="Heroku">

If you're using heroku, you can set the environment variable using the following command. This way `bundler` will use it when authenticating to `packager.dev`.

```bash
heroku config:set BUNDLE_PACKAGER__DEV=xxx
```
</Option>

<Option name="Hatchbox">

If you're using Hatchbox, you can set the environment variable in your apps "Environment" tab. This way `bundler` will use it when authenticating to `packager.dev`.

```yaml
BUNDLE_PACKAGER__DEV: xxx
```
</Option>

<Option name="GitHub Actions">

You might need to install Avo's paid gems in you GitHub Actions pipeline. There are two steps you need to take in order to enable that.

#### 1. Add `BUNDLE_PACKAGER__DEV` to your repository's secrets

Go in your repo, under Settings -> Secrets and Variables -> Actions -> New repository secret and add your Gem server token there with the name `BUNDLE_PACKAGER__DEV` and the token as the value.

<Image src="/assets/img/3_0/gem-server-authentication/github-actions.png" width="2462" height="1816" alt="" />
<Image src="/assets/img/3_0/gem-server-authentication/new-secret.png" width="2462" height="1816" alt="" />

#### 2. Expose `BUNDLE_PACKAGER__DEV` as an environment variable

Then, in your `test.yml` (you might have it as a different name), expose that configuration item as an environment variable.

```yml{8-9}
name: Tests

on:
  pull_request:
    branches:
      - main

env:
  BUNDLE_PACKAGER__DEV: ${{secrets.BUNDLE_PACKAGER__DEV}}

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      # Testing and deployment steps
```
</Option>

<Option name="Docker and docker compose">

You can build with docker by passing a build argument from your environment.

```dockerfile{8,10}
FROM ruby:3.2.2
RUN apt-get update -qq && apt-get install -y nodejs postgresql-client
WORKDIR /app
COPY Gemfile /app/Gemfile
COPY Gemfile.lock /app/Gemfile.lock

# get the build argument
ARG BUNDLE_PACKAGER__DEV
# make it available in the docker image
ENV BUNDLE_PACKAGER__DEV=$BUNDLE_PACKAGER__DEV

RUN bundle install
COPY . /app
# do more stuff
```

```bash
# Pass the key to the build argument
docker build --build-arg BUNDLE_PACKAGER__DEV=xxx

# OR

# Set the key as an environment variable on your machine
# Somewhere in your `.bashrc` or `.bash_profile` file
export BUNDLE_PACKAGER__DEV=xxx
# Then pass it to the build argument from there
docker build --build-arg BUNDLE_PACKAGER__DEV=$BUNDLE_PACKAGER__DEV
```

```bash
docker compose build --build-arg BUNDLE_PACKAGER__DEV=xxx
```

</Option>

<Option name="Kamal">

Kamal setup is very similar to Docker: include `BUNDLE_PACKAGER__DEV` in your secrets and then use it in your `Dockerfile`.

In your `deploy.yml`:

```yaml
# Configure builder setup.

builder:
  arch: amd64
  secrets:
    - BUNDLE_PACKAGER__DEV
```

Then in `.kamal/secrets`:

```
# However you set your secrets in Kamal
BUNDLE_PACKAGER__DEV=xxx
```

Finally, in your `Dockerfile`:

```dockerfile
# Install application gems
COPY Gemfile Gemfile.lock ./

RUN --mount=type=secret,id=BUNDLE_PACKAGER__DEV BUNDLE_PACKAGER__DEV=$(cat /run/secrets/BUNDLE_PACKAGER__DEV) bundle install  && \
    rm -rf ~/.bundle/ "${BUNDLE_PATH}"/ruby/*/cache "${BUNDLE_PATH}"/ruby/*/bundler/gems/*/.git && \
    bundle exec bootsnap precompile --gemfile
```

</Option>

## Bundle without paid gems

If you need to distribute your Rails app without the paid gems you can move them to an optional group.

```bash
RAILS_GROUPS=avo BUNDLE_WITH=avo bundle install
```

```ruby
# Gemfile
gem 'avo',

group :avo, optional: true do
  source "https://packager.dev/avo-hq/" do
    gem "avo-advanced", "~> 3.17"
  end
end
```

## FAQ

Frequently asked questions:

<Option name="`Forbidden 403`">

If you're seeing this error `Retrying download gem from https://packager.dev/avo-hq/ due to error (1/4): Gem::RemoteFetcher::FetchError bad response Forbidden 403`, this probably means that bundler does not have access to the `BUNDLE_PACKAGER__DEV` environment variable.

Please read the guides above on how to set that on your development machine and in deployment scenarios.
</Option>

---

# License troubleshooting

There might be times when the configurations isn't up to date and you'd like to troubleshoot it. There are a couple of things you can do to perform a self-diagnostics session.

## Check the license status page

Every Avo app has the license status page where you can see a few things about your license and the response from the license checking server.

Go to `https://yourapp.com/avo/avo_private/status`. If you mounted Avo under a different path (like `admin`) it will be `https://yourapp.com/admin/avo_private/status`.

In order to see that page your user has to be an an admin in Avo. Follow this guide to mark your user as an admin.

This should tell you if the license authenticated correctly, what is your used license key and what was the response from our checking server.

## Frequent issues

<Option name="License key not properly set on the server">

The most frequent scenario is to not have the license key set on the server.
If you use environment variables to register it in your app you should make sure your key is properly set on your production server.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.license_key = ENV["AVO_LICENSE_KEY"]
end
```

In order to check that, use the status page described above.

</Option>

---

# Authentication

With Avo, you have the flexibility to build apps either with or without authentication. While Avo has minimal assumptions about its users, a few guidelines still apply:

1. Users can be either authenticated or not. Avo apps can be developed without requiring user authentication.
2. If you choose to implement authentication, you need to [define the current_user](#customize-the-current-user-method).
3. You can assign [lightweight roles](#user-roles) to your users.
4. Any authentication strategy or gem of your choice can be utilized.

:::info Rails 8 authentication scaffold
In essence, the [authentication scaffold](https://github.com/rails/rails/pull/52328) that Rails 8 comes with is custom authentication so we need to do a few things to ensure it's working.

Please follow this guide to enable it.
:::

## Customize the `current_user` method

Avo will not assume your authentication provider (the `current_user` method returns `nil`). That means that you have to tell Avo who the `current_user` is.

<Option name="Rails authentication scaffold">

Please follow this guide to Rails' authentication scaffold.

</Option>

<Option name="Devise">

For [devise](https://github.com/heartcombo/devise), you should set it to `current_user`.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_method = :current_user
end
```
</Option>

<Option name="Other methods">

Using another authentication provider, you may customize the `current_user` method to something else.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_method = :current_admin
end
```

If you get the current user from another object like `Current.user`, you may pass a block to the `current_user_method` key.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_method do
    Current.user
  end
end
```

</Option>

## Customize the sign-out link

If your app responds to `destroy_user_session_path`, a sign-out menu item will be added on the bottom sidebar (when you click the three dots). If your app does not respond to this method, the link will be hidden unless you provide a custom sign-out path. There are two ways to customize the sign-out path.

### Customize the current user resource name

You can customize just the "user" part of the path name by setting `current_user_resource_name`. For example if you follow the `User` -> `current_user` convention, you might have a `destroy_current_user_session_path` that logs the user out.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_resource_name = :current_user
end
```

Or if your app provides a `destroy_current_admin_session_path` then you would need to set `current_user_resource_name` to `current_admin`.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_resource_name = :current_admin
end
```

### Customize the entire sign-out path

Alternatively, you can customize the sign-out path name completely by setting `sign_out_path_name`. For example, if your app provides `logout_path` then you would pass this name to `sign_out_path_name`.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.sign_out_path_name = :logout_path
end
```

If both `current_user_resource_name` and `sign_out_path_name` are set, `sign_out_path_name` takes precedence.

## Filter out requests

You probably do not want to allow Avo access to everybody. If you're using [devise](https://github.com/heartcombo/devise) in your app, use this block to filter out requests in your `routes.rb` file.

```ruby
authenticate :user do
  mount_avo at: '/avo'
end
```

You may also add custom user validation such as `user.admin?` to only permit a subset of users to your Avo instance.

```ruby
authenticate :user, -> user { user.admin? } do
  mount_avo at: '/avo'
end
```

Check out more examples of authentication on [sidekiq's authentication section](https://github.com/mperham/sidekiq/wiki/Monitoring#authentication).

## `authenticate_with` method

Alternatively, you can use the `authenticate_with` config attribute. It takes a block and evaluates it in Avo's `ApplicationController` as a `before_action`.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.authenticate_with do
    authenticate_admin_user
  end
end
```

Note that Avo's `ApplicationController` does not inherit from your app's `ApplicationController`, so any protected methods you defined would not work. Instead, you would need to explicitly write the authentication logic in the block. For example, if you store your `user_id` in the session hash, then you can do:

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.authenticate_with do
    redirect_to '/' unless session[:user_id] == 1 # hard code user ids here
  end
end
```

## User roles

There might be cases where you want to signal to Avo that the current user has a role.

Avo roles are very lightweight and that's for a reason. Building with roles in mind requires a bit more integration with the parent app. This is something that you can definitely take upon yourself to build if you need it.

There are two extra roles that you can give to a user, besides the regular user. These roles can be assigned with a check on the `current_user` object.

<Option name="1. Admin user">

The check that Avo will do to figure that out is to run the `is_admin?` method on the [`current_user`](#customize-the-current-user-method) object.

#### Check if a user is an admin

You can do that check yourself using the `Avo::Current.user_is_admin?`.

#### When does Avo check if the user is an admin (`is_admin?`)

Avo doesn't use this setting momentarily but might in the future.

</Option>

<Option name="2. Developer user">

There might be cases where you want to signal that a user is a developer. The developer will be able to see extra things like long backtrace messages in errors.

The check that Avo will do to figure that out is to run the `is_developer?` method on the [`current_user`](#customize-the-current-user-method) object.

### Check if a user is an developer

You can do that check yourself using the `Avo::Current.user_is_developer?`.

### When does Avo check if the use is an developer (`is_developer?`)

Avo uses this role to display long backtraces on non-validation errors.
Ex: on record save, you might call an API which by some reason errors out. Instead of just getting a generic "Something went wrong" error, the developer user will see the error message and backtrace

<Image src="/assets/img/3_0/authentication/backtrace.png" alt="Backtrace alert" width="1602" height="780" />

</Option>

### Customize the methods that check for roles

You may customize the methods that Avo uses to assign roles in the initializer.

```ruby
# config/avo.rb
Avo.configure do |config|
  config.is_admin_method = :is_admin?
  config.is_developer_method = :is_developer?
end
```

## Authorization

When you share access to Avo with your clients or large teams, you may want to restrict access to a resource or a subset of resources. You should set up your authorization rules (policies) to do that. Check out the authorization page for details on how to set that up.

---

# Authorization

When you share access to Avo with your clients or large teams, you may want to restrict access to a resource or a subset of resources. One example may be that only admin-level users may delete or update records.

Avo provides a [Pundit](https://github.com/varvet/pundit) client out of the box for authorization that uses a policy system to manage access.

:::info Pundit alternative
Pundit is just the default client. You may plug in your own client using the instructions [here](#custom-authorization-clients).
You can use [this](https://github.com/avo-hq/avo/issues/1922) `action_policy` client as well.
:::

:::warning
You must manually require `pundit` or your authorization library in your `Gemfile`.

```ruby
# Minimal authorization through OO design and pure Ruby classes
gem "pundit"
```
And update config/initializers/avo.rb with following configuration:
```ruby
# Example of enabling authorization client in Avo configuration
config.authorization_client = :pundit
```
:::

## Ensure Avo knows who your current user is

Before setting any policies up, please ensure Avo knows your current user. Usually, this ðŸ‘‡ set up should be fine, but follow the authentication guide for more information.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.current_user_method = :current_user
end
```

## Policies

Just run the regular pundit `bin/rails g pundit:policy Post` to generate a new policy.

**If this is a new app you need to install pundit first <code>bin/rails g pundit:install</code>.**

With this new policy, you may control what every type of user can do with Avo. The policy has the default methods for the regular controller actions: `index?`, `show?`, `create?`, `new?`, `update?`, `edit?` and `destroy?`.

These methods control whether the resource appears on the sidebar, if the view/edit/destroy buttons are visible or if a user has access to those index/show/edit/create pages.

<Option name="index?">

`index?` is used to display/hide the resources on the sidebar and restrict access to the resources **Index** view.

:::info
  This option is used in the **auto-generated menu**, not in the **menu editor**.

  You'll have to use your own logic in the `visible` block for that.
:::

</Option>

<Option name="`show?`">

When setting `show?` to `false`, the user will not see the show icon on the resource row and will not have access to the **Show** view of a resource.

</Option>

<Option name="`create?`">

The `create?` method will prevent the users from creating a resource. That will also apply to the `Create new {model}` button on the <Index />, the `Save` button on the `/new` page, and `Create new {model}` button on the association `Show` page.

</Option>

<Option name="`new?`">

The `new?` method will control whether the users can save the new resource. You can also access the `record` variable with the form values pre-filled.

</Option>

<Option name="`edit?`">

`edit?` to `false` will hide the edit button on the resource row and prevent the user from seeing the edit view.

</Option>

<Option name="`update?`">

`update?` to `false` will prevent the user from updating a resource. You can also access the `record` variable with the form values pre-filled.

</Option>

<Option name="`destroy?`">

`destroy?` to `false` will prevent the user from destroying a resource and hiding the delete button.

:::info More granular file authorization
These are per-resource and general settings. If you want to control the authorization per individual file, please see the [granular settings](#attachments).
:::

</Option>

<Option name="`act_on?`">

Controls whether the user can see the actions button on the <Index /> page.

</Option>

<Option name="`reorder?`">

Controls whether the user can see the records reordering buttons on the <Index /> page.

<Image src="/assets/img/authorization/actions_button.jpg" width="1220" height="632" alt="Actions button" />

</Option>

<Option name="`search?`">

Controls whether the user can see the resource search input on top of the <Index /> page.

</Option>

<Option name="`preview?`">

<VersionReq version="3.18.0" />

Controls access to the preview endpoint, which is triggered by the preview field.

:::info
This policy method does not control the visibility of the preview field. It only manages authorization at the endpoint level. To hide the preview field, use the `visible` field option.
:::

</Option>

## Associations

When using associations, you would like to set policies for `creating` new records on the association, allowing to `attach`, `detach`, `create` or `destroy` relevant records. Again, Avo makes this easy using a straightforward naming schema.

:::warning
Make sure you use the same pluralization as the association name.

For a `has_many :users` association use the plural version method `view_users?`, `edit_users?`, `detach_users?`, etc., not the singular version `detach_user?`.
:::

### Example scenario

We'll have this example of a `Post` resource with many `Comment`s through the `has_many :comments` association.

:::info The `record` variable in policy methods
In the `Post` `has_many` `Comments` example, when you want to authorize `show_comments?` in `PostPolicy` you will have a `Comment` instance as the `record` variable, but when you try to authorize the `attach_comments?`, you won't have that `Comment` instance because you want to create one, but we expose the parent `Post` instance so you have more information about that authorization action that you're trying to make.
:::

<Option name="`attach_{association}?`">

Controls whether the `Attach comment` button is visible. The `record` variable is the parent record (a `Post` instance in our scenario).

<Image src="/assets/img/authorization/attach.jpg" width="1224" height="692" alt="" />

</Option>
<Option name="`detach_{association}?`">

Controls whether the **detach button is available** on the associated record row on the <Index /> view. The `record` variable is the actual row record (a `Comment` instance in our scenario).

<Image src="/assets/img/authorization/detach.jpg" width="1224" height="692" alt="" />

</Option>
<Option name="`view_{association}?`">

Controls whether the whole association is being displayed on the parent record. The `record` variable is the actual row record (a `Comment` instance in our scenario).

</Option>
<Option name="`show_{association}?`">

Controls whether the **view button is visible** on the associated record row on the <Index /> page. The `record` variable is the actual row record (a `Comment` instance in our scenario).

:::warning
This **does not** control whether the user has access to that record. You control that using the Policy of that record (`PostPolicy.show?` in our example).
:::

<Image src="/assets/img/authorization/show.jpg" width="1224" height="692" alt="" />

:::info Difference between `view_{association}?` and `show_{association}?`
Let's take a `Post` `has_many` `Comment`s.

When you use the `view_comments?` policy method you get the `Post` instance as the `record` and you control if the whole listing of comments appears on that record's <Show /> page.

When you use `show_comments?` policy method, the `record` variable is each `Comment` instance and you control whether the view button is displayed on each individual row.
:::

</Option>
<Option name="`edit_{association}?`">

Controls whether the **edit button is visible** on the associated record row on the <Index /> page.The `record` variable is the actual row record (a `Comment` instance in our scenario).

:::warning
This **does not** control whether the user has access to that record's edit page. You control that using the Policy of that record (`PostPolicy.show?` in our example).
:::

<Image src="/assets/img/authorization/edit.jpg" width="1224" height="692" alt="" />
</Option>

<Option name="`create_{association}?`">

Controls whether the `Create comment` button is visible. The `record` variable is the parent record (a `Post` instance in our scenario).

<Image src="/assets/img/authorization/create.jpg" width="1224" height="692" alt="" />

</Option>
<Option name="`destroy_{association}?`">

Controls whether the **delete button is visible** on the associated record row on the <Index /> page.The `record` variable is the actual row record (a `Comment` instance in our scenario).

<Image src="/assets/img/authorization/destroy.jpg" width="1224" height="692" alt="" />

</Option>
<Option name="`act_on_{association}?`">

Controls whether the `Actions` dropdown is visible. The `record` variable is the parent record (a `Post` instance in our scenario).

<Image src="/assets/img/authorization/actions.jpg" width="1224" height="692" alt="" />

</Option>
<Option name="`reorder_{association}?`">

Controls whether the user can see the records reordering buttons on the `has_many` <Index /> page.
</Option>

## Removing duplication

:::info A note on duplication
Let's take the following example:

A `User` has many `Contract`s. And you represent that in your Avo resource. How do you handle authorization to the `ContractResource`?

For one, you set the `ContractPolicy.index?` and `ContractPolicy.edit?` methods to `false` so regular users don't have access to all contracts (see and edit), and the `UserPolicy.view_contracts?` and `UserPolicy.edit_contracts?` set to `false`, because, when viewing a user you want to see all the contracts associated with that user and don't let them edit it.

You might be thinking that there's code duplication here. "Why do I need to set a different rule for `UserPolicy.edit_contracts?` when I already set the `ContractPolicy.edit?` to `false`? Isn't that going to take precedence?"

Now, let's imagine we have a user that is an admin in the application. The business need is that an admin has access to all contracts and can edit them. This is when we go back to the `ContractPolicy.edit?` and turn that to true for the admin user. And now we can separately control who and where a user can edit a contract.
:::

You may remove duplication by applying the same policy rule from the original policy.

```ruby
class CommentPolicy
  # ... more policy methods
  def edit
    record.user_id == current_user.id
  end
end

class PostPolicy
  # ... more policy methods
  def edit_comments?
    Pundit.policy!(user, record).edit?
  end
end
```

Now, whatever action you take for one comment, it will be available for the `edit_comments?` method in `PostPolicy`.

<VersionReq version="2.31" />

From version 2.31 we introduced a concern that removes the duplication and helps you apply the same rules to associations. You should include `Avo::Pro::Concerns::PolicyHelpers` in the `ApplicationPolicy` for it to be applied to all policy classes.

`PolicyHelpers` allows you to use the method `inherit_association_from_policy`. This method takes two arguments; `association_name` and the policy file you want to be used as a template.

```ruby
inherit_association_from_policy :comments, CommentPolicy
```

With just one line of code, it will define the following methods to policy your association:

```ruby
def create_comments?
  CommentPolicy.new(user, record).create?
end

def edit_comments?
  CommentPolicy.new(user, record).edit?
end

def update_comments?
  CommentPolicy.new(user, record).update?
end

def destroy_comments?
  CommentPolicy.new(user, record).destroy?
end

def show_comments?
  CommentPolicy.new(user, record).show?
end

def reorder_comments?
  CommentPolicy.new(user, record).reorder?
end

def act_on_comments?
  CommentPolicy.new(user, record).act_on?
end

def view_comments?
  CommentPolicy.new(user, record).index?
end

# Since Version 3.10.0

def attach_comments?
  CommentPolicy.new(user, record).attach?
end

def detach_comments?
  CommentPolicy.new(user, record).detach?
end
```

Although these methods won't be visible in your policy code, you can still override them. For instance, if you include the following code in your `CommentPolicy`, it will be executed in place of the one defined by the helper:

```ruby
inherit_association_from_policy :comments, CommentPolicy

def destroy_comments?
  false
end
```

## Attachments

<VersionReq version="2.28" />

When working with files, it may be necessary to establish policies that determine whether users can `upload`, `download` or `delete` files. Fortunately, Avo simplifies this process by providing a straightforward naming schema for these policies.

Both the `record` and the `user` will be available for you to access.

<Image src="/assets/img/authorization/file_actions.png" width="472" height="93" alt="" />

<Option name="`upload_{FIELD_ID}?`">

Controls whether the user can upload the attachment.
</Option>

<Option name="`download_{FIELD_ID}?`">

Controls whether the user can download the attachment.
</Option>

<Option name="`delete_{FIELD_ID}?`">

Controls whether the user can destroy the attachment.
</Option>

:::info AUTHORIZE IN BULK
If you want to allow or disallow these methods in bulk you can use a little meta-programming to assign all the same value.

```ruby
[:cover_photo, :audio].each do |file|
  [:upload, :download, :delete].each do |action|
    define_method "#{action}_#{file}?" do
      true
    end
  end
end
```
:::

## Scopes

You may specify a scope for the <Index />, <Show />, and <Edit /> views.

```ruby{3-9}
class PostPolicy < ApplicationPolicy
  class Scope < Scope
    def resolve
      if user.admin?
        scope.all
      else
        scope.where(published: true)
      end
    end
  end
end
```

:::warning
This scope will be applied only to the <Index /> view of Avo. It will not be applied to the association view.

Example:

A `Post` has_many `Comment`s. The `CommentPolicy::Scope` will not affect the `has_many` field. You need to add the `scope` option to the `has_many` field where you can modify the query.

```ruby
# The `parent` is the Post instance that the user is seeing. ex: Post.find(1)
# The `query` is the Active Record query being done on the comments. ex: post.comments
field :comments, as: :has_many, scope: -> { Pundit.policy_scope(parent, query) }
```
:::

## Using different policy methods

By default Avo will use the generated Pundit methods (`index?`, `show?`, `create?`, `new?`, `update?`, `edit?` and `destroy?`). But maybe, in your app, you're already using these methods and would like to use different ones for Avo. You may want override these methods inside your configuration with a simple map using the `authorization_methods` key.

```ruby{6-14}
Avo.configure do |config|
  config.root_path = '/avo'
  config.app_name = 'Avocadelicious'
  config.license_key = ENV['AVO_LICENSE_KEY']
  config.authorization_methods = {
    index: 'avo_index?',
    show: 'avo_show?',
    edit: 'avo_edit?',
    new: 'avo_new?',
    update: 'avo_update?',
    create: 'avo_create?',
    destroy: 'avo_destroy?',
    search: 'avo_search?',
  }
end
```

Now, Avo will use `avo_index?` instead of `index?` to manage the **Index** view authorization.

## Use Resource's Policy to authorize custom actions

It may be necessary to authorize a specific field or custom action of a resource using a policy class rather than defining the authorization logic directly within the resource class. By doing so, we can delegate control to the policy class, ensuring a cleaner and more maintainable authorization structure.

:::code-group
```ruby [app/resources/product.rb]{8}
field :amount,
      as: :money,
      currencies: %w[USD],
      sortable: true,
      filterable: true,
      copyable: true,
      # define ability to change the amount in policy class instead of doing it here
      disabled: -> { !@resource.authorization.authorize_action(:amount?, raise_exception: false) }
```
```ruby [app/policies/product_policy.rb]{2-4}
# Define ability to change the amount in Product Policy
def amount?
  user.admin?
end

```
:::

## Raise errors when policies are missing

The default behavior of Avo is to allow missing policies for resources silently. So, if you have a `User` model and a `Avo::Resources::User` but don't have a `UserPolicy`, Avo will not raise errors regarding missing policies and authorize that resource.

If, however, you need to be on the safe side of things and raise errors when a Resource is missing a Policy, you can toggle on the `raise_error_on_missing_policy` configuration.

```ruby{7}
# config/initializers/avo.rb
Avo.configure do |config|
  config.root_path = '/avo'
  config.app_name = 'Avocadelicious'
  config.license_key = ENV['AVO_LICENSE_KEY']
  config.raise_error_on_missing_policy = true
end
```

Now, you'll have to provide a policy for each resource you have in your app, thus making it a more secure app.

## Logs
<VersionReq version="3.11.7" />
Developers have the ability to monitor any unauthorized actions. When a developer user makes a request that triggers an unauthorized action, a log entry similar to the following will be generated:

In development each log entry provides details about the policy class, the action attempted, the global id of the user who made the request, and the global id of the record involved:
```bash
web     | [Avo->] Unauthorized action 'reorder?' for 'UserPolicy'
web     | user: gid://dummy/User/20
web     | record: gid://dummy/User/31
```

To find a record based on its global id you can use `GlobalID::Locator.locate`

```ruby
gid = "gid://dummy/User/20"
user = GlobalID::Locator.locate(gid)
```

In production each log entry provides details only about the policy class and the attempted action:
```bash
web     | [Avo->] Unauthorized action 'act_on?' for 'UserPolicy'
```

## Custom policies

<VersionReq version="2.17" />

By default, Avo will infer the policy from the model of the resource object. If you wish to use a different policy for a given resource, you can specify it directly in the resource using the `authorization_policy` option.

```ruby
# app/avo/resources/photo_comment.rb
class Avo::Resources::PhotoComment < Avo::BaseResource
  self.model_class = "Comment"
  self.authorization_policy = PhotoCommentPolicy
  # ...
end
```

## Custom authorization clients

:::info
Check out the [Pundit client](https://github.com/avo-hq/avo/blob/main/lib/avo/services/authorization_clients/pundit_client.rb) for reference.
:::

### Change the authorization client

In order to use a different client change the `authorization_client` option in the initializer.

The built-in possible values are `nil` and `:pundit`.

When you create your own client, pass the class name.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.authorization_client = 'Services::AuthorizationClients::CustomClient'
end
```

### Client methods

Each authorization client must expose a few methods.

<Option name="`authorize`">

Receives the `user`, `record`, `action`, and optionally, the `policy_class` (you may want to use custom policy classes for some resources).

```ruby
# Pundit example
def authorize(user, record, action, policy_class: nil)
  Pundit.authorize(user, record, action, policy_class: policy_class)
rescue Pundit::NotDefinedError => error
  raise NoPolicyError.new error.message
rescue Pundit::NotAuthorizedError => error
  raise NotAuthorizedError.new error.message
end
```

</Option>
<Option name="`policy`">

Receives the `user` and `record` and returns the policy to use.

```ruby
def policy(user, record)
  Pundit.policy(user, record)
end
```

</Option>
<Option name="`policy!`">

Receives the `user` and `record` and returns the policy to use. It will raise an error if no policy is found.

```ruby
def policy!(user, record)
  Pundit.policy!(user, record)
rescue Pundit::NotDefinedError => error
  raise NoPolicyError.new error.message
end
```

</Option>
<Option name="`apply_policy`">

Receives the `user`, `record`, and optionally, the policy class to use. It will apply a scope to a query.

```ruby
def apply_policy(user, model, policy_class: nil)
  # Try and figure out the scope from a given policy or auto-detected one
  scope_from_policy_class = scope_for_policy_class(policy_class)

  # If we discover one use it.
  # Else fallback to pundit.
  if scope_from_policy_class.present?
    scope_from_policy_class.new(user, model).resolve
  else
    Pundit.policy_scope!(user, model)
  end
rescue Pundit::NotDefinedError => error
  raise NoPolicyError.new error.message
end
```
</Option>

## Explicit authorization

<Option name="`explicit_authorization`">

:::warning Option Renamed
In versions between <Version version="3.13.4" /> and <Version version="3.13.6" />, this option is named `implicit_authorization`.
:::

<VersionReq version="3.13.4" />

 This option gives you control over how missing policy classes or methods are handled during authorization checks in your Avo application.

### Possible values

**`true`**
  - If a policy class or method is **missing** for a given resource or action, that action will automatically be considered **unauthorized**.
  - This behavior enhances security by ensuring that any unconfigured or unhandled actions are denied by default.

**`false`**
  - If a policy class or method is **missing**, the action will be considered **authorized** by default.

**`Proc`**
  - You can also set `explicit_authorization` as a `Proc` to apply custom logic. Within this block, you gain access to all attributes of `Avo::ExecutionContext`

    For example:

    ```ruby
    config.explicit_authorization = -> {
      current_user.access_to_admin_panel? && !current_user.admin?
    }
    ```

    In this case, missing policies will be handled based on the condition: if the user has access to the admin panel but isn't an admin, the `explicit_authorization` will be enabled. This option allows you to customize authorization decisions based on the context of the current user or other factors.
### Default

- For **new applications** (starting from Avo `3.13.4`) the default value for `explicit_authorization` is `true`. This provides a more secure out-of-the-box experience by ensuring actions without explicit authorization are denied.

- For **existing applications** upgrading to `3.13.4` or later the default value for `explicit_authorization` remains `false` to preserve backward compatibility. Existing applications will retain the permissive behavior unless explicitly changed.

### Configuration:

You can configure this setting in your `config/avo.rb` file:

```ruby{4}
Avo.configure do |config|
  # Set to true to deny access when policies or methods are missing
  # Set to false to allow access when policies or methods are missing
  config.explicit_authorization = true
end
```

### Examples:

1. **When `explicit_authorization` is `true`**
    - **Scenario**: You have a `Post` resource, but there is no policy class defined for it.
    - **Result**: All actions for the `Post` resource (index, show, create, etc.) will be **unauthorized** unless you explicitly define a policy class and methods for those actions.

    ---
    - **Scenario**: You have a `Post` resource, and the policy class defined for it only defines the `show?` method.

    ```ruby
    class PostPolicy < ApplicationPolicy
      def show?
        user.admin?
      end
    end
    ```
    - **Result**: In this case, since the `PostPolicy` lacks an `index?` method, attempting to access the `index` action will be denied by default.

2. **When `explicit_authorization: false`**
    - **Scenario**: Same `Post` resource without a policy class.
    - **Result**: All actions for the `Post` resource will be **authorized** even though there are no explicit policy methods. This could expose unintended behavior, as any unprotected action will be accessible.

    ---

    - **Scenario**: You have a `Post` resource, and the policy class defined for it only defines the `show?` method.
    ```ruby
    class PostPolicy < ApplicationPolicy
      def show?
        user.admin?
      end
    end
    ```
    - **Result**: In this case, missing methods like `index?` will allow access to the `index` action by default.

### Migration Recommendations:

- **For applications after from Avo `3.13.4`**

    It is recommended to leave `explicit_authorization` set to `true`, ensuring all actions must be explicitly authorized to prevent unintentional access.

- **For applications before from Avo `3.13.4`**

    - If upgrading from an earlier version, carefully review your policies before enabling `explicit_authorization`. Missing policy methods that were previously allowing access will now deny access unless explicitly defined.

    - Itâ€™s recommended to disable `raise_error_on_missing_policy` in production, though it's not mandatory. When `explicit_authorization` is set to `true`, the default behavior is to deny access for actions without a defined policy. In this case, itâ€™s often better to show an unauthorized message to users rather than raise an error. However, keeping `raise_error_on_missing_policy` enabled in development can be helpful for identifying missing policy classes.
</Option>

## Rolify integration

Check out this guide to add rolify role management with Avo.

---

# Resource options

Avo effortlessly empowers you to build an entire customer-facing interface for your Ruby on Rails application. One of the most powerful features is how easy you can administer your database records using the CRUD UI.

## Overview

Similar to how you configure your database layer using the Rails models and their DSL, Avo's CRUD UI is configured using `Resource` files.

Each `Resource` maps out one of your models. There can be multiple `Resource`s associated to the same model if you need that.

All resources are located in the `app/avo/resources` directory.

## Resources from model generation

```bash
bin/rails generate model car make:string mileage:integer
```

Running this command will generate the standard Rails files (model, controller, etc.) and `Avo::Resources::Car` & `Avo::CarsController` for Avo.

The auto-generated resource file will look like this:

```ruby
# app/avo/resources/car.rb
class Avo::Resources::Car < Avo::BaseResource
  self.includes = []
  # self.search = {
  #   query: -> { query.ransack(id_eq: params[:q], m: "or").result(distinct: false) }
  # }

  def fields
    field :id, as: :id
    field :make, as: :text
    field :mileage, as: :number
  end
end
```

This behavior can be omitted by using the argument `--skip-avo-resource`. For example if we want to generate a `Car` model but no Avo counterpart we should use the following command:

```bash
bin/rails generate model car make:string kms:integer --skip-avo-resource
```

## Manually defining resources

```bash
bin/rails generate avo:resource post
```

This command will generate the `Post` resource file in `app/avo/resources/post.rb` with the following code:

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.includes = []
  # self.search = {
  #   query: -> { query.ransack(id_eq: params[:q], m: "or").result(distinct: false) }
  # }

  def fields
    field :id, as: :id
  end
end
```

From this config, Avo will infer a few things like the resource's model will be the `Post` model and the name of the resource is `Post`. But all of those inferred things are actually overridable.

Now, let's say we already have a model `Post` well defined with attributes and associations. In that case, the Avo resource will be generated with the fields attributes and associations.

::: code-group

```ruby [app/models/post.rb]
# == Schema Information
#
# Table name: posts
#
#  id           :bigint           not null, primary key
#  name         :string
#  body         :text
#  is_featured  :boolean
#  published_at :datetime
#  user_id      :bigint
#  created_at   :datetime         not null
#  updated_at   :datetime         not null
#  status       :integer          default("draft")
#
class Post < ApplicationRecord
 enum status: [:draft, :published, :archived]

 validates :name, presence: true

 has_one_attached :cover_photo
 has_one_attached :audio
 has_many_attached :attachments

 belongs_to :user, optional: true
 has_many :comments, as: :commentable
 has_many :reviews, as: :reviewable

 acts_as_taggable_on :tags
end
```

```ruby [app/avo/resources/post.rb]
class Avo::Resources::Post < Avo::BaseResource
  self.includes = []
  # self.search = {
  #   query: -> { query.ransack(id_eq: params[:q], m: "or").result(distinct: false) }
  # }

  def fields
    field :id, as: :id
    field :name, as: :text
    field :body, as: :textarea
    field :is_featured, as: :boolean
    field :published_at, as: :datetime
    field :user_id, as: :number
    field :status, as: :select, enum: ::Post.statuses
    field :cover_photo, as: :file
    field :audio, as: :file
    field :attachments, as: :files
    field :user, as: :belongs_to
    field :comments, as: :has_many
    field :reviews, as: :has_many
    field :tags, as: :tags
  end
end
```

:::

It's also possible to specify the resource model class. For example, if we want to create a new resource named `MiniPost` resource using the `Post` model we can do that using the following command:

```bash
bin/rails generate avo:resource mini-post --model-class post
```

That command will create a new resource with the same attributes as the post resource above with specifying the `model_class`:

```ruby
class Avo::Resources::MiniPost < Avo::BaseResource
  self.model_class = "Post"
end
```

:::info
You can see the result in the admin panel using this URL `/avo`. The `Post` resource will be visible on the left sidebar.
:::

## Generating resources for all models

To generate Avo resources for all models in your application, run:

```bash
rails generate avo:all_resources
```

### What it does

1. Scans your `app/models` directory for all model files
2. Excludes `ApplicationRecord` from the generation process
3. For each model found, it:
   - Generates a corresponding Avo resource using the `avo:resource` generator
   - Handles errors gracefully, printing error messages if generation fails for any model

This is particularly useful when:
- Setting up Avo in an existing Rails application
- Ensuring all your models have corresponding Avo resources

## Fields

`Resource` files tell Avo what records should be displayed in the UI, but not what kinds of data they hold. You do that using the `fields` method.

Read more about the fields here.

```ruby{5-17}
class Avo::Resources::Post < Avo::BaseResource
  self.title = :id
  self.includes = []

  def fields
    field :id, as: :id
    field :name, as: :text, required: true
    field :body, as: :trix, placeholder: "Add the post body here", always_show: false
    field :cover_photo, as: :file, is_image: true, link_to_record: true
    field :is_featured, as: :boolean

    field :is_published, as: :boolean do
      record.published_at.present?
    end

    field :user, as: :belongs_to, placeholder: "â€”"
  end
end
```

## Routing

Avo will automatically generate routes based on the resource name when generating a resource.

```
Avo::Resources::Post         -> /avo/resources/posts
Avo::Resources::PhotoComment -> /avo/resources/photo_comments
```

If you change the resource name, you should change the generated controller name too.

## Use multiple resources for the same model

Usually, an Avo Resource maps to one Rails model. So there will be a one-to-one relationship between them. But there will be scenarios where you'd like to create another resource for the same model.

Let's take as an example the `User` model. You'll have an `User` resource associated with it.

```ruby
# app/models/user.rb
class User < ApplicationRecord
end

# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :gravatar, link_to_record: true, as_avatar: :circle
    field :first_name, as: :text, required: true, placeholder: "John"
    field :last_name, as: :text, required: true, placeholder: "Doe"
  end
end
```

<Image src="/assets/img/resources/model-resource-mapping-1.jpg" width="2048" height="1280" alt="" />

So when you click on the Users sidebar menu item, you get to the `Index` page where all the users will be displayed. The information displayed will be the gravatar image, the first and the last name.

Let's say we have a `Team` model with many `User`s. You'll have a `Team` resource like so:

```ruby{12}
# app/models/team.rb
class Team < ApplicationRecord
end

# app/avo/resources/team.rb
class Avo::Resources::Team < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :name, as: :text
    field :users, as: :has_many
  end
end
```

From that configuration, Avo will figure out that the `users` field points to the `User` resource and will use that one to display the users.

But, let's imagine that we don't want to display the gravatar on the `has_many` association, and we want to show the name on one column and the number of projects the user has on another column.
We can create a different resource named `TeamUser` resource and add those fields.

```ruby
# app/avo/resources/team_user.rb
class Avo::Resources::TeamUser < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :name, as: :text
    field :projects_count, as: :number
  end
end
```

We also need to update the `Team` resource to use the new `TeamUser` resource for reference.

```ruby
# app/avo/resources/team.rb
class Avo::Resources::Team < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :name, as: :text
    field :users, as: :has_many, use_resource: Avo::Resources::TeamUser
  end
end
```

<Image src="/assets/img/resources/model-resource-mapping-2.jpg" width="1524" height="714" alt="" />

But now, if we visit the `Users` page, we will see the fields for the `TeamUser` resource instead of `User` resource, and that's because Avo fetches the resources in an alphabetical order, and `TeamUser` resource is before `User` resource. That's definitely not what we want.
The same might happen if you reference the `User` in other associations throughout your resource files.

To mitigate that, we are going to use the `model_resource_mapping` option to set the "default" resource for a model.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.model_resource_mapping = {
    'User': 'Avo::Resources::User'
  }
end
```

That will "shortcircuit" the regular alphabetical search and use the `User` resource every time we don't specify otherwise.

We can still tell Avo which resource to use in other `has_many` or `has_and_belongs_to_many` associations with the `use_resource` option.

## Namespaced resources

`Resource`s can't be namespaced yet, so they all need to be in the root level of that directory. If you have a model `Super::Dooper::Trooper::Model` you can use `Avo::Resources::SuperDooperTrooperModel` with the `model_class` option.

```ruby
class Avo::Resources::SuperDooperTrooperModel < Avo::BaseResource
  self.model_class = "Super::Dooper::Trooper::Model"
end
```

## Views

Please read the detailed views page.

## Extending `Avo::ResourcesController`

You may need to execute additional actions on the `ResourcesController` before loading the Avo pages. You can create an `Avo::BaseResourcesController` and extend your resource controller from it.

```ruby
# app/controllers/avo/base_resources_controller.rb
class Avo::BaseResourcesController < Avo::ResourcesController
  include AuthenticationController::Authentication

  before_action :is_logged_in?
end

# app/controllers/avo/posts_controller.rb
class Avo::PostsController < Avo::BaseResourcesController
end
```

:::warning
You can't use `Avo::BaseController` and `Avo::ResourcesController` as **your base controller**. They are defined inside Avo.
:::

When you generate a new resource or controller in Avo, it won't automatically inherit from the `Avo::BaseResourcesController`. However, you have two approaches to ensure that the new generated controllers inherit from a custom controller:

### `--parent-controller` option on the generators
Both the `avo:controller` and `avo:resource` generators accept the `--parent-controller` option, which allows you to specify the controller from which the new controller should inherit. Here are examples of how to use it:

```bash
rails g avo:controller city --parent-controller Avo::BaseResourcesController
rails g avo:resource city --parent-controller Avo::BaseResourcesController
```

### `resource_parent_controller` configuration option
You can configure the `resource_parent_controller` option in the `avo.rb` initializer. This option will be used to establish the inherited controller if the `--parent-controller` argument is not passed on the generators. Here's how you can do it:

```ruby
Avo.configure do |config|
  # ...
  config.resource_parent_controller = "Avo::BaseResourcesController" # "Avo::ResourcesController" is default value
  # ...
end
```

### Attach concerns to `Avo::BaseController`

Alternatively you can use [this guide](https://avohq.io/blog/safely-extend-a-ruby-on-rails-controller) to attach methods, actions, and hooks to the main `Avo::BaseController` or `Avo::ApplicationController`.

## Manually registering resources

In order to have a more straightforward experience when getting started with Avo, we are eager-loading the `app/avo/resources` directory.
That makes all those resources available to your app without you doing anything else.

If you want to manually load them use the `config.resources` option.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.resources = [
    "Avo::Resources::User",
    "Avo::Resources::Fish",
  ]
end
```

This tells Avo which resources you use and stops the eager-loading process on boot-time.
This means that other resources that are not declared in this array will not show up in your app.

## Extending `Avo::BaseResource`

<VersionReq version="3.10.7" /> we have restructured the `Avo::BaseResource` to enhance user customization capabilities. The existing functionality has been moved to a new base class `Avo::Resources::Base`, and `Avo::BaseResource` is now left empty for user overrides. This allows users to easily add custom methods that all of their resources will inherit, without having to modify the internal base class.

### How to Customize `Avo::BaseResource`

You can customize `Avo::BaseResource` by creating your own version in your application. This custom resource can include methods and logic that you want all your resources to inherit. Here's an example to illustrate how you can do this:

```ruby
# app/avo/base_resource.rb
module Avo
  class BaseResource < Avo::Resources::Base
    # Example custom method: make all number fields cast their values to float
    def field(id, **args, &block)
      if args[:as] == :number
        args[:format_using] = -> { value.to_f }
      end

      super(id, **args, &block)
    end
  end
end
```

All your resources will now inherit from your custom `Avo::BaseResource`, allowing you to add common functionality across your admin interface. For instance, the above example ensures that all number fields in your resources will have their values cast to floats. You can add any other shared methods or customizations here, making it easier to maintain consistent behavior across all resources.

### Your resource files

Your resource file will still look the same as it did before.

```ruby
# app/avo/resources/post_resource.rb
module Avo::Resources::Post < Avo::BaseResource
  # Your existing configuration for the Post resource
end
```

## Resource Options

Resources have a few options available for customization.

<Option name="`self.title`">

Each Avo resource will try to figure out what the title of a record is. It will try the following attributes in order `name`, `title`, `label`, and fallback to the `id`.

You can change it to something more specific, like the model's `first_name` or `slug` attributes.

```ruby
class Avo::Resources::Post < Avo::BaseResource
  self.title = :slug # it will now reference @post.slug to show the title
end
```

### Using a computed title

If you don't have a `title`, `name`, or `label` attribute in the database, you can add a getter method to your model where you compose the name.

```ruby{3,8-10}
# app/avo/resources/comment.rb
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :tiny_name
end

# app/models/comment.rb
class Comment < ApplicationRecord
  def tiny_name
    ActionView::Base.full_sanitizer.sanitize(body).truncate 30
  end
end
```

### `title` as a block

If you prefer not to use any record methods and instead compute the resource's title directly within the resource itself, you can accomplish this by assigning a lambda function to the `title` class attribute. You'll have access to `resource` and `record`.

```ruby{3-5}
# app/avo/resources/comment.rb
class Avo::Resources::Comment < Avo::BaseResource
  self.title = -> {
    ActionView::Base.full_sanitizer.sanitize(record.body).truncate 30
  }
end
```
</Option>

<Option name="`self.description`">

You might want to display information about the current resource to your users. Then, using the `description` class attribute, you can add some text to the `Index`, `Show`, `Edit`, and `New` views.

<Image src="/assets/img/resources/description.png" width="1272" height="216" alt="Avo message" />

There are two ways of setting the description. The quick way as a `string` and the more customizable way as a `block`.

### Set the description as a string

```ruby{3}
class Avo::Resources::User < Avo::BaseResource
  self.title = :name
  self.description = "These are the users of the app."
end
```

This is the quick way to set the label, and it will be displayed **on all pages**. If you want to restrict the message to custom views, use a lambda function.

### Set the description as a block

This is the more customizable method where you can access the `record`, `resource`, `view`, `current_user`, and `params` objects.

```ruby{3-13}
class Avo::Resources::User < Avo::BaseResource
  self.title = :name
  self.description = -> do
    if view == :index
    "These are the users of the app"
    else
      if current_user.is_admin?
        "You can update all properties for this user: #{record.id}"
      else
        "You can update some properties for this user: #{record.id}"
      end
    end
  end
end
```
</Option>

<Option name="`self.includes`">

If you regularly need access to a resource's associations, you can tell Avo to eager load those associations on the `Index` view using `includes`.

That will help you avoid those nasty `n+1` performance issues.

```ruby
class Avo::Resources::Post < Avo::BaseResource
  self.includes = [:user, :tags]

  # or a very nested scenario
  self.includes = [files_attachments: :blob, users: [:comments, :teams, post: [comments: :user]]]
end
```

We know, the array notation looks weird, but it works.

</Option>

<Option name="`self.single_includes`">

`single_includes` works the same as `includes` but it's going to eager load the associations on the <Show /> and <Edit /> views only.
</Option>

<Option name="`self.attachments`">

Similar to how `includes` works, you can use `attachments` to eager load attachments on the `Index` view.

:::code-group
```ruby{2-4} [app/models/post.rb]
class Post < ApplicationRecord
  has_one_attached :cover_photo
  has_one_attached :audio
  has_many_attached :attachments
end
```

```ruby{5-7} [app/avo/resources/post.rb]
class Avo::Resources::Post < Avo::BaseResource
  self.attachments = [:cover_photo, :audio, :attachments]
end
```
:::

</Option>

<Option name="`self.single_attachments`">

`single_attachments` works the same as `attachments` but it's going to eager load the attachments on the <Show /> and <Edit /> views only.

</Option>

<Option name="`self.confirm_on_save`">

<VersionReq version="3.10.10" />
If you would like to ask for confirmation when saving a resource you can do so by setting `confirm_on_save` to `true`.

That will help add friction to the saving process, avoiding human error.

```ruby
class Avo::Resources::Post < Avo::BaseResource
  self.confirm_on_save = true
end
```

This option defaults to false

<Image src="/assets/img/customization/confirm-on-save.png" width="2494" height="845" alt="Confirm on save" />

</Option>

<Option name="`default_view_type`">

On <Index />, the most common view type is `:table`, but you might have some data that you want to display in a `:grid` or `:map`. You can change that by setting `default_view_type` to `:grid` and by adding the `grid` block.

<Image src="/assets/img/grid-view.jpg" width="1312" height="1096" alt="Avo grid view" />

```ruby{2}
class Avo::Resources::Post < Avo::BaseResource
  self.default_view_type = :grid
end
```

Find out more on the grid view documentation page.

<VersionReq version="3.5.6" /> `default_view_type` become callable. Within this block, you gain access to all attributes of `Avo::ExecutionContext` along with the `resource` and `view`. Example:

```ruby
class Avo::Resources::Post < Avo::BaseResource
  self.default_view_type = -> {
    mobile_user = request.user_agent =~ /Mobile/

    mobile_user ? :table : :grid
  }
end
```

</Option>

<Option name="`self.model_class`">

For some resources you might have a model that is namespaced, or you might have a secondary resource for a model. For that scenario, you can use the `self.model_class` option to tell Avo which model to reference in that resource.

```ruby{2}
class Avo::Resources::DelayedJob < Avo::BaseResource
  self.model_class = "Delayed::Job"

  def fields
    field :id, as: :id
  end
end
```

</Option>

<Option name="`self.devise_password_optional`">

If you use `devise` and update your user models (usually `User`) without passing a password, you will get a validation error. You can use `devise_password_optional` to stop receiving that error. It will [strip out](https://stackoverflow.com/questions/5113248/devise-update-user-without-password/11676957#11676957) the `password` key from `params`.

```ruby
class Avo::Resources::User < Avo::BaseResource
  self.devise_password_optional = true
end
```

### Related

- Password field

</Option>

<Option name="`self.visible_on_sidebar`">

When you get started, the sidebar will be auto-generated for you with all the dashboards, resources, and custom tools.
However, you may have resources that should not appear on the sidebar, which you can hide using the `visible_on_sidebar` option.

```ruby{2}
class Avo::Resources::TeamMembership < Avo::BaseResource
  self.visible_on_sidebar = false
end
```

:::warning
This option is used in the **auto-generated menu**, not in the menu editor.

You'll have to use your own logic in the `visible` block for that.
:::
</Option>

<Option name="`config.buttons_on_form_footers`">

If you have a lot of fields on a resource, that form might get pretty tall. So it would be useful to have the `Save` button in the footer of that form.

You can do that by setting the `buttons_on_form_footers` option to `true` in your initializer. That will add the `Back` and `Save` buttons on the footer of that form for the `New` and `Edit` screens.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.buttons_on_form_footers = true
end
```

<Image src="/assets/img/resources/buttons_on_footer.png" width="1276" height="594" alt="Buttons on footer" />

</Option>

<Option name="`after_create_path`/`after_update_path`">

For some resources, it might make sense to redirect to something other than the `Show` view. With `after_create_path` and `after_update_path` you can control that.

The valid options are `:show` (default), `:edit`, or `:index`.

```ruby{2-3}
class Avo::Resources::Comment < Avo::BaseResource
  self.after_create_path = :index
  self.after_update_path = :edit
end
```

### Related

You can go more granular and customize these paths or response more using controller methods.

 - `after_create_path`
 - `after_update_path`
 - `after_destroy_path`
</Option>

<Option name="`self.record_selector`">

You might have resources that will never be selected, and you do not need that checkbox to waste your horizontal space.

You can hide it using the `record_selector` class_attribute.

```ruby{2}
class Avo::Resources::Comment < Avo::BaseResource
  self.record_selector = false
end
```

<Image src="/assets/img/resources/record_selector.png" width="688" height="361" alt="Hide the record selector." />
</Option>

<Option name="`self.link_to_child_resource`">

Let's take an example. We have a `Person` model and `Sibling` and `Spouse` models that inherit from it using Single Table Inheritance (STI).

When you declare this option on the parent resource `Person` it has the following effect. When a user is on the <Index /> view of your the `Person` resource and clicks to visit a `Person` record they will be redirected to a `Child` or `Spouse` record instead of a `Person` record.

```ruby
class Avo::Resources::Person < Avo::BaseResource
  self.link_to_child_resource = true
end
```
</Option>

<Option name="`self.keep_filters_panel_open`">

<DemoVideo demo-video="https://youtu.be/M2RsNPPFOio?t=374" />

There are scenarios where you wouldn't want to close the filters panel when you change the values. For that, you can use the `keep_filters_panel_open` resource option.

```ruby{2}
class Avo::Resources::Course < Avo::BaseResource
  self.keep_filters_panel_open = true

  def fields
    field :id, as: :id
    field :name, as: :text
  end

  def filters
    filter Avo::Filters::CourseCountryFilter
    filter Avo::Filters::CourseCityFilter
  end
end
```

<Image src="/assets/img/filters/keep-filters-panel-open.gif" width="449" height="800" alt="Avo filters" />
</Option>

<Option name="`self.components`">

By default, for each view we render an component:

Index -> `Avo::Views::ResourceIndexComponent`<br>
Show -> `Avo::Views::ResourceShowComponent`<br>
New, Edit -> `Avo::Views::ResourceEditComponent`

It's possible to change this behavior by using the `self.components` resource option.

```ruby
self.components = {
  resource_index_component: Avo::Views::Users::ResourceIndexComponent,
  resource_show_component: "Avo::Views::Users::ResourceShowComponent",
  resource_edit_component: "Avo::Views::Users::ResourceEditComponent",
  resource_new_component: Avo::Views::Users::ResourceEditComponent
}
```

<VersionReq version="3.11.8" /> more components can be replaced. From this version, keys must be strings that match the original component with the exception of those from the snippet above.

Here is a list of all the supported customizable components:

```ruby
self.components = {
  "Avo::Views::ResourceIndexComponent": Avo::Custom::ResourceIndexComponent,
  "Avo::Views::ResourceShowComponent": "Avo::Custom::ResourceShowComponent",
  "Avo::Views::ResourceEditComponent": "Avo::Custom::ResourceEditComponent",
  "Avo::Index::GridItemComponent": "Avo::Custom::GridItemComponent",
  "Avo::Index::ResourceMapComponent": "Avo::Custom::ResourceMapComponent",
  "Avo::Index::ResourceTableComponent": "Avo::Custom::ResourceTableComponent",
  "Avo::Index::TableRowComponent": "Avo::Custom::TableRowComponent"
}
```

A resource configured with the example above will start using the declared components instead the default ones.

:::warning
The custom view components must ensure that their initializers are configured to receive all the arguments passed during the rendering of a component. You can verify this in our codebase through the following files:

Index -> `app/views/avo/base/index.html.erb`<br>
Show -> `app/views/avo/base/show.html.erb`<br>
New -> `app/views/avo/base/new.html.erb`<br>
Edit -> `app/views/avo/base/edit.html.erb`
:::
Creating a customized component for a view is most easily achieved by ejecting one of our pre-existing components using the `--scope` parameter. You can find step-by-step instructions in the documentation here.

Alternatively, there is another method which requires two additional manual steps. This involves crafting a personalized component by extracting an existing one and adjusting its namespace. Although changing the namespace is not mandatory, we strongly recommend it unless you intend for all resources to adopt the extracted component.

Example:
1. Execute the command `bin/rails generate avo:eject --component Avo::Views::ResourceIndexComponent` to eject the specified component.<br><br>
2. Access the newly ejected file and adjust the namespace. You can create a fresh directory like `my_dir` and transfer the component to that directory.<br><br>
2. You have the flexibility to establish multiple directories, just ensure that the class name corresponds to the path of the directories.<br><br>
3. Update the class namespace in the file from `Avo::Views::ResourceIndexComponent` to `Avo::MyDir::Views::ResourceIndexComponent`.<br><br>
4. You can now utilize the customized component in a resource.

```ruby
self.components = {
  resource_index_component: Avo::MyDir::Views::ResourceIndexComponent
}
```

This way you can choose the whatever namespace structure you want and you assure that the initializer is accepting the right arguments.
</Option>

<Option name="`self.index_query`">

### Unscoped queries on `Index`

You might have a `default_scope` on your model that you don't want to be applied when you render the `Index` view.
```ruby{2}
class Project < ApplicationRecord
  default_scope { order(name: :asc) }
end
```

You can unscope the query using the `index_query` method on that resource.

```ruby{3}
class Avo::Resources::Project < Avo::BaseResource
  self.title = :name
  self.index_query = -> { query.unscoped }
end
```
</Option>

<Option name="`self.default_sort_column`">

<VersionReq version="3.10.7" />

By default, Avo sorts records on the <Index /> view by the `created_at` attribute. However, you can customize this behavior using the `default_sort_column` option in your resource file.

#### Default

`:created_at`

#### Possible values

Any symbol representing a sortable column in your model. If the specified column doesn't exist in the model, Avo will fall back to the default sort column (`created_at`).

```ruby
class Avo::Resources::User < Avo::BaseResource
  self.default_sort_column = :last_name

  def fields
    field :id, as: :id
    field :last_name, as: :text
  end

  # other resource configurations...
end
```

:::info
When changing the default sort column, it's recommended to add an index to that column in your database for better query performance.

```ruby
# Example migration
class AddIndexOnUsersCreatedAt < ActiveRecord::Migration[7.1]
  def change
    add_index :users, :last_name
  end
end
```
:::

**Related:**
  - Add an index on the `created_at` column
</Option>

<Option name="`self.default_sort_direction`">

<VersionReq version="3.11.5" />

By default, Avo sorts records in descending order of the default sort column. However, you can customize this using the `self.default_sort_direction` option in your resource file.

#### Default

`:desc`

#### Possible values

Either `:desc` (descending) or `:asc` (ascending).

```ruby
class Avo::Resources::Task < Avo::BaseResource
  self.default_sort_column = :position
  self.default_sort_direction = :asc

  # ...
end
```

</Option>

<Option name="`self.controls_placement`">

<VersionReq version="3.13.7" />

:::warning
<VersionReq version="3.16.3" /> `controls_placement` option is **obsolete**.

Check row controls configuration on table view instead
:::

By default, Avo renders action controls according to the `controls_placement` configuration, which is set to `right` by default. This value can be customized for each individual resource.

#### Possible values

Either `:left`, `:right` or `:both`

```ruby{3}
# app/avo/resources/task.rb
class Avo::Resources::Task < Avo::BaseResource
  self.controls_placement = :both
end
```

</Option>

<Option name="`self.pagination`">

This feature is designed for managing pagination. For example on large tables of data sometimes count is inefficient and unnecessary.

By setting `self.pagination[:type]` to `:countless`, you can disable the pagination count on the index page.

This is especially beneficial for large datasets, where displaying the total number of items and pages may have some performance impact.

```ruby
# As block:
self.pagination = -> do
  {
    type: :default,
    size: [1, 2, 2, 1],
  }
end

# Or as hash:
self.pagination = {
  type: :default,
  size: [1, 2, 2, 1],
}
```

The exposed pagination setting above have the default value for each key.

### `type`<br><br>
  #### Possible values
  `:default`, `:countless`
  #### Default
  `:default`

### `size`<br><br>
  #### Possible values
  [Pagy docs - Control the page links](https://ddnexus.github.io/pagy/docs/how-to/#control-the-page-links)
  #### Default
  `[1, 2, 2, 1]` - before <Version version="3.11.5" />

  `9` - <VersionReq version="3.11.5" />

### Examples
#### Default
```ruby
self.pagination = -> do
  {
    type: :default,
    size: [1, 2, 2, 1],
  }
end
```

<Image src="/assets/img/resources/pagination/default.png" width="1025" height="65" alt="Default pagination" />
<br><br>

#### Countless

```ruby
self.pagination = -> do
  {
    type: :countless
  }
end
```

<Image src="/assets/img/resources/pagination/countless.png" width="1030" height="67" alt="Countless pagination" />
<br><br>

#### Countless and "pageless"
```ruby
self.pagination = -> do
  {
    type: :countless,
    size: []
  }
end
```
<Image src="/assets/img/resources/pagination/countless_empty_size.png" width="1029" height="62" alt="Countless pagination size empty" />
</Option>

<Option name="`cache_hash`">

The `cache_hash` method is used to compute the cache key for each row. The method looks something like this:

```ruby
def cache_hash(parent_record)
  result = [record, file_hash]

  if parent_record.present?
    result << parent_record
  end

  result
end

def file_hash
  content_to_be_hashed = ""

  file_name = self.class.underscore_name.tr(" ", "_")
  resource_path = Rails.root.join("app", "avo", "resources", "#{file_name}.rb").to_s
  if File.file? resource_path
    content_to_be_hashed += File.read(resource_path)
  end

  # policy file hash
  policy_path = Rails.root.join("app", "policies", "#{file_name.gsub("_resource", "")}_policy.rb").to_s
  if File.file? policy_path
    content_to_be_hashed += File.read(policy_path)
  end

  Digest::MD5.hexdigest(content_to_be_hashed)
end
```

It's an md5 of the resource file name, the policy file (so the cache gets busted when the rules change). We also add the `parent_record` when it's displayed in as an association, so there's a separate cache record for each association.

This is the default, but if you have special requirements you can add it to your resource file and it will be used to cache your records accordingly.

```ruby
class Avo::Resources::User < Avo::BaseResource
  def cache_hash(parent_record)
    result = [record, file_hash, "SOMETHING_NEW"]

    if parent_record.present?
      result << parent_record
    end

    result
  end

  # fields, cards and more
end
```
</Option>

<Option name="`self.external_link`">

<VersionReq version="3.15.6" />

<br>
<br>

<Image src="/assets/img/resources/external-link.png" width="1293" height="426" alt="External link demonstration" />

It's often desirable to provide users with a link to the public path of a record outside of the Avo interface. The `external_link` option allows you to achieve this.

### Usage

To define an external link for a resource, set the `self.external_link` option with a lambda function. Within this lambda function, you gain access to all attributes of `Avo::ExecutionContext` along with the `record`.

```ruby{2-4}
class Avo::Resources::Post < Avo::BaseResource
  self.external_link = -> { # [!code focus]
    main_app.post_path(record) # [!code focus]
  } # [!code focus]
end
```

The `self.external_link` lambda should return a string representing the URL of the record.

You can use path helpers from your application (e.g., `main_app.post_path`) or any external URL generator.

When this option is configured, Avo will display an external link button for the resource. Clicking it will take the user to the specified URL.

</Option>

<Option name="`self.discreet_information`">

<VersionReq version="3.17" />

Oftern we want to show some information about records without adding another field. `discreet_information` does exactly that ðŸ™Œ

More information on `discreet_information`

</Option>

## Cards

Use the `def cards` method to add some cards to your resource.

Check cards documentation for more details.

```ruby{9-19}
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id
    field :name, as: :text
    field :email, as: :text
    field :roles, as: :boolean_group, options: {admin: "Administrator", manager: "Manager", writer: "Writer"}
  end

  def cards
    card Avo::Cards::ExampleAreaChart, cols: 3
    card Avo::Cards::ExampleMetric, cols: 2
    card Avo::Cards::ExampleMetric,
      label: "Active users metric",
      description: "Count of the active users.",
      arguments: { active_users: true },
      visible: -> { !resource.view.form? }
  end
end
```

<Image src="/assets/img/cards_on_resource.png" width="2520" height="1258" alt="Cards on resources - Avo for Rails" />

---

# Array Resources

## Overview

An **Array Resource** is a flexible resource that can be backed by an **array of hashes** or an **array of Active Record objects**. It is not constrained to an Active Record model and allows dynamic data handling.

:::info Related field
The Array Resource can be used in conjunction with the `Array` field to manage structured array data in your resources.

For more details on using the `Array` field, including examples and hierarchy of data fetching, check out the Array Field documentation.

This integration allows for seamless configuration of dynamic or predefined array-based data within your application.
:::

:::warning âš ï¸ Limitations

#### Sorting
- The array resource does **not support sorting**.

#### Performance Considerations
- When dealing with large datasets, you might experience suboptimal performance due to inherent architectural constraints.
- **Caching Recommendation:**
  - It is advisable to implement caching mechanisms as a viable solution to ameliorate these performance bottlenecks.
  - **Note:** These caching mechanisms should ideally be integrated into the methods that fetch data, such as the `def records` method.

**Please note that these caveats are based on the current implementation and may be subject to revisions in future releases.**

:::

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/wnWvzQyyo6A?start=1030" title="Avo 3.17 - Media Library, new Markdown field &amp; the Array Adapter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## Creating an Array Resource

Generate an **Array Resource** using the `--array` flag:

```bash
bin/rails generate avo:resource Movie --array
```

This sets up a resource designed to work with an array of data.

## Defining the `records` Method

The `records` method serves as the fallback source for data in the resource. It returns an array of hashes or Active Record objects.

### Example

```ruby
def records
  [
    {
      id: 1,
      name: "The Shawshank Redemption",
      release_date: "1994-09-23"
    },
    {
      id: 2,
      name: "The Godfather",
      release_date: "1972-03-24",
      fun_fact: "The iconic cat in the opening scene was a stray found by director Francis Ford Coppola on the studio lot."
    },
    {
      id: 3,
      name: "Pulp Fiction",
      release_date: "1994-10-14"
    }
  ]
end
```

## Defining Fields

Array Resources use fields like any other Avo resource. Hereâ€™s an example for a `Movie` resource:

```ruby
class Avo::Resources::Movie < Avo::Resources::ArrayResource
  def records
    [
      {
        id: 1,
        name: "The Shawshank Redemption",
        release_date: "1994-09-23"
      },
      {
        id: 2,
        name: "The Godfather",
        release_date: "1972-03-24",
        fun_fact: "The iconic cat in the opening scene was a stray found by director Francis Ford Coppola on the studio lot."
      },
      {
        id: 3,
        name: "Pulp Fiction",
        release_date: "1994-10-14"
      }
    ]
  end

  def fields
    main_panel do
      field :id, as: :id
      field :name, as: :text
      field :release_date, as: :date
      field :fun_fact, only_on: :index, visible: -> { resource.record.fun_fact.present? } do
        record.fun_fact.truncate_words(10)
      end

      sidebar do
        field :fun_fact do
          record.fun_fact || "There is no register of a fun fact for #{record.name}"
        end
      end
    end
  end
end
```

---

# Fields

<script setup>
  import {useData} from 'vitepress'
  const {site} = useData()
  const fields = site.value.themeConfig.sidebar['/3.0/']
    .find((item) => item.text === 'Field types')
    .items
    .map((item) => ({
      text: item.text,
      link: item.link.replace('.md', '.html')
    }))
</script>

# Fields

Fields are the backbone of a `Resource`.
Through fields you tell Avo what to fetch from the database and how to display it on the <Index />, <Show />, and <Edit /> views.

Avo ships with various simple fields like `text`, `textarea`, `number`, `password`, `boolean`, `select`, and more complex ones like `markdown`, `key_value`, `trix`, `tags`, and `code`.

## Declaring fields

You add fields to a resource through the `fields` method using the `field DATABASE_COLUMN, as: FIELD_TYPE, **FIELD_OPTIONS` notation.

```ruby
def fields
  field :name, as: :text
end
```

The `name` property is the column in the database where Avo looks for information or a property on your model.

That will add a few fields in your new Avo app.

On the <Index /> and <Show /> views, we'll get a new text column of that record's database value.
Finally, on the <Edit /> and <New /> views, we will get a text input field that will display & update the `name` field on that model.

### Specific methods for each view

The `fields` method in your resource is invoked whenever non-specific view methods are present. To specify fields for each view or a group of views, you can use the following methods:

`index` view -> `index_fields`<br>
`show` view -> `show_fields`<br>
`edit` / `update` views -> `edit_fields`<br>
`new` / `create` views -> `new_fields`

You can also register fields for a specific group of views as follows:

`index` / `show` views -> `display_fields`<br>
`edit` / `update` / `new` / `create` views -> `form_fields`

When specific view fields are defined, they take precedence over view group fields. If neither specific view fields nor view group fields are defined, the fields will be retrieved from the `fields` method.

The below example use two custom helpers methods to organize the fields through `display_fields` and `form_fields`

:::code-group
```ruby [display_fields]
def display_fields
  base_fields
  tool_fields
end
```

```ruby [form_fields]
def form_fields
  base_fields
  tool_fields
  tool Avo::ResourceTools::CityEditor, only_on: :forms
end
```

```ruby [tool_fields (helper method)]
# Notice that even if those fields are hidden on the form, we still include them on `form_fields`.
# This is because we want to be able to edit them using the tool.
# When submitting the form, we need this fields declared on the resource in order to know how to process them and fill the record.
def tool_fields
  with_options hide_on: :forms do
    field :name, as: :text, help: "The name of your city", filterable: true
    field :population, as: :number, filterable: true
    field :is_capital, as: :boolean, filterable: true
    field :features, as: :key_value
    field :image_url, as: :external_image
    field :tiny_description, as: :markdown
    field :status, as: :badge, enum: ::City.statuses
  end
end
```

```ruby [base_fields (helper method)]
def base_fields
  field :id, as: :id
  field :coordinates, as: :location, stored_as: [:latitude, :longitude]
  field :city_center_area,
    as: :area,
    geometry: :polygon,
    mapkick_options: {
      style: "mapbox://styles/mapbox/satellite-v9",
      controls: true
    },
    datapoint_options: {
      label: "Paris City Center",
      tooltip: "Bonjour mes amis!",
      color: "#009099"
    }
  field :description,
    as: :trix,
    attachment_key: :description_file,
    visible: -> { resource.params[:show_native_fields].blank? }
  field :metadata,
    as: :code,
    format_using: -> {
      if view.edit?
        JSON.generate(value)
      else
        value
      end
    },
    update_using: -> do
      ActiveSupport::JSON.decode(value)
    end

  field :created_at, as: :date_time, filterable: true
end
```
:::

:::warning In some scenarios fields require presence even if not visible
In certain situations, fields must be present in your resource configuration, even if they are hidden from view. Consider the following example where `tool_fields` are included within `form_fields` despite being wrapped in a `with_options hide_on: :forms do ... end` block.

For instance, when using `tool Avo::ResourceTools::CityEditor, only_on: :forms`, it will render the `features` field, which is of type `key_value`. When the form is submitted, Avo relies on the presence of the `features` field to determine its type and properly parse the submitted value.

If you omit the declaration of `field :features, as: :key_value, hide_on: :forms`, Avo will be unable to update that specific database column.
:::

## Field conventions

When we declare a field, we pinpoint the specific database row for that field. Usually, that's a snake case value.

Each field has a label. Avo will convert the snake case name to a humanized version.
In the following example, the `is_available` field will render the label as *Is available*.

```ruby
field :is_available, as: :boolean
```

<Image src="/assets/img/fields-reference/naming-convention.jpg" width="490" height="78" alt="Field naming convention" />

:::info
If having the fields stacked one on top of another is not the right layout, try the resource-sidebar.
:::

### A more complex example

```ruby
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id
    field :first_name, as: :text
    field :last_name, as: :text
    field :email, as: :text
    field :active, as: :boolean
    field :cv, as: :file
    field :is_admin?, as: :boolean
  end
end
```

The `fields` method is already hydrated with the `current_user`, `params`, `request`, `view_context`, and `context` variables so you can use them to conditionally show/hide fields

```ruby
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id
    field :first_name, as: :text
    field :last_name, as: :text
    field :email, as: :text
    field :is_admin?, as: :boolean
    field :active, as: :boolean

    if current_user.is_admin?
      field :cv, as: :file
    end
  end
end
```

## Field Types

<ul>
  <li v-for="field in fields">
    <a :href="field.link">
      {{field.text}}
      </a>
  </li>
</ul>

---

# Field options

Avo fields are dynamic and can be configured using field options.

There are quite a few **common field options** described on this page that will work with most fields (but some might not support them), and some **custom field options** that only some fields respond to that are described on each field page.

### Common field option example

```ruby
# disabled will disable the field on the `Edit` view
field :name, as: :text, disabled: true
field :status, as: :select, disabled: true
```

### Custom field option example

```ruby
# options will set the dropdown options for a select field
field :status, as: :select, options: %w[first second third]
```

## Change field name

To customize the label, you can use the `name` property to pick a different label.

```ruby
field :is_available, as: :boolean, name: "Availability"
```

<Image src="/assets/img/fields-reference/naming-convention-override.png" width="938" height="158" alt="Field naming convention override" />

## Showing / Hiding fields on different views

There will be cases where you want to show fields on different views conditionally. For example, you may want to display a field in the <New /> and <Edit /> views and hide it on the <Index /> and <Show /> views.

For scenarios like that, you may use the visibility helpers `hide_on`, `show_on`, `only_on`, and `except_on` methods. Available options for these methods are: `:new`, `:edit`, `:index`, `:show`, `:forms` (both `:new` and `:edit`) and `:all` (only for `hide_on` and `show_on`).

Version 3 introduces the `:display` option that is the opposite of `:forms`, referring to both, `:index` and `:show`

Be aware that a few fields are designed to override those options (ex: the `id` field is hidden in <Edit /> and <New />).

```ruby
field :body, as: :text, hide_on: [:index, :show]
```

Please read the detailed views page for more info.

## Field Visibility

You might want to restrict some fields to be accessible only if a specific condition applies. For example, hide fields if the user is not an admin.

You can use the `visible` block to do that. It can be a `boolean` or a lambda.
Inside the lambda, we have access to the `context` object and the current `resource`. The `resource` has the current `record` object, too (`resource.record`).

```ruby
field :is_featured, as: :boolean, visible: -> { context[:user].is_admin? }  # show field based on the context object
field :is_featured, as: :boolean, visible: -> { resource.name.include? 'user' } # show field based on the resource name
field :is_featured, as: :boolean, visible: -> { resource.record.published_at.present? } # show field based on a record attribute
```

:::warning
On form submissions, the `visible` block is evaluated in the `create` and `update` controller actions. That's why you have to check if the `resource.record` object is present before trying to use it.
:::

```ruby
# `resource.record` is nil when submitting the form on resource creation
field :name, as: :text, visible -> { resource.record.enabled? }

# Do this instead
field :name, as: :text, visible -> { resource.record&.enabled? }
```

## Computed Fields

You might need to show a field with a value you don't have in a database row. In that case, you may compute the value using a block that receives the `record` (the actual database record), the `resource` (the configured Avo resource), and the current `view`. With that information, you can compute what to show on the field in the <Index /> and <Show /> views.

```ruby
field 'Has posts', as: :boolean do
  record.posts.present?
rescue
  false
end
```

:::info
Computed fields are displayed only on the <Show /> and <Index /> views.
:::

This example will display a boolean field with the value computed from your custom block.

## Fields Formatter

Sometimes you will want to process the database value before showing it to the user. You may do that using `format_using` block.

Notice that this block will have effect on **all** views.

You have access to a bunch of variables inside this block, all the defaults that `Avo::ExecutionContext` provides plus `value`, `record`, `resource`, `view` and `field`.

```ruby
field :is_writer, as: :text, format_using: -> {
  if view.form?
    value
  else
    value.present? ? 'ðŸ‘' : 'ðŸ‘Ž'
  end
}
```

This example snippet will make the `:is_writer` field generate `ðŸ‘` or `ðŸ‘Ž` emojis instead of `1` or `0` values on display views and the values `1` or `0` on form views.

<Image src="/assets/img/fields-reference/fields-formatter.png" width="943" height="156" alt="Fields formatter" />

Another example:

```ruby
field :company_url,
  as: :text,
  format_using: -> {
    if view == :new || view == :edit
      value
    else
      link_to(value, value, target: "_blank")
    end
  } do
  main_app.companies_url(record)
end
```

Since <Version version="3.20" /> `decorate` option has been available. It affects only display views. This is how the above examples would look when applying `decorate`

```ruby
field :is_writer, as: :text, decorate: -> { value.present? ? 'ðŸ‘' : 'ðŸ‘Ž' }

field :company_url,
  as: :text,
  decorate: -> {
    link_to(value, value, target: "_blank")
  } do
  main_app.companies_url(record)
end
```

## Formatting with Rails helpers

You can also format using Rails helpers like `number_to_currency` (note that `view_context` is used to access the helper):

```ruby
field :price, as: :number, format_using: -> { view_context.number_to_currency(value) }
```

## Parse value before update
When it's necessary to parse information before storing it in the database, the `update_using` option proves to be useful. Inside the block you can access the raw `value` from the form, and the returned value will be saved in the database.

```ruby
field :metadata,
  as: :code,
  update_using: -> do
    ActiveSupport::JSON.decode(value)
  end
```

## Sortable fields

One of the most common operations with database records is sorting the records by one of your fields. For that, Avo makes it easy using the `sortable` option.

Add it to any field to make that column sortable in the <Index /> view.

```ruby
field :name, as: :text, sortable: true
```

<Image src="/assets/img/fields-reference/sortable-fields.png" width="406" height="363" alt="Sortable fields" />

**Related:**
  - Add an index on the `created_at` column

## Custom sortable block

When using computed fields or `belongs_to` associations, you can't set `sortable: true` to that field because Avo doesn't know what to sort by. However, you can use a block to specify how the records should be sorted in those scenarios.

```ruby{4-7}
class Avo::Resources::User < Avo::BaseResource
  field :is_writer,
    as: :text,
    sortable: -> {
      # Order by something else completely, just to make a test case that clearly and reliably does what we want.
      query.order(id: direction)
    },
    hide_on: :edit do
      record.posts.to_a.size > 0 ? "yes" : "no"
    end
end
```

The block receives the `query` and the `direction` in which the sorting should be made and must return back a `query`.

In the example of a `Post` that `has_many` `Comment`s, you might want to order the posts by which one received a comment the latest.

You can do that using this query.

::: code-group

```ruby{5} [app/avo/resources/post.rb]
class Avo::Resources::Post < Avo::BaseResource
  field :last_commented_at,
    as: :date,
    sortable: -> {
      query.includes(:comments).order("comments.created_at #{direction}")
    }
end
```

```ruby{4-6} [app/models/post.rb]
class Post < ApplicationRecord
  has_many :comments

  def last_commented_at
    comments.last&.created_at
  end
end
```

:::

## Placeholder

Some fields support the `placeholder` option, which will be passed to the inputs on <Edit /> and <New /> views when they are empty.

```ruby
field :name, as: :text, placeholder: 'John Doe'
```

<Image src="/assets/img/fields-reference/placeholder.png" width="946" height="160" alt="Placeholder option" />

## Required
To indicate that a field is mandatory, you can utilize the `required` option, which adds an asterisk to the field as a visual cue.

Avo automatically examines each field to determine if the associated attribute requires a mandatory presence. If it does, Avo appends the asterisk to signify its mandatory status. It's important to note that this option is purely cosmetic and does not incorporate any validation logic into your model. You will need to manually include the validation logic yourself, such as (`validates :name, presence: true`).

```ruby
field :name, as: :text, required: true
```

<Image src="/assets/img/fields-reference/required.png" width="949" height="156" alt="Required option" />

<DemoVideo demo-video="https://youtu.be/peKt90XhdOg?t=937" />

You may use a block as well. It will be executed in the `Avo::ExecutionContext` and you will have access to the `view`, `record`, `params`, `context`, `view_context`, and `current_user`.

```ruby
field :name, as: :text, required: -> { view == :new } # make the field required only on the new view and not on edit
```

## Disabled

When you need to prevent the user from editing a field, the `disabled` option will render it as `disabled` on <New /> and <Edit /> views and the value will not be passed to that record in the database. This prevents a bad actor to go into the DOM, enable that field, update it, and then submit it, updating the record.

```ruby
field :name, as: :text, disabled: true
```

<Image src="/assets/img/fields-reference/readonly.png" width="953" height="164" alt="Disabled option" />

### Disabled as a block

<VersionReq version="2.14" class="mt-2" />

You may use a block as well. It will be executed in the `Avo::ExecutionContext` and you will have access to the `view`, `record`, `params`, `context`, `view_context`, and `current_user`.

```ruby
field :id, as: :number, disabled: -> { view == :edit } # make the field disabled only on the new edit view
```

## Readonly

When you need to prevent the user from editing a field, the `readonly` option will render it as `disabled` on <New /> and <Edit /> views. This does not, however, prevent the user from enabling the field in the DOM and send an arbitrary value to the database.

```ruby
field :name, as: :text, readonly: true
```

<Image src="/assets/img/fields-reference/readonly.png" width="953" height="164" alt="Readonly option" />

## Default Value

When you need to give a default value to one of your fields on the <New /> view, you may use the `default` block, which takes either a fixed value or a block.

```ruby
# using a value
field :name, as: :text, default: 'John'

# using a callback function
field :level, as: :select, options: { 'Beginner': :beginner, 'Advanced': :advanced }, default: -> { Time.now.hour < 12 ? 'advanced' : 'beginner' }
```

## Help text

Sometimes you will need some extra text to explain better what the field is used for. You can achieve that by using the `help` method.
The value can be either text or HTML.

```ruby
# using the text value
field :custom_css, as: :code, theme: 'dracula', language: 'css', help: "This enables you to edit the user's custom styles."

# using HTML value
field :password, as: :password, help: 'You may verify the password strength <a href="http://www.passwordmeter.com/">here</a>.'
```

<Image src="/assets/img/fields-reference/help-text.png" width="954" height="271" alt="Help text" />

## Nullable

When a user uses the **Save** button, Avo stores the value for each field in the database. However, there are cases where you may prefer to explicitly instruct Avo to store a `NULL` value in the database row when the field is empty. You do that by using the `nullable` option, which converts `nil` and empty values to `NULL`.

You may also define which values should be interpreted as `NULL` using the `null_values` method.

```ruby
# using default options
field :updated_status, as: :status, failed_when: [:closed, :rejected, :failed], loading_when: [:loading, :running, :waiting], nullable: true

# using custom null values
field :body, as: :textarea, nullable: true, null_values: ['0', '', 'null', 'nil', nil]
```

## Link to record

Sometimes, on the <Index /> view, you may want a field in the table to be a link to that resource so that you don't have to scroll to the right to click on the <Show /> icon. You can use `link_to_record` to change a table cell to be a link to that record.

```ruby
# for id field
field :id, as: :id, link_to_record: true

# for text field
field :name, as: :text, link_to_record: true

# for gravatar field
field :email, as: :gravatar, link_to_record: true
```

<Image src="/assets/img/fields-reference/as-link-to-resource.jpg" width="694" height="166" alt="As link to resource" />

You can add this property on `id`, `text`, and `gravatar` fields.

Optionally you can enable the global config `id_links_to_resource`. More on that on the id links to resource docs page.

**Related:**
 - ID links to resource
 - Resource controls on the left side

## Align text on Index view

It's customary on tables to align numbers to the right. You can do that using the `html` option.

```ruby{2}
class Avo::Resources::Project < Avo::BaseResource
  field :users_required, as: :number, html: {index: {wrapper: {classes: "text-right"}}}
end
```

<Image src="/assets/img/fields/index_text_align.jpg" width="632" height="476" alt="Index text align" />

## Stacked layout

For some fields, it might make more sense to use all of the horizontal area to display it. You can do that by changing the layout of the field wrapper using the `stacked` option.

```ruby
field :meta, as: :key_value, stacked: true
```

#### `inline` layout (default)

<Image src="/assets/img/fields/field_wrapper_layout_inline.jpg" width="808" height="117" alt="" />

#### `stacked` layout

<Image src="/assets/img/fields/field_wrapper_layout_stacked.jpg" width="815" height="179" alt="" />

## Global `stacked` layout

You may also set all the fields to follow the `stacked` layout by changing the `field_wrapper_layout` initializer option from `:inline` (default) to `:stacked`.

```ruby
Avo.configure do |config|
  config.field_wrapper_layout = :stacked
end
```

Now, all fields will have the stacked layout throughout your app.

## Field options

<Option name="`components`">

The field's `components` option allows you to customize the view components used for rendering the field in all, `index`, `show` and `edit` views. This provides you with a high degree of flexibility.

### Ejecting the field components
To start customizing the field components, you can eject one or multiple field components using the `avo:eject` command. Ejecting a field component generates the necessary files for customization. Here's how you can use the `avo:eject` command:

#### Ejecting All Components for a Field

`$ rails g avo:eject --field-components FIELD_TYPE --scope admin`

Replace `FIELD_TYPE` with the desired field type. For instance, to eject components for a Text field, use:

`$ rails g avo:eject --field-components text --scope admin`

This command will generate the files for all the index, edit and show components of the Text field, for each field type the amount of components may vary.

For more advanced usage check the eject documentation.

:::warning Scope
If you don't pass a `--scope` when ejecting a field view component, the ejected component will override the default components all over the project.

Check eject documentation for more details.
:::

### Customizing field components using `components` option

Here's some examples of how to use the `components` option in a field definition:

::: code-group
```ruby [Hash]
field :description,
  as: :text,
  components: {
    index_component: Avo::Fields::Admin::TextField::IndexComponent,
    show_component: Avo::Fields::Admin::TextField::ShowComponent,
    edit_component: "Avo::Fields::Admin::TextField::EditComponent"
  }
```

```ruby [Block]
field :description,
  as: :text,
  components: -> do
    {
      show_component: Avo::Fields::Admin::TextField::ShowComponent,
      edit_component: "Avo::Fields::Admin::TextField::EditComponent"
    }
  end
```
:::

The components block it's executed using `Avo::ExecutionContent` and gives access to a bunch of variables as: `resource`, `record`, `view`, `params` and more.

`<view>_component` is the key used to render the field's `<view>`'s component, replace `<view>` with one of the views in order to customize a component per each view.

:::warning Initializer
It's important to keep the initializer on your custom components as the original field view component initializer.
:::

</Option>

<Option name="`html`">

### Attach HTML attributes

Using the `html` option you can attach `style`, `classes`, and `data` attributes. The `style` attribute adds the `style` tag to your element, `classes` adds the `class` tag, and the `data` attribute the `data` tag to the element you choose.

You may find more detailed information about the HTML attributes here.

</Option>

<Option name="`summarizable`">

<Image src="/assets/img/summarizable.png" width="554" height="347" alt="Field summarizable preview" />

The `summarizable` option allows you to generate a visual summary of a column's data distribution. This feature provides a quick and intuitive overview of your dataset by displaying a chart within the table header.

You can enable `summarizable` for a column like this:

```ruby
def fields
  field :status, as: :select, summarizable: true
  field :status, as: :badge, summarizable: true
end
```

### How It Works

When `summarizable` is enabled, a chart icon will appear in the table header for that column.
Clicking on the icon will display a summary chart based on the data in that column.
The chart provides a visual representation of data distribution, making it easier to analyze trends.

</Option>

<Option name="`for_attribute`">

Allows to specify the target attribute on the model for each field. By default the target attribute is the field's id.

Usage example:

```ruby
field :status, as: :select, options: [:one, :two, :three], only_on: :forms

field :secondary_field_for_status,
  as: :badge,
  for_attribute: :status,
  options: {info: :one, :success: :two, warning: :three},
  except_on: :forms,
  help: "Secondary field for status using the for_attribute option"
```
</Option>

<Option name="`meta`">

This handy option enables you to send arbitrary information to the field. It's especially useful when you're building your own custom fields or you are using [custom components](#components) for the built-in fields.

Usage example:

```ruby{4,9-11}
# meta as a hash
field :status,
  as: :custom_status,
  meta: {foo: :bar}

# meta as a block
field :status,
  as: :badge,
  meta: -> do
    record.statuses.map(&:id)
  end
```

Within your field template you can now access the `@field.meta` attribute.

```erb{2}
<%= field_wrapper **field_wrapper_args do %>
  <% if @field.meta[:foo] %>
    <%= @resource.record.foo_value %>
  <% else %>
    <%= @field.value %>
  <% end %>
<% end %>
```
</Option>

<Option name="`copyable`">

<VersionReq version="3.15.6" class="mt-2" />

The `copyable` option enables users to copy the field's value to their clipboard. When set to `true`, a clipboard icon appears when hovering over the field value, allowing easy copying. This feature can be particularly useful for fields such as unique identifiers, URLs, or other text-based content that users may frequently need to copy.

```ruby
field :name, as: :text, copyable: true
```

The `copyable` option is available for text-based fields such as `:text`, `:textarea`, and others that render text values.

</Option>

---

# Field Discovery

`discover_columns` and `discover_associations` automatically detect and configure fields for your Avo resources based on your model's database structure.

```rb{6-7}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  # ...

  def fields
    discover_columns
    discover_associations
  end
end
```

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/wnWvzQyyo6A?start=1475" title="Avo 3.17 - Media Library, new Markdown field &amp; the Array Adapter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## Options

<Option name="`only`">

Specify which fields should be discovered, excluding all others.

```rb{6-7}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  # ...

  def fields
    discover_columns only: [:title, :body, :published_at]
    discover_associations only: [:author, :comments]
  end
end
```

##### Default value

`nil`

#### Possible values

Array of symbols representing column or association names

</Option>

<Option name="`except`">

Specify which fields should be excluded from discovery.

```rb{6-7}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  # ...

  def fields
    discover_columns except: [:metadata, :internal_notes]
    discover_associations except: [:audit_logs]
  end
end
```

##### Default value

`nil`

#### Possible values

Array of symbols representing column or association names

</Option>

<Option name="`column_names_mapping`">

Override how specific column names are mapped to field types globally.

```rb{5-8}
# config/initializers/avo.rb
Avo.configure do |config|
  # ...

  config.column_names_mapping = {
    published_at: { field: :date_time, timezone: 'UTC' },
    role: { field: :select, enum: -> { User.roles } }
  }
end
```

##### Default value

`{}`

#### Possible values

Hash mapping column names to field configurations

</Option>

<Option name="`column_types_mapping`">

Override how database column types are mapped to field types globally.

```rb{5-8}
# config/initializers/avo.rb
Avo.configure do |config|
  # ...

  config.column_types_mapping = {
    jsonb: { field: :code, language: 'json' },
    decimal: { field: :number, decimals: 2 }
  }
end
```

##### Default value

`{}`

#### Possible values

Hash mapping database column types to field configurations

</Option>

## Examples

### Basic Discovery

```rb{6-7}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  # ...

  def fields
    discover_columns
    discover_associations
  end
end
```

### Custom Field Options

This will add the provided options to every discovered field or association. This is particularly useful when having duplicative configurations across many fields.

```rb{6-7}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  # ...

  def fields
    discover_columns help: "Automatically discovered fields"
    discover_associations searchable: false
  end
end
```

### Combining Manual and Discovered Fields

```rb{6,8-9,11}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  # ...

  def fields
    field :custom_field, as: :text

    discover_columns except: [:custom_field]
    discover_associations

    field :another_custom_field, as: :boolean
  end
end
```

## Automatic Type Mapping

Field discovery maps database column types to Avo field types automatically.
e.g.

- `string` â†’ `:text`
- `integer` â†’ `:number`
- `float` â†’ `:number`
- `datetime` â†’ `:datetime`
- `boolean` â†’ `:boolean`
- `json/jsonb` â†’ `:code`

The full, up-to-date list can be found [here](https://github.com/avo-hq/avo/blob/main/lib/avo/mappings.rb)

## Association Discovery

The following associations are automatically configured:

- `belongs_to` â†’ `:belongs_to`
- `has_one` â†’ `:has_one`
- `has_many` â†’ `:has_many`
- `has_one_attached` â†’ `:file`
- `has_many_attached` â†’ `:files`
- `has_rich_text` â†’ `:trix`
- `acts-as-taggable-on :tags` â†’ `:tags`

The full, up-to-date list can be found [here](https://github.com/avo-hq/avo/blob/main/lib/avo/mappings.rb)

---

# Resource controllers

In order to benefit from Rails' amazing REST architecture, Avo generates a controller alongside every resource.
Generally speaking you don't need to touch those controllers. Everything just works out of the box with configurations added to the resource file.

However, sometimes you might need more granular control about what is happening in the controller actions or their callbacks. In that scenario you may take over and override that behavior.

## Request-Response lifecycle

Each interaction with the CRUD UI results in a request - response cycle. That cycle passes through the `BaseController`. Each auto-generated controller for your resource inherits from `ResourcesController`, which inherits from `BaseController`.

```ruby
class Avo::CoursesController < Avo::ResourcesController
end
```

In order to make your controllers more flexible, there are several overridable methods similar to how [devise](https://github.com/heartcombo/devise#controller-filters-and-helpers:~:text=You%20can%20also%20override%20after_sign_in_path_for%20and%20after_sign_out_path_for%20to%20customize%20your%20redirect%20hooks) overrides `after_sign_in_path_for` and `after_sign_out_path_for`.

## Create methods
For the `create` method, you can modify the `after_create_path`, the messages, and the actions both on success or failure.

<Option name="`after_create_path`">

Overriding this method, you can tell Avo what path to follow after a record was created with success.

```ruby
def after_create_path
  "/avo/resources/users"
end
```
</Option>

<Option name="`create_success_action`">

Override this method to create a custom response when a record was created with success.

```ruby
def create_success_action
  respond_to do |format|
    format.html { redirect_to after_create_path, notice: create_success_message}
  end
end
```
</Option>

<Option name="`create_fail_action`">

Override this method to create a custom response when a record failed to be created.

```ruby
def create_fail_action
  respond_to do |format|
    flash.now[:error] = create_fail_message
    format.html { render :new, status: :unprocessable_entity }
  end
end
```
</Option>

<Option name="`create_success_message`">

Override this method to change the message the user receives when a record was created with success.

```ruby
def create_success_message
  "#{@resource.name} #{t("avo.was_successfully_created")}."
end
```
</Option>

<Option name="`create_fail_message`">

Override this method to change the message the user receives when a record failed to be created.

```ruby
def create_fail_message
  t "avo.you_missed_something_check_form"
end
```
</Option>

## Update methods
For the `update` method, you can modify the `after_update_path`, the messages, and the actions both on success or failure.

<Option name="`after_update_path`">

Overriding this method, you can tell Avo what path to follow after a record was updated with success.

```ruby
def after_update_path
  "/avo/resources/users"
end
```
</Option>

<Option name="`update_success_action`">

Override this method to create a custom response when a record was updated with success.

```ruby
def update_success_action
  respond_to do |format|
    format.html { redirect_to after_update_path, notice: update_success_message }
  end
end
```
</Option>

<Option name="`update_fail_action`">

Override this method to create a custom response when a record failed to be updated.

```ruby
def update_fail_action
  respond_to do |format|
    flash.now[:error] = update_fail_message
    format.html { render :edit, status: :unprocessable_entity }
  end
end
```
</Option>

<Option name="`update_success_message`">

Override this method to change the message the user receives when a record was updated with success.

```ruby
def update_success_message
  "#{@resource.name} #{t("avo.was_successfully_updated")}."
end
```
</Option>

<Option name="`update_fail_message`">

Override this method to change the message the user receives when a record failed to be updated.

```ruby
def update_fail_message
  t "avo.you_missed_something_check_form"
end
```
</Option>

## Destroy methods
For the `destroy` method, you can modify the `after_destroy_path`, the messages, and the actions both on success or failure.

<Option name="`after_destroy_path`">

Overriding this method, you can tell Avo what path to follow after a record was destroyed with success.

```ruby
def after_update_path
  "/avo/resources/users"
end
```
</Option>

<Option name="`destroy_success_action`">

Override this method to create a custom response when a record was destroyed with success.

```ruby
def destroy_success_action
  respond_to do |format|
    format.html { redirect_to after_destroy_path, notice: destroy_success_message }
  end
end
```
</Option>

<Option name="`destroy_fail_action`">

Override this method to create a custom response when a record failed to be destroyed.

```ruby
def destroy_fail_action
  respond_to do |format|
    format.html { redirect_back fallback_location: params[:referrer] || resources_path(resource: @resource, turbo_frame: params[:turbo_frame], view_type: params[:view_type]), error: destroy_fail_message }
  end
end
```
</Option>

<Option name="`destroy_success_message`">

Override this method to change the message the user receives when a record was destroyed with success.

```ruby
def destroy_success_message
  t("avo.resource_destroyed", attachment_class: @attachment_class)
end
```
</Option>

<Option name="`destroy_fail_message`">

Override this method to change the message the user receives when a record failed to be destroyed.

```ruby
def destroy_fail_message
  @errors.present? ? @errors.join(". ") : t("avo.failed")
end
```
</Option>

---

# Record previews

:::warning
This section is a work in progress.
:::

To use record previews add the `preview` field on your resource and add `show_on: :preview` to the fields you'd like to have visible on the preview popover.

```ruby{3,7,11,14}
class Avo::Resources::Team < Avo::BaseResource
  def fields
    field :preview, as: :preview
    field :name,
     as: :text,
     sortable: true,
     show_on: :preview
    field :color,
      as: Avo::Fields::ColorPickerField,
      hide_on: :index,
      show_on: :preview
    field :description,
      as: :textarea,
      show_on: :preview
  end
end
```
<Image src="/assets/img/3_0/record-previews/preview-field.png" width="1328" height="1000" alt="" />

---

# Scopes

<Image src="/assets/img/scopes.png" width="862" height="636" alt="" />

:::warning
This section is a work in progress.
:::

Sometimes you might need to segment your data beyond just a few filters. You might have an `User` resource but you frequently need to see all the **Active users** or **Admin users**. You can use a filter for that or add a scope.

## Generating scopes

```bash
bin/rails generate avo:scope admins
```

```ruby
# app/avo/scopes/admins.rb
class Avo::Scopes::Admins < Avo::Advanced::Scopes::BaseScope
  self.name = "Admins" # Name displayed on the scopes bar
  self.description = "Admins only" # This is the tooltip value
  self.scope = :admins # valid scope on the model you're using it
  self.visible = -> { true } # control the visibility
end

# app/models/user.rb
class User < ApplicationRecord
  scope :admins, -> { where role: :admin } # This is used in the scope file above
end
```

## Registering scopes

Because scopes are re-utilizable, you must manually add that scope to a resource using the `scope` method inside the `scopes` method.

```ruby{4}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def scopes
    scope Avo::Scopes::Admins
  end
end
```

<Option name="`default`" headingSize="3">

<VersionReq version="3.11" class="mt-4" />

The `default` option lets you select a default scope that is applied when you
navigate to the resources page.

This option can be configured using a static value or a proc, which is executed using the Avo::ExecutionContext. Check the [Execution Context](#execution-context) section for more information about what's available in the execution context.

```ruby{5-6}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def scopes
    scope Avo::Scopes::OddId
    # EvenId scope is applied as default
    scope Avo::Scopes::EvenId, default: true
  end
end
```

```ruby{5-6}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def scopes
    scope Avo::Scopes::OddId
    # EvenId scope is applied as default if the current user is an admin
    scope Avo::Scopes::EvenId, default: -> { current_user.admin? }
  end
end
```
</Option>

<Option name="`remove_scope_all`" headingSize="3">

If you don't want to have the `All` default scope you can remove it by executing the `remove_scope_all` method inside `scopes` method.

```ruby{4}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def scopes
    remove_scope_all
    scope Avo::Scopes::Admins
  end
end
```
</Option>

## Options

### Execution Context

All options can be configured using static values or procs. The procs are executed using the Avo::ExecutionContext, which provides access to all default methods and attributes available in Avo's execution context. Each option has access to:

- `query`
- `resource`
- `scope`
- `scoped_query` (check below Performance Note)

:::warning Performance Note
Inside each proc, you can call `scoped_query`, but use it with caution as it executes the scope. If the scope takes a while to execute, this could impact performance.
:::

---

<Option name="`name`" headingSize="3">

This value is going to be displayed on the scopes bar as the name of the scope.

The `scoped_query` method can be used to compute and display the record count. Please see the recipe on how to enable it.

```ruby{3}
# app/avo/scopes/even_id.rb
class Avo::Scopes::EvenId < Avo::Advanced::Scopes::BaseScope
  self.name = "Even"
end
```

```ruby{4}
# app/avo/scopes/even_id.rb
class Avo::Scopes::EvenId < Avo::Advanced::Scopes::BaseScope
  # Please see the performance note above if you're using `scoped_query`
  self.name = -> { "Even (#{scoped_query.count})" }
end
```
</Option>

---

<Option name="`description`" headingSize="3">

This value is going to be displayed when the user hovers over the scope.

```ruby{3}
# app/avo/scopes/even_id.rb
class Avo::Scopes::EvenId < Avo::Advanced::Scopes::BaseScope
  self.description = "Only records that have an even ID."
end
```

```ruby{3-5}
# app/avo/scopes/even_id.rb
class Avo::Scopes::EvenId < Avo::Advanced::Scopes::BaseScope
  self.description = -> {
    "Only #{resource.name.downcase.pluralize} that have an even ID"
  }
end
```
</Option>

---

<Option name="`scope`" headingSize="3">

The scope you return here is going to be applied to the query of records on that page.

You can use a symbol which will indicate the scope on that model or a proc which will have the `query` available so you can apply any modifications you need.

```ruby{4}
# app/avo/scopes/even_id.rb
class Avo::Scopes::EvenId < Avo::Advanced::Scopes::BaseScope
  # This will use the `even_id` scope from the model
  self.scope = :even_id
end
```

```ruby{3}
# app/avo/scopes/even_id.rb
class Avo::Scopes::EvenId < Avo::Advanced::Scopes::BaseScope
  self.scope = -> { query.where("#{resource.model_key}.id % 2 = ?", "0") }
end
```
</Option>

---

<Option name="`visible`" headingSize="3">

From this block you can show, hide, and authorize the scope on the resource.

:::info Extra Access
The `visible` option has additional access to `parent_record` and `parent_resource` variables, which are useful when working with nested resources or association contexts.
:::

```ruby{4}
# app/avo/scopes/even_id.rb
class Avo::Scopes::EvenId < Avo::Advanced::Scopes::BaseScope
  # Only show this scope to admins
  self.visible = -> { current_user.admin? }
end
```

</Option>

## Full example

```ruby
# app/avo/scopes/even_id.rb
class Avo::Scopes::EvenId < Avo::Advanced::Scopes::BaseScope
  # Please see the performance note above if you're using `scoped_query`
  self.name = -> { "Even (#{scoped_query.count})" }

  # This will compute the description based on the resource name
  self.description = -> {
    "Only #{resource.name.downcase.pluralize} that have an even ID"
  }

  # This will scope the query to only even IDs
  self.scope = -> { query.where("#{resource.model_key}.id % 2 = ?", "0") }

  # Only show this scope to admins
  self.visible = -> { current_user.admin? }
end
```

---

# Records ordering

A typical scenario is when you need to set your records into a specific order. Like re-ordering `Slide`s inside a `Carousel` or `MenuItem`s inside a `Menu`.

The `ordering` class attribute is your friend for this. You can set four actions `higher`, `lower`, `to_top` or `to_bottom`, and the `display_inline` and `visible_on` options.
The actions are simple lambda functions but coupled with your logic or an ordering gem, and they can be pretty powerful.

## Configuration

I'll demonstrate the ordering feature using the `acts_as_list` gem.

Install and configure the gem as instructed in the [tutorials](https://github.com/brendon/acts_as_list#example). Please ensure you [give all records position attribute values](https://github.com/brendon/acts_as_list#adding-acts_as_list-to-an-existing-model), so the gem works fine.

Next, add the order actions like below.

```ruby
class Avo::Resources::CourseLink < Avo::BaseResource
  self.ordering = {
    visible_on: :index,
    actions: {
      higher: -> { record.move_higher },
      lower: -> { record.move_lower },
      to_top: -> { record.move_to_top },
      to_bottom: -> { record.move_to_bottom },
    }
  }
end
```

The `record` is the actual instantiated model. The `move_higher`, `move_lower`, `move_to_top`, and `move_to_bottom` methods are provided by `acts_as_list`. If you're not using that gem, you can add your logic inside to change the position of the record.

The actions have access to `record`, `resource`, `options` (the `ordering` class attribute) and `params` (the `request` params).

That configuration will generate a button with a popover containing the ordering buttons.

<Image src="/assets/img/resources/ordering_hover.jpg" width="1058" height="550" alt="Avo ordering" />

## Always show the order buttons

If the resource you're trying to update requires re-ordering often, you can have the buttons visible at all times using the `display_inline: true` option.

```ruby
class Avo::Resources::CourseLink < Avo::BaseResource
  self.ordering = {
    display_inline: true,
    visible_on: :index,
    actions: {
      higher: -> { record.move_higher },
      lower: -> { record.move_lower },
      to_top: -> { record.move_to_top },
      to_bottom: -> { record.move_to_bottom },
    }
  }
end
```

<Image src="/assets/img/resources/ordering_visible.jpg" width="1055" height="546" alt="Avo ordering" />

## Display the buttons in the `Index` view or association view

A typical scenario is to have the order buttons on the <Index /> view or a resource. That's the default value for the `visible_on` option.

```ruby{3}
class Avo::Resources::CourseLink < Avo::BaseResource
  self.ordering = {
    visible_on: :index,
  }
end
```

## Display the button on a `has_many` association

Another scenario is to order the records only in the scope of a parent record, like order the `MenuItems` for a `Menu`, or `Slides` for a `Slider`. So you wouldn't need to have the order buttons on the <Index /> view but only in the association section (in a has many association).

To control that, you can use the `visible_on` option and set it to `:association`.

```ruby{3}
class Avo::Resources::CourseLink < Avo::BaseResource
  self.ordering = {
    visible_on: :association,
  }
end
```

### Possible values

The possible values for the `visible_on` option are `:index`, `:association` or `[:index, :association]` for both views.

## Change the scope on the `Index` view

Naturally, you'll want to apply the `order(position: :asc)` condition to your query. You may do that in two ways.

1. Add a `default_scope` to your model. If you're using this ordering scheme only in Avo, then, this is not the recommended way, because it will add that scope to all queries for that model and you probably don't want that.

2. Use the [`index_query`](https://docs.avohq.io/3.0/customization.html#custom-query-scopes) to alter the query in Avo.

```ruby{2-4}
class Avo::Resources::CourseLink < Avo::BaseResource
  self.index_query = -> {
    query.order(position: :asc)
  }

  self.ordering = {
    display_inline: true,
    visible_on: :index, # :index or :association
    actions: {
      higher: -> { record.move_higher }, # has access to record, resource, options, params
      lower: -> { record.move_lower },
      to_top: -> { record.move_to_top },
      to_bottom: -> { record.move_to_bottom }
    }
  }
end
```

## Reorder using drag and drop

<BetaStatus label="Beta"></BetaStatus>

Sometimes just picking up a record and dropping it in the position that you'd like it to be. That's exactly what this feature does.

It's disabled by default but you can enable it by adding `drag_and_drop: true` and `insert_at` options to the `self.ordering` hash.

```ruby{5,11}
self.ordering = {
  display_inline: true,
  visible_on: %i[index association], # :index or :association or both
  # position: -> { record.position },
  drag_and_drop: true,
  actions: {
    higher: -> { record.move_higher }, # has access to record, resource, options, params
    lower: -> { record.move_lower },
    to_top: -> { record.move_to_top },
    to_bottom: -> { record.move_to_bottom },
    insert_at: -> { record.insert_at position }
  }
}
```

### Custom `position` attribute

Using the `position` option you can specify the record's `position` attribute. The default is `record.position`.

```ruby{4}
self.ordering = {
  display_inline: true,
  visible_on: %i[index association], # :index or :association or both
  position: -> { record.position_in_list },
  drag_and_drop: true,
  actions: {
    higher: -> { record.move_higher }, # has access to record, resource, options, params
    lower: -> { record.move_lower },
    to_top: -> { record.move_to_top },
    to_bottom: -> { record.move_to_bottom },
    insert_at: -> { record.insert_at position }
  }
}
```

## Authorization

If you're using the authorization feature please ensure you give the proper permissions using the `reorder?` method.

```ruby
class CourseLinkPolicy < ApplicationPolicy
  def reorder? = edit?

  # or a custom permission

  def reorder?
    user.can_reorder_items?
  end

  # other policy methods
end
```

---

# Discreet Information

Sometimes you need to have some information available on the record page, but not necesarily front-and-center.
This is where the Discreet Information option is handy.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = [
    :timestamps,
    {
      tooltip: -> { sanitize("Product is <strong>#{record.published_at ? "published" : "draft"}</strong>", tags: %w[strong]) },
      icon: -> { "heroicons/outline/#{record.published_at ? "eye" : "eye-slash"}" }
    },
    {
      label: -> { record.published_at ? "ðŸš€" : "ðŸ˜¬" },
      url: -> { "https://avohq.io" },
      url_target: :_blank
    }
  ]
end
```

## Display the `id`

To save field space, you can use the discreet information area to display the id of the current record.

Set the option to the `:id` value and the id will be added next to the title.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = :id

  # fields and other resource configuration
end
```

You can alternatively use `:id_badge` to display the id as a badge.

## Display the `created_at` and `updated_at` timestamps

The reason why we built this feature was that we wanted a place to display the created and updated at timestamps but didn't want to use up a whole field for it.
That's why this is the most simple thing to add.

Set the option to the `:timestamps` value and a new icon will be added next to the title. When the user hovers over the icon, they will see the record's default timestamps.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = :timestamps

  # fields and other resource configuration
end
```

If the record doesn't have the `created_at` or `updated_at` attributes, they will be ommited.

You can alternatively use `:timestamps_badge` to display the timestamps as a badge.

## Options

You may fully customize the discreet information item by taking control of different options.
To do that, you can set it to a `Hash` with various keys.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = {
    tooltip: -> { "Product is #{record.published_at ? "published" : "draft"}" },
    icon: -> { "heroicons/outline/#{record.published_at ? "eye" : "eye-slash"}" }
    url: -> { main_app.post_path record }
  }
end
```

<Option name="`tooltip`">

Use the `tooltip` option to set the body of the tooltip.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = {
    tooltip: -> { "Product is #{record.published_at ? "published" : "draft"}" },
  }
end
```

You may return HTML for that tooltip but don't forget to sanitize the output.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = {
    tooltip: -> { sanitize("Product is <strong>#{record.published_at ? "published" : "draft"}</strong>", tags: %w[strong]) },
    icon: "heroicons/outline/academic-cap"
  }
end
```

</Option>

<Option name="`url`">

The `url` option will transform the icon into a link.

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = {
    tooltip: -> { "Product is #{record.published_at ? "published" : "draft"}" },
    icon: "heroicons/outline/academic-cap",
    url: -> { main_app. }
  }
end
```

</Option>

<Option name="`as`">

The `as` option specifies the type of representation. Currently, only `:badge` is supported, but additional types may be introduced in the future.

```ruby{7}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = {
    tooltip: -> { "Product is #{record.published_at ? "published" : "draft"}" },
    icon: "heroicons/outline/academic-cap",
    url: -> { main_app. },
    as: :badge
  }
end
```

</Option>

## Display multiple pieces of information

You can use it to display one or more pieces of information.

## Information properties

Each piece of information has a fe

## Full configuration

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.discreet_information = [
    :timestamps,
    {
      tooltip: -> { sanitize("Product is <strong>#{record.published_at ? "published" : "draft"}</strong>", tags: %w[strong]) },
      icon: -> { "heroicons/outline/#{record.published_at ? "eye" : "eye-slash"}" }
    },
    {
      label: -> { record.published_at ? "âœ…" : "ðŸ™„" },
      url: -> { "https://avohq.io" },
      url_target: :_blank
    }
  ]

  # fields and other resource configuration
end
```

---

# Customizable controls

<Image src="/assets/img/resources/customizable-controls/index.jpg" width="1020" height="469" alt="" />

One of the things that we wanted to support from day one is customizable controls on resource pages, and now, Avo supports customizable controls on <Index />, <Show />, and <Edit /> views and for the table row.

## Default controls

By default, Avo displays a few buttons (controls) for the user to use on the <Index />, <Show />, and <Edit /> views which you can override using the appropriate resource options.

<Image src="/assets/img/3_0/customizable-controls/default-controls.png" width="654" height="164" alt="" />

## Customize the controls

You can take over and customize them all using the `index_controls`, `show_controls`, `edit_controls`, and `row_controls` class attributes.

<Option name="Show page">

On the <Show /> view the default configuration is `back_button`, `delete_button`, `detach_button`, `actions_list`, and `edit_button`.

To start customizing the controls, add a `show_controls` block and start adding the desired controls.

```ruby
class Avo::Resources::Fish < Avo::BaseResource
  self.show_controls = -> do
    back_button label: "", title: "Go back now"
    link_to "Fish.com", "https://fish.com", icon: "heroicons/outline/academic-cap", target: :_blank
    link_to "Turbo demo", "/admin/resources/fish/#{params[:id]}?change_to=ðŸš€ðŸš€ðŸš€ New content here ðŸš€ðŸš€ðŸš€",
      class: ".custom-class",
      data: {
        turbo_frame: "fish_custom_action_demo"
      }
    delete_button label: "", title: "something"
    detach_button label: "", title: "something"
    actions_list label: "Runnables", exclude: [ReleaseFish], style: :primary, color: :slate
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, icon: "heroicons/outline/globe"
    edit_button label: ""
  end
end
```

<Image src="/assets/img/3_0/customizable-controls/show-controls.png" width="1344" height="164" alt="" />
</Option>

<Option name="Edit page">

On the <Edit /> view the default configuration is `back_button`, `delete_button`, `actions_list`, and `save_button`.

To start customizing the controls, add a `edit_controls` block and start adding the desired controls.

```ruby
class Avo::Resources::Fish < Avo::BaseResource
  self.edit_controls = -> do
    back_button label: "", title: "Go back now"
    link_to "Fish.com", "https://fish.com", icon: "heroicons/outline/academic-cap", target: :_blank
    delete_button label: "", title: "something"
    detach_button label: "", title: "something"
    actions_list exclude: [Avo::Actions::ReleaseFish], style: :primary, color: :slate, label: "Runnables"
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, icon: "heroicons/outline/globe" if view != :new
    save_button label: "Save Fish"
  end
end
```

<Image src="/assets/img/3_0/customizable-controls/show-controls.png" width="1344" height="164" alt="" />
</Option>

<Option name="Index page">

On the <Index /> view the default configuration contains the `actions_list`, `attach_button`, and `create_button`.

To start customizing the controls, add a `index_controls` block and start adding the desired controls.

```ruby
class Avo::Resources::Fish < Avo::BaseResource
  self.index_controls = -> do
    link_to "Fish.com", "https://fish.com", icon: "heroicons/outline/academic-cap", target: :_blank
    actions_list exclude: [Avo::Actions::DummyAction], style: :primary, color: :slate, label: "Runnables" if Fish.count > 0
    action Avo::Actions::DummyAction, style: :primary, color: :fuchsia, icon: "heroicons/outline/globe" if Fish.count > 0
    attach_button label: "Attach one Fish"
    create_button label: "Create a new and fresh Fish"
  end
end
```

<Image src="/assets/img/3_0/customizable-controls/index-controls.png" width="1300" height="164" alt="" />
</Option>

<Option name="Row controls">

On the <Index /> view the on the end of each table row the default configuration contains the `order_controls` `show_button`, `edit_button`, `detach_button`, and `delete_button`.

To start customizing the controls, add a `row_controls` block and start adding the desired controls.

The controls you customize here will be displayed on the grid view too.

```ruby
class Avo::Resources::Fish < Avo::BaseResource
  self.row_controls = -> do
    action Avo::Actions::ReleaseFish, label: "Release #{record.name}", style: :primary, color: :blue,
      icon: "heroicons/outline/hand-raised" unless params[:view_type] == "grid"
    edit_button title: "Edit this Fish now!"
    show_button title: "Show this Fish now!"
    delete_button title: "Delete this Fish now!", confirmation_message: "Are you sure you want to delete this Fish?"
    actions_list style: :primary, color: :slate, label: "Actions" unless params[:view_type] == "grid"
    action Avo::Actions::ReleaseFish, title: "Release #{record.name}", icon: "heroicons/outline/hand-raised", style: :icon
    link_to "Information about #{record.name}", "https://en.wikipedia.org/wiki/#{record.name}",
      icon: "heroicons/outline/information-circle", target: :_blank, style: :icon
  end
end
```

<Image src="/assets/img/3_0/customizable-controls/row-controls.png" width="834" height="120" alt="" />
</Option>

## Controls

A control is an item that you can place in a designated area. They can be one of the default ones like `back_button`, `delete_button`, or `edit_button` to custom ones like `link_to` or `action`.

You may use the following controls:

<Option name="`back_button`">

Links to a previous page. The link is not a `history.back()` action. It's computed based on the parameters sent by Avo. That ensures the user has consistent hierarchical progress through the app.

#### Supported options

`label`, `title`, `style`, `color`, and `icon`.
</Option>

<Option name="`delete_button`">

Adds the appropriate destroy form. It will take into account your authorization policy rules.

#### Supported options

`label`, `title`, `style`, `color`, and `icon`.
</Option>

<Option name="`detach_button`">

Adds the appropriate detach form. It's visible only on the association (`has_one`) page. It will take into account your authorization policy rules.

#### Supported options

`label`, `title`, `style`, `color`, and `icon`.
</Option>

<Option name="`actions_list`">

A dropdown where the user can see and run all the actions assigned to that resource.

:::info
The actions' icon and the dividers are defined in the `def actions` method.
:::

#### Supported options

`label`, `title`, `style`, `color`, `icon`, `include` and `exclude`.

#### `exclude` option

Filters out the specified actions.

It's used in conjunction with the `action` control. For example, when you extract an action, you don't want it to be displayed in the `actions_list` anymore, so you use the `exclude` option to filter it out.

#### Example

```ruby
actions_list exclude: Avo::Actions::DisableAccount
# Or
actions_list exclude: [Avo::Actions::ExportSelection, Avo::Actions::PublishPost]
```

#### `include` option

This option is used to specify the actions that should be included in the `actions_list`. When this option is configured, only the actions specified in the `include` option will be displayed in the `actions_list` dropdown.

#### Example

```ruby
actions_list include: Avo::Actions::DisableAccount
# Or
actions_list include: [Avo::Actions::ExportSelection, Avo::Actions::PublishPost]
```
</Option>

<Option name="`list`">

<VersionReq version="3.13" />

A dropdown that displays all the specified actions and links.

#### Supported options

`label`, `title`, `style`, `color` and `icon`

#### Example

```ruby
list label: "Custom Index List", icon: "heroicons/outline/cube-transparent", style: :primary, color: :slate, title: "A custom list" do
  link_to "Google", "https://google.com", icon: "heroicons/outline/academic-cap"
  action Avo::Actions::Sub::DummyAction, icon: "heroicons/outline/globe"
  link_to "Fish.com", "https://fish.com", icon: "heroicons/outline/fire", target: :_blank
end
```

<Image src="/assets/img/resources/customizable-controls/custom_list.png" width="404" height="256" alt="Custom list opened" />

Within the `list` block, the only permitted elements are `link_to` and `action`. For both `link_to` and `action`, you can include an optional `icon` parameter.

:::info
<VersionReq version="3.14.1" /> `divider` is also permitted within the `list` block.
:::

In addition to the `icon`, the `link_to` element can accept additional parameters such as `target: :_blank` or `rel: "noopener"`, or any other extra arguments you may want to provide for the link. These extra arguments help define specific behaviors for the link, like opening it in a new tab or ensuring security best practices are followed.

</Option>

<Option name="`edit_button`">

Links to the record edit page.

#### Supported options

`label`, `title`, `style`, `color`, and `icon`.
</Option>

<Option name="`link_to`">

Renders a link to a path set by you.

#### Supported options

`title`, `style`, `color`, `icon`, `target`, `data`, and `class`.
</Option>

<Option name="`action`">

Renders a button that triggers an action. You must provide it an Action class.

#### Supported options

`title`, `style`, `color`, `arguments` and `icon`.

#### Example

```ruby
action Avo::Actions::DisableAccount
action Avo::Actions::DisableAccount, arguments: { hide_some_fields: true }
action Avo::Actions::ExportSelection, style: :text
action Avo::Actions::PublishPost, color: :fuchsia, icon: "heroicons/outline/eye"
```

</Option>

:::warning WARNING (**NOT** applicable for versions greater than <Version version="3.10.7" />)

When you use the `action` helper in any customizable block it will act only as a shortcut to display the action button, it will not also register it to the resource.

You must manually register it with the `action` declaration.

```ruby{6-8,13-15}
class Avo::Resources::Fish < Avo::BaseResource
  self.title = :name

  self.show_controls = -> do
    # In order to use it here
    action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, arguments: {
      action_on_show_controls: "Will use this arguments"
    }
  end

  # ðŸ‘‡ Also declare it here ðŸ‘‡
  def actions
    action Avo::Actions::ReleaseFish, arguments: {
      action_from_list: "Will use this arguments"
    }
  end
end
```
:::

<Option name="`default_controls`">

There are times when you just want to add a link before or after the default controls and don't want to re-add them all.
Avo's got you covered! `default_controls` to the rescue.

```ruby
self.show_controls = -> do
  # This link will be added before all other controls.
  link_to "View on site", post_path(record), target: :_blank
  default_controls
end
```

<Image src="/assets/img/3_0/customizable-controls/default_controls.png" alt="Default controls" width="884" height="140" />
</Option>

## Control Options

Some controls take options. Not all controls take all options.
Example: The `link_to` control is the only one that will take the `target` option, but most other controls use the `class` option.

<Option name="`title`">

Sets the tooltip for that control.

#### Possible values

Any string value.
</Option>

<Option name="`style`">

Sets the `style` attribute for the [`Avo::ButtonComponent`](https://github.com/avo-hq/avo/blob/main/app/components/avo/button_component.rb).

#### Possible values

`:primary`, `:outline`, `:text`
</Option>

<Option name="`color`">

Sets the `color` attribute for the [`Avo::ButtonComponent`](https://github.com/avo-hq/avo/blob/main/app/components/avo/button_component.rb)

#### Possible values

Can be any color of [Tailwind`s default color pallete](https://tailwindcss.com/docs/customizing-colors#default-color-palette) as a symbol.
</Option>

<Option name="`icon`">

Sets the icon for that button.

#### Possible values

Any [Heroicon](https://heroicons.com) you want. You must specify the style of the heroicon like so `heoricons/outline/academic-cap` or `heroicons/solid/adjustments`.
</Option>

<Option name="`target`">

Sets the target for that control. So whatever you pass here will be passed to the control.

#### Possible values

`:_blank`, `:_top`, `:_self`
</Option>

<Option name="`class`">

Sets the classes for that control.

#### Possible values

Any string value.
</Option>

## Default values

If you're curious what are the default controls Avo adds for each block, here they are:

```ruby
# show controls
back_button
delete_button
detach_button
actions_list
edit_button

# form (edit & new) controls
back_button
delete_button
actions_list
save_button

# index controls
attach_button
actions_list
create_button

# row controls
order_controls
show_button
edit_button
detach_button
delete_button
```

## Conditionally hiding/showing actions

Actions have the `visible` block where you can control the visibility of an action. In the context of `show_controls` that block is not taken into account, but you can use regular `if`/`else` statements because the action declaration is wrapped in a block.

```ruby{6-8}
class Avo::Resources::Fish < Avo::BaseResource
  self.show_controls = -> do
    back_button label: "", title: "Go back now"

    # visibility conditional
    if record.something?
      action Avo::Actions::ReleaseFish, style: :primary, color: :fuchsia, icon: "heroicons/outline/globe"
    end

    edit_button label: ""
  end
end
```

---

# Cover and Profile photos

<Image src="/assets/img/3_0/cover-and-profile-photo/cover-and-profile-photo.png" alt="Cover and Profile Photos" width="2560â€Š" height="â€Š1876" class="mt-8" />

It's common to want to display the information in different ways than just "key" and "value". That's why Avo has rich fields like `key_value`, `trix`, `tip_tap`, `files`, and more.

Avo now also has the Cover and Profile photo areas where you can customize the experience even more.
The APIs used are pretty similar and easy to use.

## Profile photo

The `profile_photo` option takes two arguments: `visible_on` and `source`.

```ruby
self.profile_photo = {
  source: -> {
    if view.index?
      # We're on the index page and don't have a record to reference
      DEFAULT_IMAGE
    else
      # We have a record so we can reference it's profile_photo
      record.profile_photo
    end
  }
}
```

<Option name="`visible_on`">

This controls where the cover photo should be displayed.

It defaults to the <Show />, <Edit />, and <New /> views, but you can change that to be displayed to the <Index /> view or a combination of views.

##### Optional

`true`

##### Default value

`[:show, :forms]`

#### Possible values

You may choose one view or a combination of them using an array.

`:show`, `:edit`, `:new`, `:index`, `:forms`, `:display`, `[:show, :edit]`;
</Option>

<Option name="`source`">

This controls what should be displayed as the image.

You can call a field on the record using a `Symbol`, or you can open a block where you have access to the `record` and add your own value.

##### Default value

`nil`

#### Possible values

You can call a field on the `record` using a symbol.

```ruby
self.profile_photo = {
  source: :profile_photo # this will run `record.profile_photo`
}
```

Use a block to compute your own value.

```ruby
self.profile_photo = {
  source: -> {
    if view.index?
      # We're on the index page and don't have a record to reference
      DEFAULT_IMAGE
    else
      # We have a record so we can reference it's profile_photo
      record.profile_photo
    end
  }
}
```
</Option>

## Cover photo

The `cover_photo` option takes three arguments: `size`, `visible_on`, and `source`.

```ruby
self.cover_photo = {
  size: :md, # :sm, :md, :lg
  visible_on: [:show, :forms], # can be :show, :index, :edit, or a combination [:show, :index]
  source: -> {
    if view.index?
      # We're on the index page and don't have a record to reference
      DEFAULT_IMAGE
    else
      # We have a record so we can reference it's cover_photo
      record.cover_photo
    end
  }
}
```

<Option name="`size`">

This represents the height of the cover photo. It can be small, medium or large.

##### Optional

`true`

##### Default value

`:md`

#### Possible values

`:sm`, `:md`, or `:lg`
</Option>

<Option name="`visible_on`">

This controls where the cover photo should be displayed.

It defaults to the <Show />, <Edit />, and <New /> views, but you can change that to be displayed to the <Index /> view or a combination of views.

##### Optional

`true`

##### Default value

`[:show, :forms]`

#### Possible values

You may choose one view or a combination of them using an array.

`:show`, `:edit`, `:new`, `:index`, `:forms`, `:display`, `[:show, :edit]`;
</Option>

<Option name="`source`">

This controls what should be displayed as the image.

You can call a field on the record using a `Symbol`, or you can open a block where you have access to the `record` and add your own value.

##### Default value

`nil`

#### Possible values

You can call a field on the `record` using a symbol.

```ruby
self.cover_photo = {
  source: :cover_photo # this will run `record.cover_photo`
}
```

Use a block to compute your own value.

```ruby
self.cover_photo = {
  source: -> {
    if view.index?
      # We're on the index page and don't have a record to reference
      DEFAULT_IMAGE
    else
      # We have a record so we can reference it's cover_photo
      record.cover_photo
    end
  }
}
```
</Option>

---

# Associations

One of the most amazing things about Ruby on Rails is how easy it is to create [Active Record associations](https://guides.rubyonrails.org/association_basics.html) between models. We try to keep the same simple approach in Avo too.

:::warning
It's important to set the `inverse_of` as often as possible to your model's association attribute.
:::

 - Belongs to
 - Has one
 - Has many
 - Has many through
 - Has and belongs to many

## Single Table Inheritance (STI)

When you have models that share behavior and fields with STI, Rails will cast the model as the final class no matter how you query it.

```ruby
# app/models/user.rb
class User < ApplicationRecord
end

# app/models/super_user.rb
class SuperUser < User
end

# User.all.map(&:class) => [User, SuperUser]
```

For example, when you have two models, `User` and `SuperUser` with STI, when you call `User.all`, Rails will return an instance of `User` and an instance of `SuperUser`. That confuses Avo in producing the proper resource of `User`. That's why when you deal with STI, the final resource `Avo::Resources::SuperUser` should receive the underlying `model_class` so Avo knows which model it represents.

```ruby{5}
# app/avo/resources/super_user.rb
class Avo::Resources::SuperUser < Avo::BaseResource
  self.title = :name
  self.includes = []
  self.model_class = "SuperUser"

  def fields
    field :id, as: :id
    field :name, as: :text
  end
end
```

## Link to child resource when using STI

Let's take another example. We have a `Person` model and `Sibling` and `Spouse` models that inherit from it.

You may want to use the `Avo::Resources::Person` to list all the records, but when your user clicks on a person, you want to use the inherited resources (`Avo::Resources::Sibiling` and `Avo::Resources::Spouse`) to display the details. The reason is that you may want to display different fields or resource tools for each resource type.

There are two ways you can use this:

1. `self.link_to_child_resource = true` Declare this option on the parent resource. When a user is on the <Index /> view of your the `Avo::Resources::Person` and clicks on the view button of a `Person` they will be redirected to a `Child` or `Spouse` resource instead of a `Person` resource.
2. `field :peoples, as: :has_many, link_to_child_resource: false` Use it on a `has_many` field. On the `Avo::Resources::Person` you may want to show all the related people on the <Show /> page, but when someone click on a record, they are redirected to the inherited `Child` or `Spouse` resource.

## Add custom labels to the associations' pages

You might want to change the name that appears on the association page. For example, if you're displaying a `team_members` association, your users will default see `Team members` as the title, but you'd like to show them `Members`.

You can customize that using fields localization.

<Image src="/assets/img/associations/custom-label.jpg" width="1224" height="692" alt="Custom label" />

---

# Belongs to

```ruby
field :user, as: :belongs_to
```

You will see three field types when you add a `BelongsTo` association to a model.

## Options

<Option name="`allow_via_detaching`">

Keeps the field enabled when visiting from the parent record.

</Option>

<Option name="`polymorphic_as`">

Sets the field as polymorphic with the key set on the model.

#### Default

`nil`

#### Possible values

A symbol, used on the `belongs_to` association with `polymorphic: true`.

:::warning
You must use this option with the `types` option.
:::

#### Example

```ruby
field :commentable, as: :belongs_to, polymorphic_as: :commentable, types: [::Post, ::Project]
```
</Option>

<Option name="`types`">

Sets the types the field can morph to.

#### Default

`[]`

#### Possible values

`[Post, Project, Team]`. Any array of model names.

:::warning
You must use this option with the `polymorphic_as` option.
:::

#### Example

```ruby
field :commentable, as: :belongs_to, polymorphic_as: :commentable, types: [::Post, ::Project]
```
</Option>

<Option name="`polymorphic_help`">

Sets the help text for the polymorphic type dropdown. Useful when you need to specify to the user why and what they need to choose as polymorphic.

#### Default

`nil`

#### Possible values

Any string.
</Option>

<Option name="`can_create`">

Controls the creation link visibility on forms.

#### Default

`true`

#### Possible values

`true`, `false`
:::warning Since version <Version version="3.10.2" />, the target resource policy takes precedence over this option.
`field :user, as: :belongs_to, can_create: true`

In this example, even if the `can_create` option is set to `true`, if the `UserPolicy` responds with `false` to the `create?` method, the creation link will **NOT** be visible.
:::
</Option>

## Overview

On the `Index` and `Show` views, Avo will generate a link to the associated record containing the `self.title` value of the target resource.

<Image src="/assets/img/associations/belongs-to-index.jpg" width="188" height="115" alt="Belongs to index" />

<Image src="/assets/img/associations/belongs-to-show.jpg" width="531" height="81" alt="Belongs to show" />

On the `Edit` and `New` views, Avo will generate a dropdown element with the available records where the user can change the associated model.

<Image src="/assets/img/associations/belongs-to-edit.jpg" width="555" height="123" alt="Belongs to edit" />

## Polymorphic `belongs_to`

To use a polymorphic relation, you must add the `polymorphic_as` and `types` properties.

```ruby{13}
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :id

  def fields
    field :id, as: :id
    field :body, as: :textarea
    field :excerpt, as: :text, show_on: :index do
      ActionView::Base.full_sanitizer.sanitize(record.body).truncate 60
    rescue
      ""
    end

    field :commentable, as: :belongs_to, polymorphic_as: :commentable, types: [::Post, ::Project]
  end
end
```

## Polymorphic help

When displaying a polymorphic association, you will see two dropdowns. One selects the polymorphic type (`Post` or `Project`), and one for choosing the actual record. You may want to give the user explicit information about those dropdowns using the `polymorphic_help` option for the first dropdown and `help` for the second.

```ruby{17-18}
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :id

  def fields
    field :id, as: :id
    field :body, as: :textarea
    field :excerpt, as: :text, show_on: :index do
      ActionView::Base.full_sanitizer.sanitize(record.body).truncate 60
    rescue
      ""
    end

    field :reviewable,
      as: :belongs_to,
      polymorphic_as: :reviewable,
      types: [::Post, ::Project, ::Team],
      polymorphic_help: "Choose the type of record to review",
      help: "Choose the record you need."
  end
end
```

<Image src="/assets/img/associations/polymorphic_help.jpg" width="1616" height="370" alt="Belongs to ploymorphic help" />

## Searchable `belongs_to`

<DemoVideo demo-video="https://youtu.be/KLI_sVTPX-Q" />

There might be the case that you have a lot of records for the parent resource, and a simple dropdown won't cut it. This is where you can use the `searchable` option to get a better search experience for that resource.

```ruby{8}
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :id

  def fields
    field :id, as: :id
    field :body, as: :textarea

    field :user, as: :belongs_to, searchable: true
  end
end
```

<Image src="/assets/img/associations/searchable-closed.jpg" width="1232" height="184" alt="Belongs to searchable" />
<Image src="/assets/img/associations/searchable-open.jpg" width="1556" height="1272" alt="Belongs to searchable" />

`searchable` works with `polymorphic` `belongs_to` associations too.

```ruby{8}
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :id

  def fields
    field :id, as: :id
    field :body, as: :textarea

    field :commentable, as: :belongs_to, polymorphic_as: :commentable, types: [::Post, ::Project], searchable: true
  end
end
```

:::info
Avo uses the search feature behind the scenes, so **make sure the target resource has the `query` option configured inside the `search` block**.
:::

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> {
      query.ransack(id_eq: params[:q], name_cont: params[:q], body_cont: params[:q], m: "or").result(distinct: false)
    }
  }
end

# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  self.search = {
    query: -> {
      query.ransack(id_eq: params[:q], name_cont: params[:q], country_cont: params[:q], m: "or").result(distinct: false)
    }
  }
end
```

## Belongs to attach scope

<DemoVideo demo-video="https://youtu.be/Eex8CiinQZ8?t=6" />

When you edit a record that has a `belongs_to` association, on the edit screen, you will have a list of records from which you can choose a record to associate with.

For example, a `Post` belongs to a `User`. So on the post edit screen, you will have a dropdown (or a search field if it's [searchable](#searchable-belongs-to)) with all the available users. But that's not ideal. For example, maybe you don't want to show all the users in your app but only those who are not admins.

You can use the `attach_scope` option to keep only the users you need in the `belongs_to` dropdown field.

You have access to the `query` that you can alter and return it and the `parent` object, which is the actual record where you want to assign the association (the true `Post` in the below example).

```ruby
# app/models/user.rb
class User < ApplicationRecord
  scope :non_admins, -> { where "(roles->>'admin')::boolean != true" }
end

# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  def fields
    field :user, as: :belongs_to, attach_scope: -> { query.non_admins }
  end
end
```

For scenarios where you need to add a record associated with that resource (you create a `Post` through a `Category`), the `parent` is unavailable (the `Post` is not persisted in the database). Therefore, Avo makes the `parent` an instantiated object with its parent populated (a `Post` with the `category_id` populated with the parent `Category` from which you started the creation process) so you can better scope out the data (you know from which `Category` it was initiated).

## Allow detaching via the association

When you visit a record through an association, that `belongs_to` field is disabled. There might be cases where you'd like that field not to be disabled and allow your users to change that association.

You can instruct Avo to keep that field enabled in this scenario using `allow_via_detaching`.

```ruby{12}
class Avo::Resources::Comment < Avo::BaseResource
  self.title = :id

  def fields
    field :id, as: :id
    field :body, as: :textarea

    field :commentable,
      as: :belongs_to,
      polymorphic_as: :commentable,
      types: [::Post, ::Project],
      allow_via_detaching: true
  end
end
```

---

# Has One

:::warning
It's important to set the `inverse_of` as often as possible to your model's association attribute.
:::

# Has One

The `HasOne` association shows the unfolded view of your `has_one` association. It's like peaking on the `Show` view of that associated record. The user can also access the `Attach` and `Detach` buttons.

```ruby
field :admin, as: :has_one
```

<Image src="/assets/img/associations/has-one.jpg" width="919" height="824" alt="Has one" />

## Options

---

# Has Many

By default, the `HasMany` field is visible only on the `Show` view. You will see a new panel with the model's associated records below the regular fields panel.

```ruby
field :projects, as: :has_many
```

## Options

<Option name="`linkable`">

You can add use this option to make the association title clickable. That link will open a new page with the same view.

This feature doesn't go deeper than this. It just helps you see the association table easier in a separate page.

<Image src="/assets/img/3_0/has_many/linkable.gif" width="1200" height="875" alt="" />
</Option>

## Has Many Through

The `HasMany` association also supports the `:through` option.

```ruby{3}
field :members,
  as: :has_many,
  through: :memberships
```
<Option name="`attach_fields`">

<VersionReq version="3.11" />

If you have extra fields defined in the through table and would like to display them when attaching use the `attach_fields` option.

```ruby{4,5,6}
field :patrons,
  as: :has_many,
  through: :patronships,
  attach_fields: -> {
    field :review, as: :text
  }
```

:::warning
If the through model uses **polymorphism**, the type must be included as a hidden field:

```ruby{6}
field :patrons,
  as: :has_many,
  through: :patronships,
  attach_fields: -> {
    field :review, as: :text
    field :patronship_type, as: :hidden, default: "TheType"
  }
```
:::

<Image src="/assets/img/3_0/has_many/attach-fields.gif" width="600" height="338" alt="" />
</Option>

---

# Has And Belongs To Many

The `HasAndBelongsToMany` association works similarly to `HasMany`.

```ruby
field :users, as: :has_and_belongs_to_many
```

## Options

### Searchable `has_and_belongs_to_many`

<div class="flex gap-2 mt-2">
  <VersionReq version="1.25" />
  <LicenseReq license="pro" title="Searchable associations are available as a pro feature" />
</div>

Similar to `belongs_to`, the `has_many` associations support the `searchable` option.

---

# Resource panels
<br>
<Image src="/assets/img/tabs-and-panels/panel.png" width="1024" height="640" alt="Panel" />

Panels are the backbone of Avo's display infrastructure. Most of the information that's on display is wrapped inside a panel. They help maintain a consistent design throughout Avo's pages. They are also available as a view component `Avo::PanelComponent` for custom tools, and you can make your own pages using it.

When using the fields DSL for resources, all fields declared in the root will be grouped into a "main" panel, but you can add your panels.

```ruby
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :text, name: "User Email", required: true

    panel name: "User information", description: "Some information about this user" do
      field :first_name, as: :text, required: true, placeholder: "John"
      field :last_name, as: :text, required: true, placeholder: "Doe"
      field :active, as: :boolean, name: "Is active", show_on: :show
    end
  end
end
```
<Image src="/assets/img/tabs-and-panels/root-and-panel.png" width="1024" height="724" alt="Root fields and panel fields" />

You can customize the panel `name` and panel `description`.

## What is the Main Panel?
The Main Panel is the primary container for fields in a resource. It typically includes the resource's title, action buttons, and fields that are part of the resource's core data. You can think of it as the central hub for managing and displaying the resource's information.

The Main Panel is automatically created by Avo based on your resource's field definitions. However, you can also customize it to meet your specific requirements.

## How does Avo compute panels?
By default Avo's field organization occurs behind the scenes, leveraging multiple panels to simplify the onboarding process and reduce complexity when granular customization is not needed.

When retrieving the fields, the first step involves categorizing them based on whether or not they have their own panel. Fields without their own panels are referred to as "standalone" fields. Notably, most association fields, such as `field :users, as: :has_many`, automatically have their dedicated panels.

During the Avo's grouping process, we ensure that the fields maintain the order in which they were declared.

Once the groups are established, we check whether the main panel has been explicitly declared within the resource. If it has been declared, this step is skipped. However, if no main panel declaration exists, we compute a main panel and assign the first group of standalone fields to it. This ensures that the field arrangement aligns with your resource's structure and maintains the desired order.

## Computed panels vs Manual customization
Let's focus on the `fields` method for the next examples. In these examples, we demonstrate how to achieve the same field organization using both computed panels and manual customization. Each example have the code that makes Avo compute the panels and also have an example on how to intentionally declare the panels in order to achieve the same result.

:::code-group
```ruby [Computed]
def fields
  field :id, as: :id
  field :name, as: :text
  field :user, as: :belongs_to
  field :type, as: :text
end
```

```ruby [Customized]
def fields
  main_panel do
    field :id, as: :id
    field :name, as: :text
    field :user, as: :belongs_to
    field :type, as: :text
  end
end
```
:::

On this example Avo figured out that a main panel was not declared and it computes one with all standalone fields.

<Image src="/assets/img/resource-panels/1.png" width="1942" height="455" alt="" />

<br>

Now let's add some field that is not standalone between `name` and `user` fields.

:::code-group
```ruby{5} [Computed]
def fields
  field :id, as: :id
  field :name, as: :text

  field :reviews, as: :has_many

  field :user, as: :belongs_to
  field :type, as: :text
end
```

```ruby [Customized]
def fields
  main_panel do
    field :id, as: :id
    field :name, as: :text
  end

  field :reviews, as: :has_many

  panel do
    field :user, as: :belongs_to
    field :type, as: :text
  end
end
```
:::

Since the field that has it owns panel was inserted between a bunch of standalone fields Avo will compute a main panel for the first batch of standalone fields (`id` and `name`) and will compute a simple panel for the remaining groups of standalone fields (`user` and `type`)

<Image src="/assets/img/resource-panels/2.png" width="1956" height="885" alt="" />

<br>

With these rules on mind we have the ability to keep the resource simple and also to fully customize it, for example, if we want to switch the computed main panel with the computed panel we can declare them in the desired order.

```ruby
def fields
  panel do
    field :user, as: :belongs_to
    field :type, as: :text
  end

  field :reviews, as: :has_many

  main_panel do
    field :id, as: :id
    field :name, as: :text
  end
end
```

<Image src="/assets/img/resource-panels/3.png" width="1917" height="875" alt="" />

By using the `main_panel` and `panel` method, you can manually customize the organization of fields within your resource, allowing for greater flexibility and control.

## Index view fields

By default, only the fields declared in the root and the fields declared inside `main_panel` will be visible on the `Index` view.

```ruby{4-8}
class Avo::Resources::User < Avo::BaseResource
  def fields
    # Only these fields will be visible on the `Index` view
    field :id, as: :id, link_to_record: true
    field :email, as: :text, name: "User Email", required: true
    field :name, as: :text, only_on: :index do
      "#{record.first_name} #{record.last_name}"
    end

    # These fields will be hidden on the `Index` view
    panel name: "User information", description: "Some information about this user" do
      field :first_name, as: :text, required: true, placeholder: "John"
      field :last_name, as: :text, required: true, placeholder: "Doe"
      field :active, as: :boolean, name: "Is active", show_on: :show
    end
  end
end
```

<Image src="/assets/img/tabs-and-panels/index-view.png" width="1024" height="724" alt="Index view" />

<Option name="`visible`">

<VersionReq version="3.10.7" />
The `visible` option allows you to dynamically control the visibility of a panel and all its children based on certain conditions.

This option is particularly useful when you need to show or hide entire sections of your resource at once without having to do it for each field.

Example:
```ruby
panel name: "User information", visible: -> { resource.record.enabled? } do
  field :first_name, as: :text
  field :last_name, as: :text
end
```
</Option>

---

# Several fields in a cluster

<VersionReq version="3.18.0" class="mt-2" />

:::info
To fully understand this section, you should be familiar with the `stacked` field option and `resource panels`. These concepts will help you structure and customize your fields effectively.
:::

The `cluster` DSL allows you to group multiple fields horizontally within a `panel`. This is useful for organizing related fields in a structured layout.

To enhance readability and maintain a well-organized UI, it is recommended to use the `stacked` option for fields inside clusters.

<Image src="/assets/img/row.png" width="1028" height="230" alt="Cluster" />

```ruby{4-18}
# app/avo/resources/person.rb
class Avo::Resources::Person < Avo::BaseResource
  def fields
    panel "Address" do
      cluster do
        field :street_address, stacked: true do
          "1234 Elm Street"
        end

        field :city, stacked: true do
          "Los Angeles"
        end

        field :zip_code, stacked: true do
          "15234"
        end
      end
    end
  end
end
```

<Option name="`divider`">

<VersionReq version="3.21.0" class="mt-2" />

Adds a horizontal divider between fields.

```ruby{5}
# app/avo/resources/person.rb
class Avo::Resources::Person < Avo::BaseResource
  def fields
    panel "Address" do
      cluster divider: true do # [!code focus]
        field :street_address, stacked: true do
          "1234 Elm Street"
        end

        field :city, stacked: true do
          "Los Angeles"
        end

        field :zip_code, stacked: true do
          "15234"
        end
      end
    end
  end
end
```

<Image src="/assets/img/cluster_with_divider.png" width="1944" height="404" alt="Cluster with divider" />

##### Default value

`false`

#### Possible values

`true`, `false`

</Option>

---

# Resource Sidebar

By default, all declared fields are going to be stacked vertically in the main area. But there are some fields with information that needs to be displayed in a smaller area, like boolean, date, and badge fields.
Those fields don't need all that horizontal space and can probably be displayed in a different space.
That's we created the **resource sidebar**.

## Adding fields to the sidebar

Using the `sidebar` block on a resource you may declare fields the same way you would do on the root level. Notice that the sidebar should be declared inside a panel. Each resource can have several panels or main panels and each panel can have it's own sidebars.

```ruby
class Avo::Resources::User < Avo::BaseResource
  def fields
    main_panel do
      field :id, as: :id, link_to_record: true
      field :first_name, as: :text, placeholder: "John"
      field :last_name, as: :text, placeholder: "Doe"

      # We can also add custom resource tools
      tool UserTimeline

      sidebar do
        field :email, as: :gravatar, link_to_record: true, only_on: :show
        field :active, as: :boolean, name: "Is active", only_on: :show
      end
    end
  end
end
```

<Image src="/assets/img/resource-sidebar/sidebar.jpg" width="1024" height="640" alt="" />

The fields will be stacked in a similar way in a narrower area on the side of the main panel. You may notice that inside each field, the tabel and value zones are also stacked one on top of the other to allow for a larger area to display the field value.

<Option name="panel_wrapper">

The `panel_wrapper` it's helpful when you want to render a custom tool inside a sidebar and you don't want to apply the `white_panel_classes` to it

```ruby
sidebar panel_wrapper: false do
  tool Avo::ResourceTools::SidebarTool
end
```
</Option>

---

# Tabs

Once your Avo resources reach a certain level of complexity, you might feel the need to better organize the fields, associations, and resource tools into groups. You can already use the `heading` to separate the fields inside a panel, but maybe you'd like to do more.

Tabs are a new layer of abstraction over panels. They enable you to group panels and tools together under a single pavilion and toggle between them.

```ruby
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :text, name: "User Email", required: true

    tabs do
      tab "User information", description: "Some information about this user" do
        panel do
          field :first_name, as: :text, required: true, placeholder: "John"
          field :last_name, as: :text, required: true, placeholder: "Doe"
          field :active, as: :boolean, name: "Is active", show_on: :show
        end
      end

      field :teams, as: :has_and_belongs_to_many
      field :people, as: :has_many
      field :spouses, as: :has_many
      field :projects, as: :has_and_belongs_to_many
    end
  end
end
```

<Image src="/assets/img/tabs-and-panels/tabs.png" width="1024" height="640" alt="Avo tabs" />

To use tabs, you need to open a `tabs` group block. Next, you add your `tab` block where you add fields and panels like you're used to on resource root. Most fields like `text`, `number`, `gravatar`, `date`, etc. need to be placed in a `panel`. However, the `has_one`, `has_many`, and `has_and_belongs_to_many` have their own panels, and they don't require a `panel` or a `tab`.

The tab `name` is mandatory is what will be displayed on the tab switcher. The tab `description` is what will be displayed in the tooltip on hover.

<Image src="/assets/img/tabs-and-panels/tab-name-description.png" width="640" height="211" alt="Avo tab name and description" />

## Tabs on Show view

Tabs have more than an aesthetic function. They have a performance function too. On the <Show /> page, if you have a lot of `has_many` type of fields or tools, they won't load right away, making it a bit more lightweight for your Rails app. Instead, they will lazy-load only when they are displayed.

## Tabs on Edit view

All visibility rules still apply on <Edit />, meaning that `has_*` fields will be hidden by default. However, you can enable them by adding `show_on: :edit`. All other fields will be loaded and hidden on page load. This way, when you submit a form, if you have validation rules in place requiring a field that's in a hidden tab, it will be present on the page on submit-time.

## Durable and "Bookmarkable"

Tabs remain durable within views, meaning that when switch between views, each tab group retains the selected tab. This ensures a consistent UX, allowing for seamless navigation without losing context.

Moreover, you have the ability to bookmark a link with a personalized tab selection.

This functionalities relies on the unique tab group ID. To take full advantage of this feature, it's important to assign a unique ID to each tab group defined in your application.

```ruby {1}
tabs id: :some_random_uniq_id do
  field :posts, as: :has_many, show_on: :edit
end
```

## Display counter indicator on tabs switcher

Check this recipe on how to enhance your tabs switcher with a counter for each association tab.

## Visibility control

<VersionReq version="3.10.10" />

Both `tabs` and individual `tab` components support a `visible` option that allows you to dynamically control their visibility based on certain conditions. For example, you might want to hide a tab if the user doesn't have the necessary permissions to view its content.

<Option name="`visible`">

The `visible` option allows you to control the visibility of either a group of tabs or an individual tab. It can be a `boolean` or a lambda.

#### Example

```ruby
tabs visible: -> { resource.record.enabled? } do
  tab name: "General Information" do
    panel do
      field :name, as: :text
      field :email, as: :text
    end
  end
  tab "Admin Information", visible: -> { current_user.is_admin? } do
    panel do
      field :role, as: :text
      field :permissions, as: :text
    end
  end
end
```

In this example:
- The entire group of tabs is only visible if the record is enabled (`resource.record.enabled?`).
- Within this group, the "General Information" tab is always visible when the tabs are shown.
- The "Admin Information" tab is only visible for admin records (`resource.record.admin?`).

</Option>

<Option name="`title`">

<VersionReq version="3.15.0" />

The `title` option enables you to specify a label for the entire group of tabs. This title serves as an overarching descriptor for the collection, providing context regarding the purpose or content of the tabs.

You can define the title of a tabs group by passing it as an argument to the `tabs` block. The value should be a string that succinctly encapsulates the theme or purpose of the tabs.

```ruby
tabs title: "Tabs group title" do
  # ...
end
```

</Option>

<Option name="`description`">

<VersionReq version="3.15.0" />

The `description` option allows you to provide an auxiliary explanation or detailed note for the entire group of tabs. This can be used to elaborate on the purpose of the tabs or provide additional guidance.

You can define a description for a tabs group by passing it as an argument to the `tabs` block. The value should be a string that offers further clarity about the content or functionality of the tabs.

```ruby
tabs description: "Tabs group description" do
  # ...
end
```

</Option>

<Option name="`lazy_load`">

<VersionReq version="3.17.0" />

The `lazy_load` option enables deferred loading of tab content, improving performance by fetching data only when the tab is clicked. By default, `lazy_load` is set to `false`, ensuring that all tabs load immediately. However, in form views, this option is automatically disabled to prevent data loss during form submission.

```ruby{2}
tabs do
  tab "Address", lazy_load: true do
    # ...
  end
end
```

</Option>

---

# Views

The Avo CRUD feature generates with four main views for each resource.

<Option name="`Index`">

The page where you see all your resources listed in a table or a grid.
<br/>
<RelatedList>
  <RelatedItem href="./customization.html#click_row_to_view_record">Click row to view record</RelatedItem>
  <RelatedItem href="./resources.html#self.components">Resource custom components</RelatedItem>
</RelatedList>

</Option>

<Option name="`Show`">

The page where you see one resource in more detail.
<br/>
<RelatedList>
  <RelatedItem href="./resources.html#self.components">Resource custom components</RelatedItem>
</RelatedList>

</Option>

<Option name="`Edit`">

The page where you can edit one resource.
<br/>
<RelatedList>
  <RelatedItem href="./resources.html#self.components">Resource custom components</RelatedItem>
</RelatedList>

</Option>

<Option name="`New`">

The page where you can create a new resource.
<br/>
<RelatedList>
  <RelatedItem href="./resources.html#self.components">Resource custom components</RelatedItem>
</RelatedList>

</Option>

<Option name="`Display`">

`:display` is an alias for the the `Index` and `Show` views where you can display records and their details.

</Option>

<Option name="`Form`">

`:form` is an alias for the `Edit` and `New` views for creating and editing records.

</Option>

## Preview

The fields marked with `show_on :preview`, will be show in the preview field popup.
By default, all fields are hidden in `:preview`.

## Checking the current view

The `view` object, available in the code, is an instance of the `Avo::ViewInquirer` class.
This enables you to examine the existing `view` status through expressions such as `view.show?` and `view.index?`.
Essentially, these are equivalent to asserting whether view equals `show` or `index`.

## Multiple ways to check

```ruby
view == "edit" # Check against a string
view == :edit # Check against a symbol
view.edit? # Ask if it's a view
view.form? # Ask if it's a collection of views
view.in? [:edit, :new] # Check against an array of symbols
view.in? ["edit", "new"] # Check against an array of strings
```

::: code-group
```ruby [Ask]
if view.show?
  # Code for the "show" view
elsif view.index?
  # Code for the "index" view
elsif view.edit?
  # Code for the "edit" view
elsif view.new?
  # Code for the "new" view
elsif view.form?
  # Code for the "new" or "edit" views
elsif view.display?
  # Code for the "index or "show" views
end
```

```ruby [Symbol comparator]
if view == :show
  # Code for the "show" view
elsif view == :index
  # Code for the "index" view
elsif view == :edit
  # Code for the "edit" view
elsif view == :new
  # Code for the "new" view
end
```

```ruby [String comparator]
if view == "show"
  # Code for the "show" view
elsif view == "index"
  # Code for the "index" view
elsif view == "edit"
  # Code for the "edit" view
elsif view == "new"
  # Code for the "new" view
end
```
:::

It's also possible to check if the view is on a `form` (`new`, `edit`) or `display` (`index`, `show`).

::: code-group
```ruby [Ask]
if view.form?
  # Code for the "new" and "edit" views
elsif view.display?
  # Code for the "show" and "index" views
end
```

```ruby [Symbol comparator]
if view.in? [:new, :edit]
  # Code for the "new" and "edit" views
elsif view.in? [:show, :index]
  # Code for the "show" and "index" views
end
```

```ruby [String comparator]
if view.in? ["new", "edit"]
  # Code for the "new" and "edit" views
elsif view.in? ["show", "index"]
  # Code for the "show" and "index" views
end
```
:::

---

# Table View

The table view is the default way to display resources in Avo. It provides a powerful, tabular layout that supports searching, sorting, filtering, and pagination out of the box.

<Image src="/assets/img/table-view.png" width="1919" height="1122" alt="Table view" />

## Row controls configuration
:::info
The configuration options for row controls depend on the version of Avo you are using.

**If you are using a version earlier than <Version version="3.16.3" />**, refer to the following pages for guidance:

- How to adjust resource controls globally for all resources
- Customize the placement of controls for individual resources
:::

By default, resource controls are positioned on the right side of record rows. However, if the table contains many columns, these controls may become obscured. In such cases, you may prefer to move the controls to the left side for better visibility.

<VersionReq version="3.16.3" /> Avo provides configuration options that allow you to customize row controls placement, floating behavior, and visibility on hover either globally or individually for each resource.

## Global configuration

`resource_row_controls_config` defines the default settings for row controls across all resources. These global configurations will apply to each resource unless explicitly overridden.

This option can be configured on `config/initializers/avo.rb` and defaults to the following:

```ruby{3-7}
# config/initializers/avo.rb
Avo.configure do |config|
  config.resource_row_controls_config = {
    placement: :right,
    float: false,
    show_on_hover: false
  }
end
```

## Resource configuration

`row_controls_config` allows you to customize the row controls for a specific resource, overriding the global configuration.

This option can be configured individually for each resource and defaults to the global configuration value defined in `resource_row_controls_config`.

```ruby{3-7}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  self.row_controls_config = {
    placement: :right,
    float: false,
    show_on_hover: false,
  }
end
```

<Option name="`placement`">

Defines the position of the row controls.

##### Optional

`true`

##### Default value

`:right`

#### Possible values

- `:left` - Places the controls on the **left side** of the resource row.
- `:right` - Places the controls on the **right side** of the resource row.
- `:both` - Displays controls on **both sides** of the resource row.

:::warning
The `float` and `show_on_hover` options are designed to function optimally when `placement` is set to `:right`. While Avo does not restrict its usage with `:left` or `:both`, the applied styles are specifically intended for use with `:right`, and unexpected behavior may occur with other placements.
:::
</Option>

<Option name="`float`">

Determines whether the row controls should float over the row.

<DemoVideo demo-video="https://youtu.be/wnWvzQyyo6A?t=698" class="mb-4" />

##### Optional

`true`

##### Default value

`false`

#### Possible values

- `true` - Enables floating behavior.
- `false` - Disables floating behavior (default).
</Option>

<Option name="`show_on_hover`">

Controls whether the row controls should be displayed only on hover.

##### Optional

`true`

##### Default value

`false`

#### Possible values

- `true` - Displays the controls on hover only.
- `false` - Always shows the controls (default).
</Option>

---

# Grid view

<br>
<Image src="/assets/img/grid-view.jpg" width="1312" height="1096" alt="Avo grid view" />

Some resources are best displayed in a grid view. We can do that with Avo using a `cover_url`, a `title`, and a `body`.

## Enable grid view

To enable grid view for a resource, you need to configure the `grid_view` class attribute on the resource. That will add the grid view to the view switcher on the <Index /> view.

```ruby{2-13}
class Avo::Resources::Post < Avo::BaseResource
  self.grid_view = {
    card: -> do
      {
        cover_url:
          if record.cover_photo.attached?
            main_app.url_for(record.cover_photo.url)
          end,
        title: record.name,
        body: record.truncated_body
      }
    end
  }
end
```

<Image src="/assets/img/view-switcher.png" width="822" height="153" alt="Avo view switcher" />

## Make default view

To make the grid the default way of viewing a resource **Index**, we have to use the `default_view_type` class attribute.

```ruby{2}
class Avo::Resources::Post < Avo::BaseResource
  self.default_view_type = :grid
end
```

## Custom style

You may want to customize the card a little bit. That's possible using the `html` option.

```ruby{13-37}
class Avo::Resources::Post < Avo::BaseResource
  self.grid_view = {
    card: -> do
      {
        cover_url:
          if record.cover_photo.attached?
            main_app.url_for(record.cover_photo.url)
          end,
        title: record.name,
        body: record.truncated_body
      }
    end,
    html: -> do
      {
        title: {
          index: {
            wrapper: {
              classes: "bg-blue-50 rounded-md p-2"
            }
          }
        },
        body: {
          index: {
            wrapper: {
              classes: "bg-gray-50 rounded-md p-1"
            }
          }
        },
        cover: {
          index: {
            wrapper: {
              classes: "blur-sm"
            }
          }
        }
      }
    end
  }
end
```

<Image src="/assets/img/grid-html-option.png" width="1014" height="637" alt="Grid html option" />

## Grid Item Badge

<VersionReq version="3.15" />

<br>
<br>

<Image src="/assets/img/3_0/grid-view/grid-badge.png" size="2080â€Šx1210" alt="Avo Grid View Badge Element" />

One common scenario is to show a badge on top of your grid items. Avo enables you to do that pretty easy using these three options.

<Option name="`badge_label`">

The label is what the user sees on top of your grid item.

```ruby{7}
self.grid_view = {
  card: -> do
    {
      cover_url: record.image.attached? ? main_app.url_for(record.image.variant(resize: "300x300")) : nil,
      title: record.title,
      body: simple_format(record.description),
      badge_label: (record.updated_at < 1.week.ago ? "New" : "Updated"),
    }
  end
}
```

<Image src="/assets/img/3_0/grid-view/badge-label.png" size="1022â€Šx686" alt="Avo Grid View Badge Label" />

</Option>

<Option name="`badge_color`">

You may style it in any [TailwindCSS color](https://tailwindcss.com/docs/customizing-colors#default-color-palette) you prefer.

It only needs to know the color name (`green`, `blue`, `fuchsia`, etc.).

```ruby{8}
self.grid_view = {
  card: -> do
    {
      cover_url: record.image.attached? ? main_app.url_for(record.image.variant(resize: "300x300")) : nil,
      title: record.title,
      body: simple_format(record.description),
      badge_label: (record.updated_at < 1.week.ago ? "New" : "Updated"),
      badge_color: (record.updated_at < 1.week.ago ? "green" : "orange")
    }
  end
}
```

<Image src="/assets/img/3_0/grid-view/badge-color.png" size="1016xâ€Š678" alt="Avo Grid View Badge Color" />

</Option>

<Option name="`badge_title`">

The title refers to the tooltip that the user gets when they hover over the badge.

```ruby{9}
self.grid_view = {
  card: -> do
    {
      cover_url: record.image.attached? ? main_app.url_for(record.image.variant(resize: "300x300")) : nil,
      title: record.title,
      body: simple_format(record.description),
      badge_label: (record.updated_at < 1.week.ago ? "New" : "Updated"),
      badge_color: (record.updated_at < 1.week.ago ? "green" : "orange"),
      badge_title: (record.updated_at < 1.week.ago ? "New product here" : "Updated product here")
    }
  end
}
```

<Image src="/assets/img/3_0/grid-view/badge-title.png" size="1088xâ€Š740" alt="Avo Grid View Badge Title" />

</Option>

---

# Map view

Some resources that contain geospatial data can benefit from being displayed on a map. For
resources to be displayed to the map view they require a `coordinates` field, but that's customizable.

## Enable map view

To enable map view for a resource, you need to add the `map_view` class attribute to a resource. That will add the view switcher to the <Index /> view.

<Image src="/assets/img/map-view.png" width="3240" height="1970" alt="Avo view switcher" />

```ruby
class Avo::Resources::City < Avo::BaseResource
  # ...
  self.map_view = {
    mapkick_options: {
      controls: true
    },
    record_marker: -> {
      {
        latitude: record.coordinates.first,
        longitude: record.coordinates.last,
        tooltip: record.name
      }
    },
    table: {
      visible: true,
      layout: :right
    }
  }
end
```

:::warning
You need to add the `mapkick-rb` (not `mapkick`) gem to your `Gemfile` and have the `MAPBOX_ACCESS_TOKEN` environment variable with a valid [Mapbox](https://account.mapbox.com/auth/signup/) key.
:::

<Option name="`mapkick_options`">

The options you pass here are forwarded to the [`mapkick` gem](https://github.com/ankane/mapkick).

</Option>

<Option name="`record_marker`">

This block is being applied to all the records present in the current query to fetch the coordinates of off the record.

You may use this block to fetch the coordinates from other places (API calls, cache queries, etc.) rather than the database.

This block has to return a hash compatible with the [`PointMap` items](https://github.com/ankane/mapkick#point-map). Has to have `latitude` and `longitude` and optionally `tooltip`, `label`, or `color`.
</Option>

<Option name="`table`">

This is the configuration for the adjacent table. You can set the visibility to `true` or `false`, and set the position of the table `:top`, `:right`, `:bottom`, or `:left`.
</Option>

<Option name="`extra_markers`">

Available since version <Version version="3.10.3" />

Allow to define extra markers. The `extra_markers` block is executed in the `ExecutionContext` and should return an array of hashes.

For each extra marker, you can specify a label, tooltip, and color.

```ruby
self.map_view = {
  # ...
  extra_markers: -> do
    [
      {
        latitude: 37.780411,
        longitude: -25.497047,
        label: "AÃ§ores",
        tooltip: "SÃ£o Miguel",
        color: "#0F0"
      }
    ]
  end,
  # ...
}
```
<Image src="/assets/img/extra-markers.png" width="3240" height="1970" alt="Map extra markers" />
</Option>

## Make it the default view

To make the map view the default way of viewing a resource on <Index />, we have to use the `default_view_type` class attribute.

```ruby{7}
class Avo::Resources::City < Avo::BaseResource
  self.default_view_type = :map
end
```

---

# Customization options

## Change the app name

On the main navbar next to the logo, Avo generates a link to the homepage of your app. The label for the link is usually computed from your Rails app name. You can customize that however, you want using `config.app_name = 'Avocadelicious'`.

The `app_name` option is also callable using a block. This is useful if you want to reference a `I18n.t` method or something more dynamic.

```ruby
Avo.configure do |config|
  config.app_name = -> { I18n.t "app_name" }
end
```

## Timezone and Currency

Your data-rich app might have a few fields where you reference `date`, `datetime`, and `currency` fields. You may customize the global timezone and currency with `config.timezone = 'UTC'` and `config.currency = 'USD'` config options.

## Resource Index view

There are a few customization options to change how resources are displayed in the **Index** view.

### Resources per page

You may customize how many resources you can view per page with `config.per_page = 24`.

<Image src="/assets/img/resource-index/per-page-config.jpg" width="648" height="438" alt="Per page config" />

### Per page steps

Similarly customize the per-page steps in the per-page picker with `config.per_page_steps = [12, 24, 48, 72]`.

<Image src="/assets/img/resource-index/per-page-steps.jpg" width="628" height="422" alt="Per page config" />

### Resources via per page

For `has_many` associations you can control how many resources are visible in their `Index view` with `config.via_per_page = 8`.

### Default view type

The `ResourceIndex` component supports two view types `:table` and `:grid`. You can change that by `config.default_view_type = :table`. Read more on the grid view configuration page.

<div class="grid grid-flow-row sm:grid-flow-col sm:grid-cols-2 gap-2 w-full">
  <div class="w-full">
    <strong>Table view</strong>
    <Image src="/assets/img/customization/table-view.png" width="2400" height="1500" alt="Table view" />
  </div>
  <div class="w-full">
    <strong>Grid view</strong>
    <Image src="/assets/img/customization/grid-view.jpg" width="1312" height="1096" alt="Grid view" />
  </div>
</div>

## ID links to resource

On the **Index** view, each row has the controls component at the end, which allows the user to go to the **Show** and **Edit** views and delete that entry. If you have a long row and a not-so-wide display, it might not be easy to scroll to the right-most section to click the **Show** link.

You can enable the `id_links_to_resource` config option to make it easier.

```ruby{4}
Avo.configure do |config|
  config.root_path = '/avo'
  config.app_name = 'Avocadelicious'
  config.id_links_to_resource = true
end
```

That will render all `id` fields in the **Index** view as a link to that resource.

<Image src="/assets/img/fields-reference/as-link-to-resource.jpg" width="694" height="166" alt="As link to resource" />

## Resource controls on the left or both sides

:::warning
<VersionReq version="3.16.3" /> `resource_controls_placement` option is **obsolete**.

Check row controls configuration on table view instead
:::

<DemoVideo demo-video="https://youtu.be/MfryUtcXqvU?t=706" />

By default, the resource controls are located on the right side of the record rows, which might be hidden if there are a lot of columns. You might want to move the controls to the left side in that situation using the `resource_controls_placement` option.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.resource_controls_placement = :left
end
```

<Image src="/assets/img/customization/resource-controls-left.jpg" width="1206" height="920" alt="Resource controls on the left side" />

<VersionReq version="3.13.7" class="mt-2" /> You're able to render the controls on both sides

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.resource_controls_placement = :both
end
```

## Container width

```ruby{2-3}
Avo.configure do |config|
  config.full_width_index_view = false
  config.full_width_container = false
end
```

Avo's default main content is constrained to a regular [Tailwind CSS container](https://tailwindcss.com/docs/container). If you have a lot of content or prefer to display it full-width, you have two options.

### Display the `Index` view full-width

Using `full_width_index_view: true` tells Avo to display the **Index** view full-width.

### Display all views full-width

Using `full_width_container: true` tells Avo to display all views full-width.

## Cache resources on the `Index` view

Avo caches each resource row (or Grid item for Grid view) for performance reasons. You can disable that cache using the `cache_resources_on_index_view` configuration option. The cache key is using the record's `id` and `created_at` attributes and the resource file `md5`.

:::info
If you use the `visibility` option to show/hide fields based on the user's role, you should disable this setting.
:::

```ruby{2}
Avo.configure do |config|
  config.cache_resources_on_index_view = false
end
```

## Context

In the `Resource` and `Action` classes, you have a global `context` object to which you can attach a custom payload. For example, you may add the `current_user`, the current request `params`, or any other arbitrary data.

You can configure it using the `set_context` method in your initializer. The block you pass in will be instance evaluated in `Avo::ApplicationController`, so it will have access to the `_current_user` method or `Current` object.

```ruby{3-6}
Avo.configure do |config|
  config.set_context do
    {
      foo: 'bar',
      params: request.params,
    }
  end
end
```

:::warning `_current_user`
It's recommended you don't store your current user here but using the `current_user_method` config.
:::

You can access the context data with `::Avo::Current.context` object.

## Eject
This section has moved.

## Breadcrumbs

By default, Avo ships with breadcrumbs enabled.

<Image src="/assets/img/customization/breadcrumbs.jpg" width="618" height="297" alt="Avo breadcrumbs" />

You may disable them using the `display_breadcrumbs` configuration option.

```ruby{2}
Avo.configure do |config|
  config.display_breadcrumbs = false
end
```

The first item on the breadcrumb is **Home** with the `root_path` URL. You can customize that using the `set_initial_breadcrumbs` block.

```ruby{2-5}
Avo.configure do |config|
  config.set_initial_breadcrumbs do
    add_breadcrumb "Casa", root_path
    add_breadcrumb "Something else", something_other_path
  end
end
```

Avo uses the [breadcrumbs_on_rails](https://github.com/weppos/breadcrumbs_on_rails) gem under the hood.

### Breadcrumbs for custom pages

You can add breadcrumbs to custom pages in the controller action.

```ruby{3}
class Avo::ToolsController < Avo::ApplicationController
  def custom_tool
    add_breadcrumb "Custom tool"
  end
end
```

## Page titles

When you want to update the page title for a custom tool or page, you only need to assign a value to the `@page_title` instance variable in the controller method.

```ruby{3}
class Avo::ToolsController < Avo::ApplicationController
  def custom_tool
    @page_title = "Custom tool page title"
  end
end
```

Avo uses the [meta-tags](https://github.com/kpumuk/meta-tags) gem to compile and render the page title.

## Home path

When a user clicks your logo inside Avo or goes to the `/avo` URL, they will be redirected to one of your resources. You might want to change that path to something else, like a custom page. You can do that with the `home_path` configuration.

```ruby{2}
Avo.configure do |config|
  config.home_path = "/avo/dashboard"
end
```

### Use a lambda function for the home_path

<VersionReq version="2.8.0" class="mt-2" />

You can also use a lambda function to define that path.

```ruby{2}
Avo.configure do |config|
  config.home_path = -> { avo_dashboards.dashboard_path(:dashy) }
end
```

When you configure the `home_path` option, the `Get started` sidebar item will be hidden in the development environment.

Now, users will be redirected to `/avo/dashboard` whenever they click the logo. You can use this configuration option alongside the `set_initial_breadcrumbs` option to create a more cohesive experience.

```ruby{2-5}
Avo.configure do |config|
  config.home_path = "/avo/dashboard"
  config.set_initial_breadcrumbs do
    add_breadcrumb "Dashboard", "/avo/dashboard"
  end
end
```

## Mount Avo under a nested path

You may need to mount Avo under a nested path, something like `/uk/admin`. In order to do that, you need to consider a few things.

1. Move the engine mount point below any route for custom tools.

```ruby{7,10}
Rails.application.routes.draw do
  # other routes

  authenticate :user, ->(user) { user.is_admin? } do
    scope :uk do
      scope :admin do
        get "dashboard", to: "avo/tools#dashboard" # custom tool added before engine
      end

      mount_avo # engine mounted last
    end
  end
end
```

2. The `root_path` configuration should only be the last path segment.

```ruby
# ðŸš« Don't add the scope to the root_path
Avo.configure do |config|
  config.root_path = "/uk/admin"
end

# âœ… Do this instead
Avo.configure do |config|
  config.root_path = "/admin"
end
```

3. Use full paths for other configurations.

```ruby
Avo.configure do |config|
  config.home_path = "/uk/admin/dashboard"

  config.set_initial_breadcrumbs do
    add_breadcrumb "Dashboard", "/uk/admin/dashboard"
  end
end
```

## Custom `view_component` path

You may not keep your view components under `app/components` and want the generated field `view_component`s to be generated in your custom directory. You can change that using the `view_component_path` configuration key.

```ruby
Avo.configure do |config|
  config.view_component_path = "app/frontend/components"
end
```

## Custom query scopes

You may want to change Avo's queries to add sorting or use gems like [friendly](https://github.com/norman/friendly_id).
You can do that using `index_query` for multiple records and `find_record_method` when fetching one record.

### Custom scope for `Index` page

Using `index_query` you tell Avo how to fetch the records for the `Index` view.

```ruby
class Avo::Resources::User < Avo::BaseResource
  self.index_query = -> {
    query.order(last_name: :asc)
  }
end
```

### Custom find method for `Show` and `Edit` pages

Using `find_record_method` you tell Avo how to fetch one record for `Show` and `Edit` views and other contexts where a record needs to be fetched from the database.

This is very useful when you use something like `friendly` gem, custom `to_param` methods on your model, and even the wonderful `prefix_id` gem.

#### Custom `to_param` method

The following example shows how you can update the `to_param` (to use the post name) method on the `User` model to use a custom attribute and then update the `Avo::Resources::User` so it knows how to search for that model.

::: code-group
```ruby [app/avo/resources/post.rb]
class Avo::Resource::Post < Avo::BaseResource
  self.find_record_method = -> {
    # When using friendly_id, we need to check if the id is a slug or an id.
    # If it's a slug, we need to use the find_by_slug method.
    # If it's an id, we need to use the find method.
    # If the id is an array, we need to use the where method in order to return a collection.
    if id.is_a?(Array)
      id.first.to_i == 0 ? query.where(slug: id) : query.where(id: id)
    else
      id.to_i == 0 ? query.find_by_slug(id) : query.find(id)
    end
  }
end
```

```ruby [app/models/post.rb]
class Post < ApplicationRecord
  before_save :update_slug

  def to_param
    slug || id
  end

  def update_slug
    self.slug = name.parameterize
  end
end
```
:::

#### Using the `friendly` gem

::: code-group
```ruby [app/avo/resources/user.rb]
class Avo::Resources::User < Avo::BaseResource
  self.find_record_method = -> {
    if id.is_a?(Array)
      query.where(slug: id)
    else
      # We have to add .friendly to the query
      query.friendly.find id
    end
  }
end
```

```ruby [app/models/user.rb]
class User < ApplicationRecord
  extend FriendlyId

  friendly_id :name, use: :slugged
end
```
:::

#### Using `prefixed_ids` gem

You really don't have to do anything on Avo's side for this to work. You only need to add the `has_prefix_id` the model as per the documentation. Avo will know how to search for the record.

```ruby
class Course < ApplicationRecord
  has_prefix_id :course
end
```

## Disable features

You might want to disable some Avo features. You can do that using the `disabled_features` option.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.disabled_features = [:global_search]
end
```

<VersionReq version="3.13.5" /> `disabled_features` become callable. Within this block, you gain access to all attributes of `Avo::ExecutionContext`

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.disabled_features = -> { current_user.is_admin? ? [] : [:global_search] }
end
```

After this setting, the global search will be hidden for users.

Supported options:

- `global_search`

## Customize profile name, photo, and title

You might see on the sidebar footer a small profile widget. The widget displays three types of information about the user; `name`, `photo`, and `title`.

### Customize the name of the user

Avo checks to see if the object returned by your `current_user_method` responds to a `name` method. If not, it will try the `email` method and then fall back to `Avo user`.

### Customize the profile photo

Similarly, it will check if that current user responds to `avatar` and use that as the `src` of the photo.

### Customize the title of the user

Lastly, it will check if it responds to the `avo_title` method and uses that to display it under the name.

### Customize the sign-out link

Please follow this guide in authentication.

## Skip show view

<div class="space-x-2">
  <VersionReq version="2.16" />
  <BetaStatus label="Public beta"></BetaStatus>
</div>

In the CRUD interface Avo adds the <Show /> view by default. This means that when your users will see the view icon to go to that detail page and they will be redirected to the <Show /> page when doing certain tasks (update a record, run an action, etc.).

You might not want that behavior and you might not use the <Show /> view at all and prefer to skip that and just use the <Edit /> view.
Adding `config.skip_show_view = true` to your `avo.rb` configuration file will tell Avo to skip it and use the <Edit /> view as the default resource view.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.skip_show_view = true
end
```

<Image src="/assets/img/customization/skip_show_view.gif" width="1870" height="880" alt="" />

## Logger

You may want to set a different output stream for avo logs, you can do that by returning it on a `config.logger` Proc

```ruby
## == Logger ==
config.logger = -> {
  file_logger = ActiveSupport::Logger.new(Rails.root.join("log", "avo.log"))

  file_logger.datetime_format = "%Y-%m-%d %H:%M:%S"
  file_logger.formatter = proc do |severity, time, progname, msg|
    "[Avo] #{time}: #{msg}\n".tap do |i|
      puts i
    end
  end

  file_logger
}
```

<Option name="`default_url_options`">

`default_url_options` is a Rails [controller method](https://apidock.com/rails/ActionController/Base/default_url_options) that will append params automatically to the paths you generate through path helpers.

In order to implement some features like route-level Multitenancy we exposed an API to add to Avo's `default_url_options` method.

::: code-group
```ruby [config/initializers/avo.rb]{2}
Avo.configure do |config|
  config.default_url_options = [:account_id]
end
```
```ruby [app/config/routes.rb]{3}
Rails.application.routes.draw do
  # Use to test out route-based multitenancy
  scope "/account/:account_id" do
    mount_avo
  end
end
```
:::

Now, when you visit `https://example.org/account/adrian/avo`, the `account_id` param is `adrian` and it will be appended to all path helpers.
</Option>

<Option name="`turbo`">

You may want to configure how turbo behave on Avo.

You can configure it using `config.turbo` option on `avo.rb` initializer

Supported options with default values:

```ruby
  config.turbo = -> do
    {
      instant_click: true
    }
  end
```
</Option>

<Option name="`pagination`">

You can configure the default pagination settings key by key.

```ruby
config.pagination = {
  type: :countless
}

# Or

config.pagination = -> do
  {
    type: :countless,
  }
end
```

This will make all your application's tables countless keeping the size key / value as the default one.

Verify all possible options here.
</Option>

<Option name="`click_row_to_view_record`">

This setting allows your users to click on a record to navigate to its <Show /> view.

:::warning
This interaction (clicking a `tr` element to behave as a link) is not natively supported in HTML.

Avo enhances this functionality with JavaScript, which may lead to side effects. Please report any issues you encounter on our [issue queue](https://avo.cool/new-issue).
:::

Enable this setting by using the `click_row_to_view_record` configuration option.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.click_row_to_view_record = true
end
```

<Image src="/assets/img/3_0/customization/click-row-to-view-record.gif" width="" height="" alt="Click to view record in Avo" />
</Option>

## Associations lookup list limit

<Option name="`associations_lookup_list_limit`">

<VersionReq version="3.14.1" />

By default, there is a limit of a 1000 records per query when listing the association options. This limit ensures that the page will not crash due to large collections.
Use `associations_lookup_list_limit` configuration to change the limit value.

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.associations_lookup_list_limit = 1000
end
```

The message `There are more records available.` is shown when the limit is reached. To localize the message you can use `I18n.translate("avo.more_records_available")`.

Using searchable is recommended for listing unlimited records with better performance and user experience.

<Image src="/assets/img/customization/associations-lookup-list-limit.png" width="2466" height="1098" alt="Associations lookup list limit configuration" />
</Option>

<Option name="`persistence`">

### Persistent UI State Configuration <VersionReq version="3.15.4" />

#### Overview

The `persistence` configuration enables retention of specific UI settings, such as pagination and static filters, across user interactions.

---

#### Configuration

By default, the `:driver` is `nil`, which means no persistence is applied. You can configure the `:driver` for persistence as follows:

```ruby
Avo.configure do |config|
  config.persistence = {
    driver: :session
  }

  # Or with a dynamic block

  config.persistence = -> do
    {
      driver: :session
    }
  end
end
```

---

#### Behavior

When enabled, the `persistence` configuration ensures the following:

1. **Associations Pagination**
   The pagination state (e.g., `page` and `per_page` settings) for association tables (e.g., `has_many` fields) is retained across requests.

2. **Static Filters**
   Static filter selections applied by users are preserved during their session.

---

#### How It Works

Setting `:driver` to `:session` stores the UI state in the user session, enabling it to persist while the session remains active.

---

:::warning
**Important**:
To prevent issues with session storage limits, avoid relying solely on the default **cookie store** for session management. The **cookie store** in Rails has a size limit of 4096 bytes. Storing multiple pagination states and filter settings may exceed this limit, resulting in an `ActionDispatch::Cookies::CookieOverflow` error.
:::

#### Recommended Session Store

To mitigate potential storage overflow, it is advisable to use a more scalable session store, such as:

- **Redis Store**
- **MemCache Store**

For detailed guidance, refer to the [Rails session store configuration](https://guides.rubyonrails.org/v8.0/configuring.html#config-session-store).

---

By adopting the `persistence` configuration with a suitable session store, you can ensure a seamless user experience.
</Option>

<Option name="`alert_dismiss_time`">

Specifies the duration (in milliseconds) for which alerts remain visible before automatically dismissing.
A lower value results in quicker dismissal, while a higher value keeps the alert on screen for longer.

### Default value

`5000`

### Example

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.alert_dismiss_time = 8000
end
```

</Option>

<Option name="`first_sorting_option`">

Defines the default sorting option for the fields on the index view.

### Default value

`:desc`

### Possible values

- `:asc`
- `:desc`

### Example

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.first_sorting_option = :asc
end
```

</Option>

<Option name="`exclude_from_status`">

Defines which status items to exclude from the status page (`/avo_private/status`). This is useful for hiding sensitive information like license keys from the status page.

### Default value

`[]`

### Possible values

An array of strings or a callable that returns an array of strings representing the status items to exclude.

### Example

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.exclude_from_status = ["license_key"]

  # OR using a callable
  config.exclude_from_status = -> do
    ["license_key"]
  end
end
```

### Common use case

The most common use case is to exclude the `license_key` from being displayed on the status page for security reasons.
</Option>

---

# Eject

If you want to change one of Avo's built-in views, you can eject it, update it and use it in your admin panel.

:::warning
Once ejected, the views will not receive updates on new Avo releases. You must maintain them yourself.
:::

<Option name="`--partial`">

Utilize the `--partial` option when you intend to extract certain partial

## Prepared templates

We prepared a few templates to make it easier for you.

`bin/rails generate avo:eject --partial :logo` will eject the `_logo.html.erb` partial.

```
â–¶ bin/rails generate avo:eject --partial :logo
Running via Spring preloader in process 20947
      create  app/views/avo/logo/_logo.html.erb
```

A list of prepared templates:

- `:logo` âž¡ï¸ &nbsp; `app/views/avo/partials/_logo.html.erb`
- `:head` âž¡ï¸ &nbsp; `app/views/avo/partials/_head.html.erb`
- `:header` âž¡ï¸ &nbsp; `app/views/avo/partials/_header.html.erb`
- `:scripts` âž¡ï¸ &nbsp; `app/views/avo/partials/_scripts.html.erb`
- `:sidebar_extra` âž¡ï¸ &nbsp; `app/views/avo/partials/_sidebar_extra.html.erb`

### Logo

In the `app/views/avo/partials` directory, you will find the `_logo.html.erb` partial, which you may customize however you want. It will be displayed in place of Avo's logo.

### Header

The `_header.html.erb` partial enables you to customize the name and link of your app.

### Scripts

The `_scripts.html.erb` partial enables you to insert scripts in the footer of your admin.

## Eject any template

You can eject any partial from Avo using the partial path.

```
â–¶ bin/rails generate avo:eject --partial app/views/layouts/avo/application.html.erb
      create  app/views/layouts/avo/application.html.erb
```
</Option>

<Option name="`--component`">

You can eject any view component from Avo using the `--component` option.

```bash
$ bin/rails generate avo:eject --component Avo::Index::TableRowComponent
```
or

```bash
$ bin/rails generate avo:eject --component avo/index/table_row_component
```

Have the same output:
```bash
create  app/components/avo/index/table_row_component.rb
create  app/components/avo/index/table_row_component.html.erb
```
</Option>

<Option name="`--field-components`">

With `--field-components` option is easy to eject, one or multiple field components. Notice that without using the `--scope`, the ejected components will override the original components for that field everywhere on the project.

Check the `--scope` and the `components` field options for more details on how to override the components only on specific parts of the project.

```bash
$ rails g avo:eject --field-components text
      create  app/components/avo/fields/text_field
      create  app/components/avo/fields/text_field/edit_component.html.erb
      create  app/components/avo/fields/text_field/edit_component.rb
      create  app/components/avo/fields/text_field/index_component.html.erb
      create  app/components/avo/fields/text_field/index_component.rb
      create  app/components/avo/fields/text_field/show_component.html.erb
      create  app/components/avo/fields/text_field/show_component.rb
```

Let's say you want to override only the edit component of the `TextField`, that can be achieved with this simple command.

```bash
$ rails g avo:eject --field-components text --view edit
      create  app/components/avo/fields/text_field/edit_component.rb
      create  app/components/avo/fields/text_field/edit_component.html.erb
```

</Option>

<Option name="`--view`">

While utilizing the `--field-components` option, you can selectively extract a specific view using the `--view` parameter, as demonstrated in the example above. If this option is omitted, all components of the field will be ejected.

</Option>

<Option name="`--scope`">

When you opt to eject a view component that exists under `Avo::Views` or a field component under `Avo::Fields` namespace, for example the `Avo::Views::ResourceIndexComponent` or `Avo::Fields::TextField::ShowComponent` you can employ the `--scope` option to specify the namespace that should be adopted by the ejected component, extending from `Avo::Views` / `Avo::Fields`.

```bash
$ rails g avo:eject --component Avo::Views::ResourceIndexComponent --scope admins
      create  app/components/avo/views/admins/resource_index_component.rb
      create  app/components/avo/views/admins/resource_index_component.html.erb

$ rails g avo:eject --field-components text --view show --scope admins
      create  app/components/avo/fields/admins/text_field/show_component.rb
      create  app/components/avo/fields/admins/text_field/show_component.html.erb
```

The ejected file have the same code that original `Avo::Views::ResourceIndexComponent` or `Avo::Fields::TextField::ShowComponent` but you can notice that the class name and the directory has changed

```ruby
class Avo::Views::Admins::ResourceIndexComponent < Avo::ResourceComponent

class Avo::Fields::Admins::TextField::ShowComponent < Avo::Fields::ShowComponent
```

:::info Scopes transformation
`--scope users_admins` -> `Avo::Views::UsersAdmins::ResourceIndexComponent`<br>
`--scope users/admins` -> `Avo::Views::Users::Admins::ResourceIndexComponent`
:::
</Option>

<Option name="`--controller`">

You can eject any Avo controller using the `--controller` option. Once ejected, you'll be responsible for maintaining the ejected controller.

```bash
$ rails g avo:eject --controller application_controller
```

The most common use case is ejecting the `application_controller`. The ejected application controller serves as an extendable layer that inherits from `Avo::BaseApplicationController`, where the core logic resides. All your Avo controllers for a specific resource inherit from this extendable layer, allowing you to customize behavior that applies to all resources' controllers.

This approach provides a clean way to add custom functionality or override default behaviors without directly modifying Avo's base controllers.

</Option>

---

# Custom view types
By default, Avo displays all the configured view types on the view switcher. For example, if you have `map_view` and `grid_view` configured, both of them, along with the `table_view`, will be available on the view switcher.

However, there might be cases where you only want to make a specific view type available without removing the configurations for other view types. This can be achieved using the `view_types` class attribute on the resource. Note that when only one view type is available, the view switcher will not be displayed.

```ruby{3}
class Avo::Resources::City < Avo::BaseResource
  # ...
  self.view_types = :table
  #...
end
```

If you want to make multiple view types available, you can use an array. The icons on the view switcher will follow the order in which they are declared in the configuration.

```ruby{3}
class Avo::Resources::City < Avo::BaseResource
  # ...
  self.view_types = [:table, :grid]
  #...
end
```

You can also dynamically restrict the view types based on user roles, params, or other business logic. To do this, assign a block to the `view_types` attribute. Within the block, you'll have access to `resource`, `record`, `params`, `current_user`, and other default accessors provided by `ExecutionContext`.

```ruby{3-9}
class Avo::Resources::City < Avo::BaseResource
  # ...
  self.view_types = -> do
    if current_user.is_admin?
      [:table, :grid]
    else
      :table
    end
  end
  #...
end
```

---

# Menu editor

One common task you need to do is organize your sidebar resources into menus. You can easily do that using the menu editor in the initializer.

When you start with Avo, you'll get an auto-generated sidebar by default. That sidebar will contain all your resources, dashboards, and custom tools. To customize that menu, you have to add the `main_menu` key to your initializer.

```ruby{3-22}
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    section "Resources", icon: "heroicons/outline/academic-cap" do
      group "Academia" do
        resource :course
        resource :course_link
      end

      group "Blog", collapsable: true, collapsed: true do
        dashboard :dashy

        resource :post
        resource :comment
      end
    end

    section I18n.t('avo.other'), icon: "heroicons/outline/finger-print", collapsable: true, collapsed: true do
      link_to 'Avo HQ', path: 'https://avohq.io', target: :_blank
      link_to 'Jumpstart Rails', path: 'https://jumpstartrails.com/', target: :_blank
    end
  }
end
```

<Image src="/assets/img/menu-editor/main.jpg" width="250" height="448" alt="Avo main menu" />

For now, Avo supports editing only two menus, `main_menu` and `profile_menu`. However, that might change in the future by allowing you to write custom menus for other parts of your app.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    section I18n.t("avo.dashboards"), icon: "dashboards" do
      dashboard :dashy, visible: -> { true }
      dashboard :sales, visible: -> { true }

      group "All dashboards", visible: false do
        all_dashboards
      end
    end

    section "Resources", icon: "heroicons/outline/academic-cap" do
      group "Academia" do
        resource :course
        resource :course_link
      end

      group "Blog" do
        resource :posts
        resource :comments
      end

      group "Other" do
        resource :fish
      end
    end

    section "Tools", icon: "heroicons/outline/finger-print" do
      all_tools
    end

    group do
      link_to "Avo", path: "https://avohq.io"
      link_to "Google", path: "https://google.com", target: :_blank
    end
  }
  config.profile_menu = -> {
    link_to "Profile", path: "/profile", icon: "user-circle"
  }
end
```

## Menu item types

A few menu item types are supported `link_to`, `section`, `group`, `resource`, and `dashboard`. There are a few helpers too, like `all_resources`, `all_dashboards`, and `all_tools`.

<Option name="`link_to`">

`link_to` is the menu item that the user will probably interact with the most. It will generate a link on your menu. You can specify the `name`, `path` , and `target`.

```ruby
link_to "Google", path: "https://google.com", target: :_blank
```

<Image src="/assets/img/menu-editor/external-link.jpg" width="254" height="155" alt="Avo menu editor" />

When you add the `target: :_blank` option, a tiny external link icon will be displayed.

#### `link_to` options

#### `path`

This is the path of the item.
It may be ommited to make the API look like Rail's

```ruby
config.main_menu = -> {
  # These two are equivalent
  link_to "Home", path: main_app.root_path
  link_to "Home", main_app.root_path
}
```

##### `data`

You may add arbitraty `data` attributes to your link.

You can make a link execute a `put`, `post`, or `delete` request similar to how you use the `data-turbo-method` attribute.

```ruby
config.main_menu = -> {
  link_to "Sign out!", main_app.destroy_user_session_path, data: { turbo_method: :delete }
}
```

</Option>

<Option name="`render`">

The `render` method will render renderable objects like partials or View Components.

You can even pass `locals` to partials.
The partials follow the same pattern as the regular `render` method.

```ruby
render "avo/sidebar/items/custom_tool"
render "avo/sidebar/items/custom_tool", locals: { something: :here }
render Super::Dooper::Component.new(something: :here)
```

</Option>

<Option name="`resource`">

To make it a bit easier, you can use `resource` to quickly generate a link to one of your resources. For example, you can pass a short symbol name `:user` or the full name `Avo::Resources::User`.

```ruby
resource :posts
resource "Avo::Resources::Comments"
```

<Image src="/assets/img/menu-editor/resource.jpg" width="252" height="177" alt="Avo menu editor" />

You can also change the label for the `resource` items to something else.

```ruby
resource :posts, label: "News posts"
```

Additionally, you can pass the `params` option to the `resource` items to add query params to the link.

```ruby
resource :posts, params: { status: "published" }
resource :users, params: -> do
  decoded_filter = {"Avo::Filters::IsAdmin"=>["non_admins"]}

  { encoded_filters: Avo::Filters::BaseFilter.encode_filters(decoded_filter)}
end
```

</Option>

<Option name="`dashboard`">

Similar to `resource`, this is a helper to make it easier to reference a dashboard. You pass in the `id` or the `name` of the dashboard.

```ruby
dashboard :dashy
dashboard "Sales"
```

<Image src="/assets/img/menu-editor/dashboard.jpg" width="256" height="212" alt="Avo menu editor" />

You can also change the label for the `dashboard` items to something else.

```ruby
dashboard :dashy, label: "Dashy Dashboard"
```

</Option>

<Option name="`section`">

Sections are the big categories in which you can group your menu items. They take `name` and `icon` options.

```ruby
section "Resources", icon: "heroicons/outline/academic-cap" do
  resource :course
  resource :course_link
end
```

<Image src="/assets/img/menu-editor/section.jpg" width="255" height="207" alt="Avo menu editor" />

</Option>

<Option name="`group`">

Groups are smaller categories where you can bring together your items.

```ruby
group "Blog" do
  resource :posts
  resource :categories
  resource :comments
end
```

<Image src="/assets/img/menu-editor/group.jpg" width="252" height="205" alt="Avo menu editor" />

</Option>

<Option name="`all_resources`">

Renders all resources, except those explicitly excluded.

#### Arguments:
- `exclude`: *(Array, optional)* â€“ A list of resource names to be excluded.

#### Example:

```ruby
section "App", icon: "heroicons/outline/beaker" do
  group "Resources", icon: "resources" do
    all_resources exclude: [:users, :orders]
  end
end
```

In the example above, all resources will be rendered except `Avo::Resources::Users` and `Avo::Resources::Orders`.

</Option>

<Option name="`all_dashboards`">

Renders all dashboards, except those explicitly excluded.

#### Arguments:
- `exclude`: *(Array, optional)* â€“ A list of dashboard names to be excluded.

#### Example:

```ruby
section "App", icon: "heroicons/outline/beaker" do
  group "Dashboards", icon: "dashboards" do
    all_dashboards exclude: [:sales, :analytics]
  end
end
```

In this example, all dashboards will be rendered except `Avo::Resources::Sales` and `Avo::Resources::Analytics`.

</Option>

<Option name="`all_tools`">

Renders all tools.

```ruby
section "App", icon: "heroicons/outline/beaker" do
  group "All tools", icon: "tools" do
    all_tools
  end
end
```

</Option>

### `all_` helpers

```ruby
section "App", icon: "heroicons/outline/beaker" do
  group "Dashboards", icon: "dashboards" do
    all_dashboards
  end

  group "Resources", icon: "resources" do
    all_resources
  end

  group "All tools", icon: "tools" do
    all_tools
  end
end
```

:::warning
The `all_resources` helper is taking into account your authorization rules, so make sure you have `def index?` enabled in your resource policy.
:::

<Image src="/assets/img/menu-editor/all-helpers.jpg" width="254" height="732" alt="Avo menu editor" />

## Item visibility

The `visible` option is available on all menu items. It can be a boolean or a block that has access to a few things:

- the `current_user`. Given that you set a way for Avo to know who the current user is, that will be available in that block call
- the `context` object.
- the `params` object of that current request
- the [`view_context`](https://apidock.com/rails/AbstractController/Rendering/view_context) object. The `view_context` object lets you use the route helpers. eg: `view_context.main_app.posts_path`.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    resource :user, visible: -> do
      context[:something] == :something_else
    end
  }
end
```

## Add `data` attributes to items

<VersionReq version="2.16" />

You may want to add special data attributes to some items and you can do that using the `data` option. For example you may add `data: {turbo: false}` to make a regular request for a link.

```ruby{4}
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    resource :user, data: {turbo: false}
  }
end
```

## Using authorization rules

When you switch from a generated menu to a custom one, you might want to keep using the same authorization rules as before. To quickly do that, use the `authorize` method in the `visible` option.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = -> {
    resource :team, visible: -> do
      # authorize current_user, MODEL_THAT_NEEDS_TO_BE_AUTHORIZED, METHOD_THAT_NEEDS_TO_BE_AUTHORIZED
      authorize current_user, Team, "index?", raise_exception: false
    end
  }
end
```

## Icons

For [`Section`](#section)s, you can use icons to make them look better. You can use some local ones that we used throughout the app and all [heroicons](https://heroicons.com/) designed by [Steve Schoger](https://twitter.com/steveschoger). In addition, you can use the `solid` or `outline` versions. We used the `outline` version throughout the app.

```ruby
section "Resources", icon: "heroicons/outline/academic-cap" do
  resource :course
end

section "Resources", icon: "heroicons/solid/finger-print" do
  resource :course
end

section "Resources", icon: "heroicons/outline/adjustments" do
  resource :course
end
```

<Image src="/assets/img/menu-editor/icons.jpg" width="253" height="328" alt="Avo menu editor" />

### Icons on resource, dashboard, and link_to items

You can add icons to other menu items like `resource`, `dashboard`, and `link_to`.

```ruby
link_to "Avo", "https://avohq.io", icon: "globe"
```

## Collapsable sections and groups

When you have a lot of items they can take up a lot of vertical space. You can choose to make those sidebar sections collapsable by you or your users.

```ruby
section "Resources", icon: "resources", collapsable: true do
  resource :course
end
```

<Image src="/assets/img/menu-editor/collapsable.jpg" width="250" height="182" alt="Avo menu editor" />

That will add the arrow icon next to the section to indicate it's collapsable. So when your users collapse and expand it, their choice will be stored in Local Storage and remembered in that browser.

### Default collapsed state

You can however, set a default collapsed state using the `collapsed` option.

```ruby
section "Resources", icon: "resources", collapsable: true, collapsed: true do
  resource :course
end
```

<Image src="/assets/img/menu-editor/collapsed.jpg" width="250" height="182" alt="Avo menu editor" />

You might want to allow your users to hide certain items from view.

## Authorization

<DemoVideo demo-video="https://youtu.be/Eex8CiinQZ8?t=373" />

If you use the authorization feature, you will need an easy way to authorize your items in the menu builder.
For that scenario, we added the `authorize` helper.

```ruby{3}
Avo.configure do |config|
  config.main_menu = -> {
    resource :team, visible: -> {
      # authorize current_user, THE_RESOURCE_MODEL, THE_POLICY_METHOD, raise_exception: false
      authorize current_user, Team, "index?", raise_exception: false
    }
  }
end
```

Use it in the `visible` block by giving it the `current_user` (which is available in that block), the class of the resource, the method that you'd like to authorize for (default is `index?`), and tell it not to throw an exception.

Now, the item visibility will use the `index?` method from the `TeamPolicy` class.

## Profile menu

The profile menu allows you to add items to the menu displayed in the profile component. **The sign-out link is automatically added for you.**

You may add the `icon` option to the `profile_menu` links.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.profile_menu = -> {
    link_to "Profile", path: "/profile", icon: "user-circle"
  }
end
```

<Image src="/assets/img/menu-editor/profile-menu.png" width="276" height="192" alt="Avo profile menu" />

## Forms in profile menu

It's common to have forms that `POST` to a path to do sign ut a user. For this scenario we added the `method` and `params` option to the profile item `link_to`, so if you have a custom sign out path you can do things like this.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.profile_menu = -> {
    link_to "Sign out", path: main_app.destroy_user_session_path, icon: "user-circle", method: :post, params: {custom_param: :here}
  }
end
```

## Custom content in the profile menu

You might, however, want to add a very custom form or more items to the profile menu. For that we prepared the `_profile_menu_extra.html.erb` partial for you.

```bash
bin/rails generate avo:eject --partial :profile_menu_extra
```

This will eject the partial and you can add whatever custom content you might need.

```erb
<%# Example link below %>
<%#= render Avo::ProfileItemComponent.new label: 'Profile', path: '/profile', icon: 'user-circle' %>
```

---

# Search

Finding what you're looking for fast is essential. That's why Avo leverages [ransack's](https://github.com/activerecord-hackery/ransack) powerful query language.

:::info
While we show you examples using `ransack`, you can use other search engines, so `ransack` is not mandatory.
:::

First, you need to add `ransack` as a dependency to your app (breaking change from Avo v1.10).

```ruby
# Gemfile
gem 'ransack'
```

## Enable search for a resource

To enable search for a resource, you need to configure the `search` class attribute to the resource file.

```ruby{2-4}
class Avo::Resources::User < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_eq: params[:q]).result(distinct: false) }
  }
end
```

The `query` block passes over the `params` object that holds the `q` param, the actual query string. It also provides the `query` variable on which you run the query. That ensures that the authorization scopes have been appropriately applied.

In this block, you may configure the search however strict or loose you need it. Check out [ransack's search matchers](https://github.com/activerecord-hackery/ransack#search-matchers) to compose the query better.

:::warning
If you're using ransack version 4 and up you must add `ransackable_attributes` and maybe more to your model in order for it to work. Read more about it [here](https://activerecord-hackery.github.io/ransack/going-further/other-notes/#authorization-allowlistingdenylisting).
:::

### Custom search provider

<VersionReq version="3.10.8" />

You can use custom search providers like Elasticsearch.
In such cases, or when you want to have full control over the search results, the `query` block should return an array of hashes. Each hash should follow the structure below:

```ruby
{
  _id: 1,
  _label: "The label",
  _url: "The URL",
  _description: "Some description about the record", # only with Avo Pro and above
  _avatar: "URL to an image that represents the record", # only with Avo Pro and above
  _avatar_type: :rounded # or :circle or :square; only with Avo Pro and above
}
```

Example:

```ruby{2-10}
class Avo::Resources::Project < Avo::BaseResource
  self.search = {
    query: -> do
      [
        { _id: 1, _label: "Record One", _url: "https://example.com/1" },
        { _id: 2, _label: "Record Two", _url: "https://example.com/2" },
        { _id: 3, _label: "Record Three", _url: "https://example.com/3" }
      ]
    end
  }
end
```

:::warning
Results count will not be available with custom search providers.
:::

## Authorize search

Search is authorized in policy files using the `search?` method.

```ruby
class UserPolicy < ApplicationPolicy
  def search?
    true
  end
end
```

If the `search?` method returns false, the search operation for that resource is not going to show up in the global search and the search box on index is not going to be displayed.

If you're using `search?` already in your policy file, you can alias it to some other method in you initializer using the `config.authorization_methods` config. More about that on the authorization page.

```ruby
Avo.configure do |config|
  config.authorization_methods = {
    search: 'avo_search?',
  }
  end
```

## Configure the search result

<Option name="`title`">

By default, the search results will be displayed as text. By default search title will be the resource title.

<Image src="/assets/img/search/search_blank.jpg" width="1412" height="686" alt="Blank search" />

You may configure that to be something more complex using the `item -> title` option. That will display it as the title of the search result.

```ruby{6}
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_cont: params[:q], m: "or").result(distinct: false) },
    item: -> do
      {
        title: "[#{record.id}]#{record.name}",
      }
    end
  }
end
```

<Image src="/assets/img/search/search_label.jpg" width="1406" height="674" alt="Search label" />
</Option>

<Option name="`description`">

<LicenseReq license="pro" />

You might want to show more than just the title in the search result. Avo provides the `item -> description` option to add some more information.

```ruby{7}
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_cont: params[:q], m: "or").result(distinct: false) },
    item:  -> do
      {
        title: "[#{record.id}]#{record.name}",
        description: record.truncated_body
      }
    end
  }
end
```

<Image src="/assets/img/search/search_description.jpg" width="1396" height="754" alt="Search description" />
</Option>

<Option name="`image_url`">

<LicenseReq license="pro" />

You may improve the results listing by adding an image to each search result. You do that by using the `item -> image_url` attribute that is an url to a image.

```ruby{8}
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_cont: params[:q], m: "or").result(distinct: false) },
    item: -> do
      {
        title: "[#{record.id}]#{record.name}",
        description: ActionView::Base.full_sanitizer.sanitize(record.body).truncate(130),
        image_url: main_app.url_for(record.cover_photo),
      }
    end
  }
end
```

</Option>

<Option name="`image_format`">

<LicenseReq license="pro" />

The image you add to a search result can have a different format based on what you set on the `item -> image_format` attribute. You may choose between three options: `:square`, `:rounded` or `:circle`.

```ruby{9}
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_cont: params[:q], m: "or").result(distinct: false) },
    item: -> do
      {
        title: "[#{record.id}]#{record.name}",
        description: ActionView::Base.full_sanitizer.sanitize(record.body).truncate(130),
        image_url: main_app.url_for(record.cover_photo),
        image_format: :rounded
      }
    end
  }
end
```

<Image src="/assets/img/search/search_avatar.jpg" width="1400" height="794" alt="Search avatar" />
</Option>

<Option name="`help`">

You may improve the results listing header by adding a piece of text highlighting the fields you are looking for or any other instruction for the user. You do that by using the `help` attribute. This attribute takes a string and appends it to the title of the resource.

<Image src="/assets/img/search/search_header_help.jpg" width="1620" height="538" alt="Search Header Help" />

```ruby{4}
class Avo::Resources::Post < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(id_eq: params[:q], m: "or").result(distinct: false) },
    help: -> { "- search by id" }
  }
end
```
</Option>

<Option name="`result_path`">

By default, when a user clicks on a search result, they will be redirected to that record, but you can change that using the `result_path` option.

```ruby
class Avo::Resources::City < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(name_eq: params[:q]).result(distinct: false) },
    result_path: -> { avo.resources_city_path record, custom: "yup" }
  }
end
```
</Option>

<Option name="`hide_on_global`">

You might have a resource that you'd like to be able to perform a search on when on its `Index` page but not have it present in the global search. You can hide it using `hide_on_global: true`.

```ruby{9}
class Avo::Resources::TeamMembership < Avo::BaseResource
  self.search = {
    query: -> { query.ransack(id_eq: params[:q], m: "or").result(distinct: false) },
    item: -> do
      {
        description: record.level,
      }
    end,
    hide_on_global: true
  }
end
```
</Option>

## Resource search

When a resource has the `search` attribute with a valid configuration, a new search input will be displayed on the `Index` view.

<Image src="/assets/img/search/resource_search.jpg" width="808" height="395" alt="" />

## Global search

<LicenseReq license="pro" />

Avo also has a global search feature. It will search through all the resources that have the `search` attribute with a valid configuration.

You open the global search input by clicking the trigger on the navbar or by using the <kbd>CMD</kbd> + <kbd>K</kbd> keyboard shortcut (<kbd>Ctrl</kbd> + <kbd>K</kbd> on Windows).

<Image src="/assets/img/search/global_search_trigger.jpg" width="960" height="76" alt="Global search trigger" />

### Hide the global search

If you, by any chance, want to hide the global search, you can do so using this setting ðŸ‘‡

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.disabled_features = [:global_search]
end
```

Since version <Version version="3.13.5" /> `disabled_features` become callable. Within this block, you gain access to all attributes of `Avo::ExecutionContext`

```ruby{3}
# config/initializers/avo.rb
Avo.configure do |config|
  config.disabled_features = -> { current_user.is_admin? ? [] : [:global_search] }
end
```

### Scope out global or resource searches

You may want to perform different searches on the `global` search from the `resource` search. You may use the `params[:global]` flag to figure that out.

```ruby
class Avo::Resources::Order < Avo::BaseResource
  self.search = {
    query: -> {
      if params[:global]
        # Perform global search
        query.ransack(id_eq: params[:q], m: "or").result(distinct: false)
      else
        # Perform resource search
        query.ransack(id_eq: params[:q], details_cont: params[:q], m: "or").result(distinct: false)
      end
    }
  }
end
```

## Searching within associations

In some cases, you might need to search for records based on attributes of associated models. This can be achieved by adding a few things to the search query. Here's an example of how to do that:

Assuming you have two models, `Application` and `Client`, with the following associations:

```ruby{3,8}
# app/models/application.rb
class Application < ApplicationRecord
  belongs_to :client
end

# app/models/client.rb
class Client < ApplicationRecord
  has_many :applications
end
```

You can perform a search on `Application` records based on attributes of the associated `Client`. For example, searching by the client's email, name, or phone number:

```ruby{6,11-15}
# app/avo/resources/application.rb
class Avo::Resources::Application < Avo::BaseResource
  self.search = {
    query: -> {
      query
        .joins(:client)
        .ransack(
          id_eq: params[:q],
          name_cont: params[:q],
          workflow_name_cont: params[:q],
          client_id_eq: params[:q],
          client_first_name_cont: params[:q],
          client_last_name_cont: params[:q],
          client_email_cont: params[:q],
          client_phone_number_cont: params[:q],
          m: 'or'
        ).result(distinct: false)
    }
  }
end
```

In the above example, ransack is used to search for `Application` records based on various attributes of the associated `Client`, such as `client_email_cont` and `client_phone_number_cont`. The joins method is used to join the applications table with the clients table to perform the search efficiently.

This approach allows for flexible searching within associations, enabling you to find records based on related model attributes.

## Results count

<VersionReq version="3.11" />

By default, Avo displays 8 search results whenever you search. You can change the number of results displayed by configuring the `search_results_count` option:

```ruby
Avo.configure do |config|
  config.search_results_count = 16
end
```

You can also change the number of results displayed on individual resources:

```ruby{3}
class Avo::Resources::User < Avo::BaseResource
  self.search = {
    results_count: 5
    query: -> {},
  }
end
```

You can also assign a lambda to dynamically set the value.

```ruby{3}
class Avo::Resources::User < Avo::BaseResource
  self.search = {
    results_count: -> { user.admin? ? 30 : 10 }
  }
end
```

If you configure `results_count` by specifying it in the resource file then that number takes precedence over the global [`search_results_count`](#results-count) for that resource.

---

# Localization (i18n)

Avo leverages Rails' powerful `I18n` translations module.

:::warning Multi-language URL Support
If you're serving Avo using multiple languages and you're using the locale in your routes (`/en/resources/users`, `/de/resources/users`), check out this guide.
:::

When you run `bin/rails avo:install`, Rails will not generate for you the `avo.en.yml` translation file. This file is already loaded will automatically be injected into the I18n translations module.

## Localizing resources

Let's say you want to localize a resource. All you need to do is add a `self.translation_key` class attribute in the `Resource` file. That will tell Avo to use that translation key to localize this resource. That will change the labels of that resource everywhere in Avo.

```ruby{4}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  self.title = :name
  self.translation_key = 'avo.resource_translations.user'
end
```

```yaml{6-10}
# avo.es.yml
es:
  avo:
    dashboard: 'Dashboard'
    # ... other translation keys
    resource_translations:
      user:
        zero: 'usuarios'
        one: 'usuario'
        other: 'usuarios'
```

## Localizing fields

Similarly, you can even localize fields. All you need to do is add a `translation_key:` option on the field declaration.

```ruby{8}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id
    # ... other fields
    field :files, as: :files, translation_key: 'avo.field_translations.file'
  end
end
```

```yaml{6-10}
# avo.es.yml
es:
  avo:
    dashboard: 'Dashboard'
    # ... other translation keys
    field_translations:
      file:
        zero: 'archivos'
        one: 'archivo'
        other: 'archivos'
```

## Localizing buttons label

<BetaStatus label="Beta" />

The `avo.save` configuration applies to all save buttons. If you wish to customize the localization for a specific resource, such as `Avo::Resources::Product`, you can achieve this by:

```yml
---
en:
  avo:
    resource_translations:
      product:
        save: "Save the product!"
```

## Setting the locale

Setting the locale for Avo is pretty simple. Just use the `config.locale = :en` config attribute. Default is `nil` and will fall back to whatever you have configured in as `config.i18n.default_locale` in `application.rb`.

```ruby{2}
Avo.configure do |config|
  config.locale = :en # default is nil
end
```

That will change the locale only for Avo requests. The rest of your app will still use your locale set in `application.rb`. If you wish to change the locale for Avo, you can use the `set_locale=pt-BR` param. That will set the default locale for Avo until you restart your server.

Suppose you wish to change the locale only for one request using the `force_locale=pt-BR` param. That will set the locale for that request and keep the `force_locale` param in all links while you navigate Avo. Remove that param when you want to go back to your configured `default_locale`.

Related:
- Check out our guide for multilingual records.

## Customize the locale

If there's anything in the locale files that you would like to change, run `bin/rails generate avo:locales` to generate the locale files.

These provide a guide for you for when you want to add more languages.

If you do translate Avo in a new language please consider contributing it to the [main repo](https://github.com/avo-hq/avo). Thank you

## FAQ

If you try to localize your resources and fields and it doesn't seem to work, please be aware of the following.

### The I18n.t method defaults to the name of that field/resource

Internally the localization works like so `I18n.t(translation_key, count: 1, default: default)` where the `default` is the computed field/resource name. So check the structure of your translation keys.

```yaml
# config/locales/avo.pt-BR.yml
pt-BR:
  avo:
    field_translations:
      file:
        zero: 'arquivos'
        one: 'arquivo'
        other: 'arquivos'
    resource_translations:
      user:
        zero: 'usuÃ¡rios'
        one: 'usuÃ¡rio'
        other: 'usuÃ¡rios'
```

### Using a Route Scope for Localization

To implement a route scope for localization within Avo, refer to this guide. It provides step-by-step instructions on configuring your routes to include a locale scope, enabling seamless localization handling across your application.

---

# Branding

```ruby
Avo.configure do |config|
  config.branding = {
    colors: {
      background: "248 246 242",
      100 => "#C5F1D4",
      400 => "#3CD070",
      500 => "#30A65A",
      600 => "#247D43",
    },
    chart_colors: ['#FFB435', "#FFA102", "#CC8102", '#FFB435', "#FFA102", "#CC8102"],
    logo: "/avo-assets/logo.png",
    logomark: "/avo-assets/logomark.png",
    placeholder: "/avo-assets/placeholder.svg",
    favicon: "/avo-assets/favicon.ico"
  }
end
```

Using the branding feature, you can easily change the look of your app. You tweak it inside your `avo.rb` initializer in the `branding` attribute. It takes a hash with a few properties.

## Configure brand color

To customize the primary color of Avo, you must configure the `colors` key with four color variants. `100` for color hints, `500` for the base primary color, and `400` and `600` values for highlights.

```ruby{4-8}
Avo.configure do |config|
  config.branding = {
    colors: {
      background: "248 246 242",
      100 => "#C5F1D4",
      400 => "#3CD070",
      500 => "#30A65A",
      600 => "#247D43",
    }
  }
end
```

You may also customize the color of Avo's background using the `background` key.

<Image src="/assets/img/branding/green.jpg" width="2560" height="1280" alt="" />

<Image src="/assets/img/branding/red.jpg" width="2560" height="1280" alt="" />

<Image src="/assets/img/branding/orange.jpg" width="2560" height="1280" alt="" />

:::info
The color format can be hex (starting with `#`) or rgb (three groups split by a space, not a comma).
:::

Avo uses [Tailwinds color system](https://tailwindcss.com/docs/customizing-colors). You can generate your own using the tools below.

 - [Palettte](https://palettte.app/)
 - [ColorBox](https://colorbox.io/)
 - [TailwindInk](https://tailwind.ink/)

Here are a few for you to choose from.

```ruby
config.branding = {
  colors: {
    # BLUE
    100 => "#CEE7F8",
    400 => "#399EE5",
    500 => "#0886DE",
    600 => "#066BB2",
    # RED
    100 => "#FACDD4",
    400 => "#F06A7D",
    500 => "#EB3851",
    600 => "#E60626",
    # GREEN
    100 => "#C5F1D4",
    400 => "#3CD070",
    500 => "#30A65A",
    600 => "#247D43",
    # ORANGE
    100 => "#FFECCC",
    400 => "#FFB435",
    500 => "#FFA102",
    600 => "#CC8102",
  }
}
```

## Customize the chart colors

For your dashboard, you can further customize the colors of the charts. You can do that using the `chart_colors` option. Pass in an array of colors, and Avo will do the rest.

```ruby
Avo.configure do |config|
  config.branding = {
    chart_colors: ['#FFB435', "#FFA102", "#CC8102", '#FFB435', "#FFA102", "#CC8102"],
  }
end
```

<Image src="/assets/img/branding/chart-colors.jpg" width="2236" height="1588" alt="" />

:::warning
The chart colors should be hex colors. They are forwarded to chart.js
:::

## Customize the logo

We want to make it easy to change the logo for your app, so we added the `logo` and `logomark` options to the branding feature.

The `logo` should be the "big" logo you want to display on the desktop version of your app, and `logomark` should be a squared-aspect image that Avo displays on the mobile version.

<Image src="/assets/img/branding/logomark.gif" width="800" height="572" alt="" />

## Customize the missing image placeholder

When you view the data in the <Index /> view in a grid, when the `cover` field does not have an image, an avocado is going to be displayed instead as a placeholder.

You might want to change that to something else using the `placeholder` option.

```ruby
Avo.configure do |config|
  config.branding = {
    placeholder: "/YOUR_PLACEHOLDER_IMAGE.jpg",
  }
end
```

## Customize the favicon

We want to make it easy to change the logo for your app, so we added the `favicon` option to the branding feature.
Overwrite it using an `.ico` file.

---

# Routing

We stick to Rails defaults in terms of routing just to make working with Avo as straightforward as possible.

Avo's functionality is distributed across multiple gems, each encapsulating its own engine. By default, these engines are mounted under Avo's scope within your Rails application.

Each engine registers itself with Avo.

### Default Mounting Behavior

When the `mount_avo` method is invoked, Avo and all the associated engines are mounted at a common entry point. By default, this mounting point corresponds to `Avo.configuration.root_path`, but you can customize it using the `at` argument:

```ruby{4,7}
# config/routes.rb
Rails.application.routes.draw do
  # Mounts Avo at Avo.configuration.root_path
  mount_avo

  # Mounts Avo at `/custom_path` instead of the default
  mount_avo at: "custom_path"
end
```

If no custom path is specified, Avo is mounted at the default configuration root path.

## Mount Avo under a scope

In this example, we'll demonstrate how to add a `:locale` scope to your routes.

The `:locale` scope is just an example. If your objective is to implement a route scope for localization within Avo, there's a detailed recipe available. Check out this guide for comprehensive instructions.

```ruby{4-6}
# config/routes.rb

Rails.application.routes.draw do
  scope ":locale" do
    mount_avo
  end
end
```

:::info
To guarantee that the `locale` scope is included in the `default_url_options`, you must explicitly add it to the Avo configuration.

Check this documentation section for details on how to configure `default_url_options` setting.
:::

## Add your own routes

You may want to add your own routes inside Avo so you can access different custom actions that you might have set in the Avo resource controllers.

You can do that in your app's `routes.rb` file by opening up the Avo routes block and append your own.

```ruby
# routes.rb
Rails.application.routes.draw do
  mount_avo

  # your other app routes
end

if defined? ::Avo
  Avo::Engine.routes.draw do
    # new route in new controller
    put "switch_accounts/:id", to: "switch_accounts#update", as: :switch_account

    scope :resources do
      # append a route to a resource controller
      get "courses/cities", to: "courses#cities"
    end
  end
end

# app/controllers/avo/switch_accounts_controller.rb
class Avo::SwitchAccountsController < Avo::ApplicationController
  def update
    session[:tenant_id] = params[:id]

    redirect_back fallback_location: root_path
  end
end
```

---

# Multitenancy

Multitenancy is a very talked-about subject. We're not going to go very deep into how to achieve it on the database level, but will talk a little bit about how it's supported in Avo.

## Breakdown

Usually, with multitenancy you add a new layer just one level below authentication. You don't have just a user to think about, but now that user might act on the behalf of a tenant. That tenant can be an `Account` or a `Team`, or any other model you design in your database.

So now, the mission is to pinpoint which tenant is the user acting for. Because Avo has such an integrated experience and we use our own `ApplicationController`, you might think it's difficult to add that layer, when in fact it's really not. There are a couple of steps to do.

:::info
We'll use the `foo` tenant id from now on.
:::

## Route-based tenancy

There are a couple of strategies here, but the a common one is to use route-based tenancy. That means that your user uses a URL like `https://example.com/foo/` and the app should know to scope everything to that `foo` tenant.

We need to do a few things:

#### 1. Set the proper routing pattern

Mount Avo under the `tenant_id` scope

```ruby
# config/routes.rb
Rails.application.routes.draw do
  scope "/:tenant_id" do
    mount_avo
  end
end
```

#### 2. Set the tenant for each request

:::code-group
```ruby [config/initializers/avo.rb]{6}
Avo.configure do |config|
  # configuration values
end

Rails.configuration.to_prepare do
  Avo::ApplicationController.include Multitenancy
end
```
```ruby [app/controllers/concerns/multitenancy.rb]
module Multitenancy
  extend ActiveSupport::Concern

  included do
    prepend_before_action :set_tenant
  end

  def set_tenant
    Avo::Current.tenant_id = params[:tenant_id]
    Avo::Current.tenant = Account.find params[:tenant_id]
  end
end
```
:::

Now, whenever you navigate to `https://example.com/lol` the tenant the `tenant_id` will be set to `lol`.

## Session-based tenancy

Using a session-based tenancy strategy is a bit simpler as we don't meddle with the routing.

:::warning
The code below shows how it's possible to do session-based multitenancy but your use-case or model names may vary a bit.
:::

We need to do a few things:

#### 1. Set the tenant for each request
:::code-group
```ruby [config/initializers/avo.rb]{6}
Avo.configure do |config|
  # configuration values
end

Rails.configuration.to_prepare do
  Avo::ApplicationController.include Multitenancy
end
```
```ruby [app/controllers/concerns/multitenancy.rb]
module Multitenancy
  extend ActiveSupport::Concern

  included do
    prepend_before_action :set_tenant
  end

  def set_tenant
    Avo::Current.tenant = Account.find session[:tenant_id] || current_user.accounts.first
  end
end
```
:::

#### 2. Add an account switcher

Somewhere in a view on a navbar or sidebar add an account switcher.

:::code-group
```erb [app/views/avo/session_switcher.html.erb]
<% current_user.accounts.each do |account| %>
  <%= link_to account.name, switch_account_path(account.id), class: class_names({"underline": session[:tenant_id].to_s == account.id.to_s}), data: {turbo_method: :put} %>
<% end %>
```

```ruby [app/controllers/avo/switch_accounts_controller.rb]
class Avo::SwitchAccountsController < Avo::ApplicationController
  def update
    # set the new tenant in session
    session[:tenant_id] = params[:id]

    redirect_back fallback_location: root_path
  end
end
```
:::

---

# Actions Overview

<DemoVideo demo-video="https://youtu.be/BK47E7TMXn0?t=778" class="mt-4" />

Actions in Avo are powerful tools that transform the way you interact with your data. They enable you to perform operations on one or multiple records simultaneously, extending your interface with custom functionality that goes beyond basic CRUD operations.

## What Are Actions?

Think of Actions as custom operations you can trigger from your admin interface. They're like specialized commands that can:
- Process single records or work in batch mode
- Collect additional information through customizable forms
- Trigger background jobs
- Generate reports or export data
- Modify record states
- Send notifications
- And much more...

## Key Benefits

### 1. Streamlined Workflows
Instead of building custom interfaces for common operations, Actions provide a standardized way to perform complex tasks right from your admin panel.

### 2. Flexibility
Actions can be as simple or as complex as you need:
- Simple toggles for changing record states
- Multi-step processes with user input on each step
- Background job triggers for heavy operations
- API integrations with external services

### 3. Batch Operations
Save time by performing operations on multiple records at once. Whether you're updating statuses, sending notifications, or processing data, batch actions have you covered.

### 4. User Input Forms
When additional information is needed, Actions can present custom forms to collect data before execution. These forms are fully customizable and support various field types.

## Common Use Cases

- **User Management**: Activate/deactivate accounts, reset passwords, or send welcome emails
- **Content Moderation**: Approve/reject content, flag items for review
- **Data Processing**: Generate reports, export data, or trigger data transformations
- **Communication**: Send notifications, emails, or SMS messages
- **State Management**: Change status, toggle features, or update permissions
- **Batch Updates**: Modify multiple records with consistent changes
- **Integration Triggers**: Connect with external APIs or services

Common use cases include managing user states, sending notifications, and automating data processing. Their flexibility makes them essential for building robust interfaces, streamlining workflows, and managing data efficiently.

---

# Action Generator

Avo provides a powerful Rails generator to create action files quickly and efficiently.

## Basic Generator Usage

Generate a new action file using the Rails generator:

```bash
bin/rails generate avo:action toggle_inactive
```

This command creates a new action file at `app/avo/actions/toggle_inactive.rb` with the following structure:

```ruby
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  self.name = "Toggle Inactive"
  # self.visible = -> do
  #   true
  # end

  # def fields
  #   # Add Action fields here
  # end

  def handle(query:, fields:, current_user:, resource:, **args)
    query.each do |record|
      # Do something with your records.
    end
  end
end
```

## Generator Options

### `--standalone`

By default, actions require at least one record to be selected before they can be triggered, unless specifically configured as standalone actions.

The `--standalone` option creates an action that doesn't require record selection. This is particularly useful for:
- Generating reports
- Exporting all records
- Running global operations

```bash
bin/rails generate avo:action export_users --standalone
```

You can also make an existing action standalone by manually setting `self.standalone = true` in the action class:

```ruby{5}
# app/avo/actions/export_users.rb

class Avo::Actions::ExportUsers < Avo::BaseAction
  self.name = "Export Users"
  self.standalone = true

  # ... rest of the action code
end
```

## Best Practices

When generating actions, consider the following:

1. Use descriptive names that reflect the action's purpose (e.g., `toggle_published`, `send_newsletter`, `archive_records`)
2. Follow Ruby naming conventions (snake_case for file names)
3. Group related actions in namespaces using subdirectories
4. Use the `--standalone` flag when the action doesn't operate on specific records

## Examples

```bash
# Generate a regular action
bin/rails generate avo:action mark_as_featured

# Generate a standalone action
bin/rails generate avo:action generate_monthly_report --standalone

# Generate an action in a namespace
bin/rails generate avo:action admin/approve_user
```

---

# Registration

Actions are registered within a resource by using the resource's `actions` method. This method defines which actions are available for that specific resource.

## `action`

The `action` method is used to register an action within the `actions` block. It accepts the action class as its first argument and optional configuration parameters like `arguments` and `icon`

```ruby{5}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def actions
    # Basic registration
    action Avo::Actions::ToggleInactive
  end
end
```

:::warning
Using the Pundit policies, you can restrict access to actions using the `act_on?` method. If you think you should see an action on a resource and you don't, please check the policy method.

More info here
:::

Once attached, the action will appear in the **Actions** dropdown menu. By default, actions are available on all views.

:::info
You may use the customizable controls feature to show the actions outside the dropdown.
:::

<Option name="`arguments`" headingSize="3">

The `arguments` option allows you to pass custom data to your action. These arguments are accessible throughout the entire action class including the `handle` and `fields` methods.

```ruby{5-7,11-15}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def actions
    action Avo::Actions::ToggleInactive,
      arguments: {
        special_message: true
      }

    # Or as a proc to make it dynamic
    action Avo::Actions::ToggleInactive,
      arguments: -> do
        {
          special_message: resource.view.index? && current_user.is_admin?
        }
      end
  end
end
```

Now, the arguments can be accessed all over the action class like inside `handle` and `fields` methods.

```ruby{4-8}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  def handle(**args)
    if arguments[:special_message]
      succeed "I love ðŸ¥‘"
    else
      succeed "Success response âœŒï¸"
    end
  end
end
```
</Option>

<Option name="`icon`" headingSize="3">

<VersionReq version="3.5.6" class="mt-4" />

The `icon` option lets you specify the icon to display next to the action in the dropdown menu. Avo supports [Heroicons](https://heroicons.com) by default.

Here's an example of how you can define actions with icons:

```ruby{4}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def actions
    action Avo::Actions::ToggleInactive, icon: "heroicons/outline/globe"
  end
end
```

</Option>

---

## `divider`

<VersionReq version="3.5.6" class="mt-4" />

Action dividers allow you to organize and separate actions into logical groups, improving the overall layout and usability.
This will create a visual separator in the actions dropdown menu, helping you group related actions together.

```ruby{8}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def actions
    # User status actions
    action Avo::Actions::ActivateUser
    action Avo::Actions::DeactivateUser

    divider

    # Communication actions
    action Avo::Actions::SendWelcomeEmail
    action Avo::Actions::SendPasswordReset
  end
end
```

<Option name="`label`" headingSize="3">

You can also add a label to the divider for better organization:

```ruby{5}
# app/avo/resources/user.rb
class Avo::Resources::User < Avo::BaseResource
  def actions
    action Avo::Actions::ActivateUser
    divider label: "Communication"
    action Avo::Actions::SendWelcomeEmail
  end
end
```

</Option>

---

# Execution flow

When a user triggers an action in Avo, the following flow occurs:

1. Record selection phase:
   - This phase can be bypassed by setting `self.standalone = true`
   - For bulk actions on the index page, Avo collects all the records selected by the user
   - For actions on the show page or row controls, Avo uses that record as the target of the action

2. The action is initiated by the user through the index page (bulk actions), show page (single record actions), or resource controls (custom action buttons)

3. Form display phase (optional):
    - This phase can be bypassed by setting `self.no_confirmation = true`
    - By default, a modal is displayed where the user can confirm or cancel the action
    - If the action has defined fields, they will be shown in the modal for the user to fill out
    - The user can then choose to run the action or cancel it
    - If the user cancels, the execution stops here

4. Action execution:
    - The `handle` method processes selected records, form values, current user, and resource details
    - Your custom business logic is executed within the `handle` method
    - User feedback is configured ([`succeed`](#succeed), [`warn`](#warn), [`inform`](#inform), [`error`](#error), or [`silent`](#silent))
    - Response type is configured ([`redirect_to`](#redirect_to), [`reload`](#reload), [`keep_modal_open`](#keep_modal_open), and [more](#response-types))

## The `handle` method

The `handle` method is where you define what happens when your action is executed. This is the core of your action's business logic and receives the following arguments:

- `query` Contains the selected record(s). Single records are automatically wrapped in an array for consistency
- `fields` Contains the values submitted through the action's form fields
- `current_user` The currently authenticated user
- `resource` The Avo resource instance that triggered the action

```ruby{10-23}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  self.name = "Toggle Inactive"

  def fields
    field :notify_user, as: :boolean
    field :message, as: :textarea
  end

  def handle(query:, fields:, current_user:, resource:, **args)
    query.each do |record|
      # Toggle the inactive status
      record.update!(inactive: !record.inactive)

      # Send notification if requested
      if fields[:notify_user]
        # Assuming there's a notify method
        record.notify(fields[:message])
      end
    end

    succeed "Successfully toggled status for #{query.count}"
  end
end
```

## Feedback notifications

After an action runs, you can respond to the user with different types of notifications or no feedback at all. The default feedback is an `Action ran successfully` message of type `inform`.

All feedback notification methods (`succeed`, `warn`, `inform`, `error`) support an optional `timeout` parameter to control how long the notification remains visible:

```ruby
# Display notification for 5 seconds
succeed 'Task completed successfully', timeout: 5000

# Keep notification open indefinitely, until the user dismisses it
warn 'Important warning - requires attention', timeout: :forever

# Use default timeout (falls back to global configuration)
inform 'Action completed'
```

:::info
Set the `timeout` to `:forever` to keep the notification open indefinitely until the user dismisses it.

The default timeout is set to `config.alert_dismiss_time` in the Avo configuration.
:::

<Option name="`succeed`" headingSize="3">

Displays a **green** success alert to indicate successful completion.
</Option>

<Option name="`warn`" headingSize="3">

Displays an **orange** warning alert for cautionary messages.
</Option>

<Option name="`inform`" headingSize="3">

Displays a **blue** info alert for general information.
</Option>

<Option name="`error`" headingSize="3">

Displays a **red** error alert to indicate failure or errors.
</Option>

<Option name="`silent`" headingSize="3">

You may want to run an action and show no notification when it's done. That is useful for redirect scenarios. You can use the `silent` response for that.

```ruby{5}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  def handle(**args)
    redirect_to "/admin/some-tool"
    silent
  end
end
```
</Option>

:::info
You can show multiple notifications at once by calling multiple feedback methods (`succeed`, `warn`, `inform`, `error`) in your action's `handle` method. Each notification will be displayed in sequence.
:::

```ruby{4-7}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  def handle(**args)
    succeed "Success response âœŒï¸"
    warn "Warning response âœŒï¸"
    inform "Info response âœŒï¸"
    error "Error response âœŒï¸"
  end
end
```

<Image src="/assets/img/actions/alert-responses.png" width="1074" height="558" alt="Avo notification types" />

## Response types

After an action completes, you can control how the UI responds through various response types. These powerful responses give you fine-grained control over the user experience by allowing you to:

- **Navigate**: Reload pages or redirect users to different parts of your application
- **Manipulate UI**: Control modals, update specific page elements, or refresh table rows
- **Handle Files**: Trigger file downloads and handle data exports
- **Show Feedback**: Combine with notification messages for clear user communication

You can use these responses individually or combine them to create sophisticated interaction flows. Here are all the available action responses:

<Option name="`reload`" headingSize=3>

The `reload` response triggers a full-page reload. This is the default behavior if no other response type is specified.

```ruby{9}
def handle(query:, **args)
  query.each do |project|
    project.update active: false
  end

  succeed 'Done!'
  reload # This is optional since reload is the default behavior
end
```
</Option>

<Option name="`redirect_to`" headingSize=3>

`redirect_to` will execute a redirect to a new path of your app. It accept `allow_other_host`, `status` and any other arguments.

Example:
`redirect_to path, allow_other_host: true, status: 303`

```ruby{9}
def handle(query:, **args)
  query.each do |project|
    project.update active: false
  end

  succeed 'Done!'
  redirect_to avo.resources_users_path
end
```
</Option>

<Option name="`download`" headingSize=3>

`download` will start a file download to your specified `path` and `filename`.

:::warning
**Ignore this warning if you are using Avo 3.2.2 or later.**

You need to set `self.may_download_file` to true for the download response to work like below.
:::

:::code-group

```ruby{3-4,17} [app/avo/actions/download_file.rb]
class Avo::Actions::DownloadFile < Avo::BaseAction
  self.name = "Download file"
  # Only required for versions before 3.2.2
  self.may_download_file = true

def handle(query:, **args)
    filename = "projects.csv"
    report_data = []

    query.each do |project|
      report_data << project.generate_report_data
    end

    succeed 'Done!'

    if report_data.present? and filename.present?
      download report_data, filename
    end
  end
end
```

```ruby{8} [app/avo/resources/project.rb]
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  def fields
    # fields here
  end

  def actions
    action Avo::Actions::DownloadFile
  end
end
```
:::
</Option>

<Option name="`keep_modal_open`" headingSize=3>

There might be situations where you want to run an action and if it fails, respond back to the user with some feedback but still keep it open with the inputs filled in.

`keep_modal_open` will tell Avo to keep the modal open.

```ruby
class Avo::Actions::KeepModalOpenAction < Avo::BaseAction
  self.name = "Keep Modal Open"
  self.standalone = true

  def fields
    field :name, as: :text
    field :birthday, as: :date
  end

  def handle(fields:, **args)
    User.create fields
    succeed "All good âœŒï¸"
  rescue => error
    error "Something happened: #{error.message}"
    keep_modal_open
  end
end
```
</Option>

<Option name="`close_modal`" headingSize=3>

<VersionReq version="3.3.0" class="mt-4" />

This type of response becomes useful when you are working with a form and need to execute an action without redirecting, ensuring that the form remains filled as it is.

`close_modal` will flash all the messages gathered by [action responses](#action-responses) and will close the modal using turbo streams keeping the page still.

```ruby{7,9}
class Avo::Actions::CloseModal < Avo::BaseAction
  self.name = "Close modal"

  def handle(**args)
    # do_something_here
    succeed "Modal closed!!"
    close_modal
    # or
    do_nothing
  end
end
```
</Option>

<Option name="`do_nothing`" headingSize=3>

`do_nothing` is an alias for `close_modal`.

```ruby{7}
class Avo::Actions::CloseModal < Avo::BaseAction
  self.name = "Close modal"

  def handle(**args)
    # do_something_here
    succeed "Modal closed!!"
    do_nothing
  end
end
```
</Option>

<Option name="`navigate_to_action`" headingSize=3>

<VersionReq version="3.4.2" class="mt-4" />

You may want to redirect to another action. Here's an example of how to create a multi-step process, passing arguments from one action to another.
In this example the initial action prompts the user to select the fields they wish to update, and in the subsequent action, the chosen fields will be accessible for updating.

:::code-group
```ruby[PreUpdate]
class Avo::Actions::City::PreUpdate < Avo::BaseAction
  self.name = "Update"

  def fields
    field :name, as: :boolean
    field :population, as: :boolean
  end

  def handle(query:, fields:, **args)
    navigate_to_action Avo::Actions::City::Update,
      arguments: {
        cities: query.map(&:id),
        render_name: fields[:name],
        render_population: fields[:population]
      }
  end
end
```

```ruby[Update]
class Avo::Actions::City::Update < Avo::BaseAction
  self.name = "Update"
  self.visible = -> { false }

  def fields
    field :name, as: :text if arguments[:render_name]
    field :population, as: :number if arguments[:render_population]
  end

  def handle(fields:, **args)
    City.find(arguments[:cities]).each do |city|
      city.update! fields
    end

    succeed "City updated!"
  end
end
```
:::

You can see this multi-step process in action by visiting the [avodemo](https://main.avodemo.com/avo/resources/cities). Select one of the records, click on the "Update" action, choose the fields to update, and then proceed to update the selected fields in the subsequent action.
</Option>

<Option name="`append_to_response`" headingSize=3>

<VersionReq version="3.10.3" class="mt-4" />

Avo action responses are in the `turbo_stream` format. You can use the `append_to_response` method to append additional turbo stream responses to the default response.

```ruby{5-7}
def handle(**args)
  succeed "Modal closed!!"
  close_modal

  append_to_response -> {
    turbo_stream.set_title("Cool title ;)")
  }
end
```

The `append_to_response` method accepts a Proc or lambda function. This function is executed within the context of the action's controller response.

The block should return either a single `turbo_stream` response or an array of multiple `turbo_stream` responses.

:::code-group
```ruby[Array]{2-5}
append_to_response -> {
  [
    turbo_stream.set_title("Cool title"),
    turbo_stream.set_title("Cool title 2")
  ]
}
```

```ruby[Single]{2}
append_to_response -> {
  turbo_stream.set_title("Cool title")
}
```
:::
</Option>

<Option name="`reload_records`" headingSize=3>

<VersionReq version="3.14.0" class="my-4" />

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/6b9ae6a3968c447f98ac4f9a161fe781?sid=17f08010-6a56-4e8c-8b80-692424327b55" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>

:::warning
This option **only** works on **Index** pages, **NOT** on **associations**.
:::

This option leverages Turbo Stream to refresh specific table rows in response to an action. For individual records, you can use the `reload_record` alias method.

```ruby{8}
def handle(query:, fields:, **args)
  query.each do |record|
    record.update! active: !record.active

    record.notify fields[:message] if fields[:notify_user]
  end

  reload_records(query)
end
```

The `reload_records` and `reload_record` methods are aliases, and they accept either an array of records or a single record.

:::code-group
```ruby[Array]{1}
reload_records([record_1, record_2])
```

```ruby[Single]{1}
reload_record(record)
```
:::
</Option>

---

# Customization

Actions can be customized in several ways to enhance the user experience. You can modify the action's display name, confirmation message, button labels, and confirmation behavior between other things.

There are 2 types of customization, visual and behavioral.

## Visual customization

Visual customization is the process of modifying the action's appearance. This includes changing the action's name, message and button labels.

All visual customization options can be set as a string or a block.

The blocks are executed using `Avo::ExecutionContext`. Within these blocks, you gain access to:

- All attributes of `Avo::ExecutionContext`
- `resource` - The current resource instance
- `record` - The current record
- `view` - The current view
- `arguments` - Any passed arguments
- `query` - The current query parameters

<Option name="`name`" headingSize=3>

The `name` option is used to change the action's display name.

```ruby{3,5-8}
# app/avo/actions/release_fish.rb
class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.name = "Release fish"

  # Or as a block
  self.name = -> {
    record.present? ? "Release #{record.name}?" : "Release fish"
  }
end
```

</Option>

<Option name="`message`" headingSize=3>

The `message` option is used to change the action's confirmation message.

```ruby{3,5-12}
# app/avo/actions/release_fish.rb
class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.message = "Are you sure you want to release the fish?"

  # Or as a block
  self.message = -> {
    if resource.record.present?
      "Are you sure you want to release the #{resource.record.name}?"
    else
      "Are you sure you want to release the fish?"
    end
  }
end
```

</Option>

<Option name="`confirm_button_label`" headingSize=3>

The `confirm_button_label` option is used to change the action's confirmation button label.

```ruby{3,5-12}
# app/avo/actions/release_fish.rb
class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.confirm_button_label = "Release fish"

  # Or as a block
  self.confirm_button_label = -> {
    if resource.record.present?
      "Release #{resource.record.name}"
    else
      "Release fish"
    end
  }
end
```

</Option>

<Option name="`cancel_button_label`" headingSize=3>

The `cancel_button_label` option is used to change the action's cancel button label.

```ruby{3,5-12}
# app/avo/actions/release_fish.rb
class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.cancel_button_label = "Cancel release"

  # Or as a block
  self.cancel_button_label = -> {
    if resource.record.present?
      "Cancel release on #{resource.record.name}"
    else
      "Cancel release"
    end
  }
end
```

</Option>

## Behavioral customization

Behavioral customization is the process of modifying the action's behavior. This includes changing the action's confirmation behavior and authorization.

<Option name="`no_confirmation`" headingSize=3>

By default, actions display a confirmation modal before execution. You can bypass this modal by setting `self.no_confirmation = true`, which will execute the action immediately upon triggering.

```ruby{3}
# app/avo/actions/release_fish.rb
class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.no_confirmation = true
end
```

This is particularly useful for actions that:
- Are safe to execute without confirmation
- Need to provide immediate feedback
- Are part of a multi-step workflow where confirmation is handled elsewhere

</Option>

<Option name="`standalone`" headingSize=3>

Standalone actions allow you to execute operations that aren't tied to specific model records. These are useful for global operations like:

- Generating system-wide reports
- Running maintenance tasks
- Triggering background jobs

You can create a standalone action in two ways:

1. Using the generator with the `--standalone` flag:
```bash
bin/rails generate avo:action global_action --standalone
```

2. Adding `self.standalone = true` to an existing action:
```ruby{4}
# app/avo/actions/global_report.rb
class Avo::Actions::GlobalReport < Avo::BaseAction
  self.name = "Generate Global Report"
  self.standalone = true
end
```

Standalone actions will be active in the Actions dropdown even when no records are selected. They can be used alongside regular record-based actions in the same resource.

:::tip
Standalone actions work well with the [`fields`](#fields) feature to collect additional input needed for the operation.
:::

</Option>

<Option name="`visible`" headingSize=3>

You may want to hide specific actions on some views, like a standalone action on the `Show` and `Edit` views, and show it only on the `Index` view. You can do that using the `self.visible` attribute.

```ruby{5,8}
# app/avo/actions/global_report.rb
class Avo::Actions::GlobalReport < Avo::BaseAction
  self.name = "Generate Global Report"
  self.standalone = true
  self.visible = true

  # Or as a block
  self.visible = -> { view.index? }
end
```

The `visible` attribute accepts a boolean or a block.

The block will be executed within the `Avo::ExecutionContext` environment, giving you access to important contextual attributes like:
- `view` - The current view type (index, show, edit)
- `resource` - The current resource instance
- `parent_resource` - The parent resource (if applicable).
  - You can access the `parent_record` by `parent_resource.record`
- Plus all other `Avo::ExecutionContext` default attributes
</Option>

<Option name="`authorize`" headingSize=3>

The `authorize` attribute is used to restrict access to actions based on custom logic.

If an action is unauthorized, it will be hidden. If a bad actor attempts to proceed with the action, the controller will re-evaluate the authorization and block unauthorized requests.

```ruby{2,4-7}
class Avo::Actions::GlobalReport < Avo::BaseAction
  self.authorize = false

  # Or as a block
  self.authorize = -> {
    current_user.is_admin?
  }
end
```

The `authorize` attribute accepts a boolean or a proc.

The block will be executed within the `Avo::ExecutionContext` environment, giving you access to important contextual attributes like:
- `action` - The current action instance
- `resource` - The current resource instance
- `view` - The current view type (index, show, edit)
- All other `Avo::ExecutionContext` attributes

</Option>

<Option name="`close_modal_on_backdrop_click`" headingSize=3>

<VersionReq version="3.14.0" class="mt-4" />

By default, action modals use a dynamic backdrop.

Add `self.close_modal_on_backdrop_click = false` in case you want to prevent the user from closing the modal when clicking on the backdrop.

```ruby{3}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  self.close_modal_on_backdrop_click = false
end
```

</Option>

<Option name="`turbo`" headingSize=3>

The `turbo` attribute is used to control the Turbo behavior of actions.

There are times when you don't want to perform the actions with Turbo. In such cases, turbo should be set to false.

```ruby{3}
# app/avo/actions/toggle_inactive.rb
class Avo::Actions::ToggleInactive < Avo::BaseAction
  self.turbo = false
end
```

The `turbo` attribute accepts a boolean.
</Option>

---

# WIP
this section is under construction
## Helpers

### `link_arguments`

The `link_arguments` method is used to generate the arguments for an action link.

You may want to dynamically generate an action link. For that you need the action class and a resource instance (with or without record hydrated). Call the action's class method `link_arguments` with the resource instance as argument and it will return the `[path, data]` that are necessary to create a proper link to a resource.

Let's see an example use case:

```ruby{4-,16} [Current Version]
# app/avo/resources/city.rb
class Avo::Resources::City < Avo::BaseResource
  field :name, as: :text, name: "Name (click to edit)", only_on: :index do
    path, data = Avo::Actions::City::Update.link_arguments(
      resource: resource,
      arguments: {
        cities: Array[resource.record.id],
        render_name: true
      }
    )

    link_to resource.record.name, path, data: data
  end
end
```

<Image src="/assets/img/actions/action_link.gif" width="684" height="391" alt="actions link demo" />

:::tip
#### Generate an Action Link Without a Resource Instance
Sometimes, you may need to generate an action link without having access to an instantiated resource.

#### Scenario
Imagine you want to trigger an action from a custom partial card on a dashboard, but there is no resource instance available.

#### Solution
In this case, you can create a new resource instance (with or without record) and use it as follows:

```ruby
path, data = Avo::Actions::City::Update.link_arguments(
  resource: Avo::Resources::City.new(record: city)
)

link_to "Update city", path, data: data
```
:::

## Guides

### StimulusJS

Please follow our extended StimulusJS guides for more information.

### Passing Params to the Action Show Page
When navigation to an action from a resource <Index /> or <Show /> views, it's sometimes useful to pass parameters to an action.

One particular example is when you'd like to populate a field in that action with some particular value based on that param.

```ruby
class Action
  def fields
    field :some_field, as: :hidden, default: -> { if previous_param == yes ? :yes : :no}
  end
end
```
Consider the following scenario:

1. Navigate to `https://main.avodemo.com/avo/resources/users`.
2. Add the parameter `hey=ya` to the URL: `https://main.avodemo.com/avo/resources/users?hey=ya`
3. Attempt to run the dummy action.
4. After triggering the action, verify that you can access the `hey` parameter.
5. Ensure that the retrieved value of the `hey` parameter is `ya`.

**Implementation**

To achieve this, we'll reference the `request.referer` object and extract parameters from the URL. Here is how to do it:

```ruby
class Action
  def fields
    # Accessing the parameters passed from the parent view
    field :some_field, as: :hidden, default: -> {
      # Parsing the request referer to extract parameters
      parent_params = URI.parse(request.referer).query.split("&").map { |param| param.split("=")}.to_h.with_indifferent_access
      # Checking if the `hei` parameter equals `ya`
      if parent_params[:hey] == 'ya'
        :yes
      else
        :no
      end
    }
  end
end
```
Parse the `request.referer` to extract parameters using `URI.parse`.
Split the query string into key-value pairs and convert it into a hash.
Check if the `hey` parameter equals `ya`, and set the default value of `some_field` accordingly.

---

# Dashboards

:::warning
You must manually require the `chartkick` gem in your `Gemfile`.

```ruby
# Create beautiful JavaScript charts with one line of Ruby
gem "chartkick"
```
:::

There comes the point in your app's life when you need to display the data in an aggregated form like a metric or chart. That's what Avo's Dashboards are all about.

## Generate a dashboard

Run `bin/rails g avo:dashboard my_dashboard` to get a shiny new dashboard.

```ruby
class Avo::Dashboards::MyDashboard < Avo::Dashboards::BaseDashboard
  self.id = 'my_dashboard'
  self.name = 'Dashy'
  self.description = 'The first dashbaord'
  self.grid_cols = 3

  def cards
    card Avo::Cards::ExampleMetric
    card Avo::Cards::ExampleAreaChart
    card Avo::Cards::ExampleScatterChart
    card Avo::Cards::PercentDone
    card Avo::Cards::AmountRaised
    card Avo::Cards::ExampleLineChart
    card Avo::Cards::ExampleColumnChart
    card Avo::Cards::ExamplePieChart
    card Avo::Cards::ExampleBarChart
    divider label: "Custom partials"
    card Avo::Cards::ExampleCustomPartial
    card Avo::Cards::MapCard
  end
end
```

<Image src="/assets/img/dashboards/dashboard.jpg" width="1262" height="1094" alt="Avo Dashboard" />

## Settings

Each dashboard is a file. It holds information about itself like the `id`, `name`, `description`, and how many columns its grid has.

The `id` field has to be unique. The `name` is what the user sees in big letters on top of the page, and the `description` is some text you pass to give the user more details regarding the dashboard.

Using the ' grid_cols ' parameter, you may organize the cards in a grid with `3`, `4`, `5`, or `6` columns using the `grid_cols` parameter. The default is `3`.

## Cards
This section has moved.

### Override card arguments from the dashboard

We found ourselves in the position to add a few cards that were the same card but with a slight difference. Ex: Have one `Users count` card and another `Active users count` card. They both count users, but the latter has an `active: true` condition applied.

Before, we'd have to duplicate that card and modify the `query` method slightly but end up with duplicated boilerplate code.
For those scenarios, we created the `arguments` attribute. It allows you to send arbitrary arguments to the card from the parent.

```ruby{7-9}
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  self.id = "dashy"
  self.name = "Dashy"

  def cards
    card Avo::Cards::UsersCount
    card Avo::Cards::UsersCount, arguments: {
      active_users: true
    }
  end
end
```

Now we can pick up that option in the card and update the query accordingly.

```ruby{9-11}
class Avo::Cards::UsersCount < Avo::Cards::MetricCard
  self.id = "users_metric"
  self.label = "Users count"

  # You have access to context, params, range, current parent, and current card
  def query
    scope = User

    if arguments[:active_users].present?
      scope = scope.active
    end

    result scope.count
  end
end
```

That gives you an extra layer of control without code duplication and the best developer experience.

#### Control the base settings from the parent

Evidently, you don't want to show the same `label`, `description`, and other details for that second card from the first card.
Therefore, you can control the `label`, `description`, `cols`, `rows`, `visible`, and `refresh_every` arguments from the parent declaration.

```ruby{8-16}
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  self.id = "dashy"
  self.name = "Dashy"

  def cards
    card Avo::Cards::UsersCount
    card Avo::Cards::UsersCount,
      label: "Active users",
      description: "Active users count",
      cols: 2,
      rows: 2,
      visible: -> { true }
      refresh_every: 2.minutes,
      arguments: {
        active_users: true
      }
  end
end
```

## Dashboards visibility

You might want to hide specific dashboards from certain users. You can do that using the `visible` option. The option can be a boolean `true`/`false` or a block where you have access to the `params`, `current_user`, `context`, and `dashboard`.

If you don't pass anything to `visible`, the dashboard will be available for anyone.

```ruby{5-11}
class Avo::Dashboards::ComplexDash < Avo::Dashboards::BaseDashboard
  self.id = "complex_dash"
  self.name = "Complex dash"
  self.description = "Complex dash description"
  self.visible = -> do
    current_user.is_admin?
    # or
    params[:something] == 'something else'
    # or
    context[:your_param] == params[:something_else]
  end

  def cards
    card Avo::Cards::UsersCount
  end
end
```

## Dashboards authorization

<VersionReq version="2.22" />

You can set authorization rules for dashboards using the `authorize` block.

```ruby{3-6}
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  self.id = 'dashy'
  self.authorize = -> do
    # You have access to current_user, params, request, context, adn view_context.
    current_user.is_admin?
  end
end
```

<Option name="`self.name`">

`self.name` is what is going to be displayed to the user as the dashboard name.

```ruby
self.name = "Dashy"
```

<VersionReq version="3.14.2" /> `self.name` can be configured using a Proc.

```ruby
self.name = -> { I18n.t("avo.dashboards.dashy.name") }
```

Within this block, you gain access to all attributes of `Avo::ExecutionContext` along with the `dashboard`.

</Option>

---

# Cards

Cards are one way of quickly adding custom content for your users.

Cards can be used on dashboards or resources, we'll refer to both of them as "parent" since they're hosting the cards.

You can add three types of cards to your parent: `partial`, `metric`, and `chartkick`.

## Base settings

All cards have some standard settings like `id`, which must be unique, `label` and `description`. The `label` will be the title of your card, and `description` will show a tiny question mark icon on the bottom right with a tooltip with that description.

Each card has its own `cols` and `rows` settings to control the width and height of the card inside the parent's grid. They can have values from `1` to `6`.

All this settings can be called as an lambda.

The lambda will be executed using `Avo::ExecutionContext`. Within this blocks, you gain access to all attributes of `Avo::ExecutionContext` along with the `parent`, `resource`, `dashboard` and `card`.

```ruby{2-7}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = "users_metric"
  self.label = -> { "Users count" }
  self.description = -> { "Users description" }
  self.cols = 1
  self.rows = 1
  self.display_header = true
end
```

<Image src="/assets/img/dashboards/users_metric.jpg" width="331" height="170" alt="Avo Metric Card" />

## Ranges
#### Control the aggregation using ranges

You may also want to give the user the ability to query data in different ranges. You can control what's passed in the dropdown using the' ranges' attribute. The array passed here will be parsed and displayed on the card. All integers are transformed to days, and other string variables will be passed as they are.

You can also set a default range using the `initial_range` attribute.

The ranges have been changed a bit since **version 2.8**. The parameter you pass to the `range` option will be directly passed to the [`options_for_select`](https://apidock.com/rails/v5.2.3/ActionView/Helpers/FormOptionsHelper/options_for_select) helper, so it behaves more like a regular `select_tag`.

```ruby{4-15}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.label = 'Users count'
  self.initial_range = 30
  self.ranges = {
    "7 days": 7,
    "30 days": 30,
    "60 days": 60,
    "365 days": 365,
    Today: "TODAY",
    "Month to date": "MTD",
    "Quarter to date": "QTD",
    "Year to date": "YTD",
    All: "ALL"
  }
end
```

## Keep the data fresh

If the parent is something that you keep on the big screen, you need to keep the data fresh at all times. That's easy using `refresh_every`. You pass the number of seconds you need to be refreshed and forget about it. Avo will do it for you.

```ruby{3}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.refresh_every = 10.minutes
end
```

## Hide the header

In cases where you need to embed some content that should fill the whole card (like a map, for example), you can choose to hide the label and ranges dropdown.

```ruby{3}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.display_header = false
end
```
<Image src="/assets/img/dashboards/map_card.jpg" width="653" height="602" alt="Avo Map card" />

## Format

Option `self.format` is useful when you want to format the data that `result` returns from `query`.

Example without format:

```ruby
class Avo::Cards::AmountRaised < Avo::Cards::MetricCard
  self.id = "amount_raised"
  self.label = "Amount raised"
  self.prefix = "$"

  def query
    result 9001
  end
end
```

<Image src="/assets/img/3_0/cards/amount_raised_without_format.png" width="296" height="196" alt="amount raised without format" />

Example with format:

```ruby
class Avo::Cards::AmountRaised < Avo::Cards::MetricCard
  self.id = "amount_raised"
  self.label = "Amount raised"
  self.prefix = "$"
  self.format = -> {
    number_to_social value, start_at: 1_000
  }

  def query
    result 9001
  end
end
```

<Image src="/assets/img/3_0/cards/amount_raised_with_format.png" width="300" height="204" alt="amount raised with format" />

## Metric card

The metric card is your friend when you only need to display a simple big number. To generate one run `bin/rails g avo:card users_metric --type metric`.

<Image src="/assets/img/dashboards/users_metric.jpg" width="331" height="170" alt="Avo Metric" />

#### Calculate results

To calculate your result, you may use the `query` method. After you make the query, use the `result` method to store the value displayed on the card.

In the `query` method you have access to a few variables like `context` (the App context), `params` (the request params), `range` (the range that was requested), `dashboard`, `resource` or `parent` (the current dashboard or resource the card is on), and current `card`.

```ruby{23-47,36}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.label = 'Users count'
  self.description = 'Some tiny description'
  self.cols = 1
  # self.rows = 1
  # self.initial_range = 30
  # self.ranges = {
  #   "7 days": 7,
  #   "30 days": 30,
  #   "60 days": 60,
  #   "365 days": 365,
  #   Today: "TODAY",
  #   "Month to date": "MTD",
  #   "Quarter to date": "QTD",
  #   "Year to date": "YTD",
  #   All: "ALL",
  # }
  # self.prefix = '$'
  # self.suffix = '%'
  # self.refresh_every = 10.minutes

  def query
    from = Date.today.midnight - 1.week
    to = DateTime.current

    if range.present?
      if range.to_s == range.to_i.to_s
        from = DateTime.current - range.to_i.days
      else
        case range
        when 'TODAY'
          from = DateTime.current.beginning_of_day
        when 'MTD'
          from = DateTime.current.beginning_of_month
        when 'QTD'
          from = DateTime.current.beginning_of_quarter
        when 'YTD'
          from = DateTime.current.beginning_of_year
        when 'ALL'
          from = Time.at(0)
        end
      end
    end

    result User.where(created_at: from..to).count
  end
end
```

### Decorate the data using `prefix` and `suffix`

Some metrics might want to add a `prefix` or a `suffix` to display the data better.

```ruby{3,4}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.prefix = '$'
  self.suffix = '%'
end
```

<Image src="/assets/img/dashboards/prefix-suffix.jpg" width="651" height="168" alt="Avo Prefix & suffix" />

<br>

<VersionReq version="3.13" /> `prefix` and `suffix` became callable options.

The blocks are executed using `Avo::ExecutionContext`. Within this blocks, you gain access to all attributes of `Avo::ExecutionContext` along with the `parent`.

```ruby{3,4}
class Avo::Cards::UsersMetric < Avo::Cards::MetricCard
  self.id = 'users_metric'
  self.prefix = -> { params[:prefix] || parent.prefix }
  self.suffix = -> { params[:suffix] || parent.suffix }
end
```

## Chartkick card

A picture is worth a thousand words. So maybe a chart a hundred? Who knows? But creating charts in Avo is very easy with the help of the [chartkick](https://github.com/ankane/chartkick) gem.

You start by running `bin/rails g avo:card users_chart --type chartkick`.

```ruby
class Avo::Cards::UserSignups < Avo::Cards::ChartkickCard
  self.id = 'user_signups'
  self.label = 'User signups'
  self.chart_type = :area_chart
  self.description = 'Some tiny description'
  self.cols = 2
  # self.rows = 1
  # self.chart_options = { library: { plugins: { legend: { display: true } } } }
  # self.flush = true
  # self.legend = false
  # self.scale = false
  # self.legend_on_left = false
  # self.legend_on_right = false

  def query
    points = 16
    i = Time.new.year.to_i - points
    base_data =
      Array
        .new(points)
        .map do
          i += 1
          [i.to_s, rand(0..20)]
        end
        .to_h

    data = [
      { name: 'batch 1', data: base_data.map { |k, v| [k, rand(0..20)] }.to_h },
      { name: 'batch 2', data: base_data.map { |k, v| [k, rand(0..40)] }.to_h },
      { name: 'batch 3', data: base_data.map { |k, v| [k, rand(0..10)] }.to_h }
    ]

    result data
  end
end
```

<Image src="/assets/img/dashboards/chartkick.jpg" width="650" height="169" alt="Chartkick card" />

### Chart types

Using the `self.chart_type` class attribute you can change the type of the chart. Supported types are `line_chart`, `pie_chart`, `column_chart`, `bar_chart`, `area_chart`, and `scatter_chart`.

### Customize chart

Because the charts are being rendered with padding initially, we offset that before rendering to make the chart look good on the card. To disable that, you can set `self.flush = false`. That will set the chart loose for you to customize further.

After you set `flush` to `false`, you can add/remove the `scale` and `legend`. You can also place the legend on the left or right using `legend_on_left` and `legend_on_right`.

These are just some of the predefined options we provide out of the box, but you can send different [chartkick options](https://github.com/ankane/chartkick#options) to the chart using `chart_options`.

If you'd like to use [Groupdate](https://github.com/ankane/groupdate), [Hightop](https://github.com/ankane/hightop), and [ActiveMedian](https://github.com/ankane/active_median) you should require them in your `Gemfile`. Only `chartkick` is required by default.

`chart.js` is supported for the time being. So if you need support for other types, please reach out or post a PR (ðŸ™ PRs are much appreciated).

<VersionReq version="3.6.1" />
`self.chartkick_options` accepts callable blocks:
```ruby
class Avo::Cards::ExampleAreaChart < Avo::Cards::ChartkickCard
  self.chart_options: -> do
    {
      library: {
        plugins: {
          legend: {display: true}
        }
      }
    }
  end
end
```

`chartkick_options` can also be declared when registering the card:

```ruby
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  def cards
    card Avo::Cards::ExampleAreaChart,
      chart_options: {
        library: {
          plugins: {
            legend: {display: true}
          }
        }
      }

    # OR

    card Avo::Cards::ExampleAreaChart,
      chart_options: -> do
        {
          library: {
            plugins: {
              legend: {display: true}
            }
          }
        }
      end
  end
end
```

The blocks are executed using `Avo::ExecutionContext`. Within this blocks, you gain access to all attributes of `Avo::ExecutionContext` along with the `parent`, `arguments` and `result_data`.

## Partial card

You can use a partial card to add custom content to a card. Generate one by running `bin/rails g avo:card custom_card --type partial`. That will create the card class and the partial for it.

```ruby{5}
class Avo::Cards::ExampleCustomPartial < Avo::Cards::PartialCard
  self.id = "users_custom_card"
  self.cols = 1
  self.rows = 4
  self.partial = "avo/cards/custom_card"
  # self.display_header = true
end
```
<Image src="/assets/img/dashboards/custom_partial_card.jpg" width="330" height="598" alt="Custom partial card" />

You can embed a piece of content from another app using an iframe. You can hide the header using the `self.display_header = false` option. That will render the embedded content flush to the container.

```ruby{5}
# app/avo/cards/map_card.rb
class Avo::Cards::MapCard < Avo::Cards::PartialCard
  self.id = "map_card"
  self.label = "Map card"
  self.partial = "avo/cards/map_card"
  self.display_header = false
  self.cols = 2
  self.rows = 4
end
```

```html

<iframe src="https://www.google.com/maps/embed?pb=!1m14!1m12!1m3!1d17991.835132857846!2d-73.98926852562143!3d40.742050491245955!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!5e0!3m2!1sen!2sro!4v1647079626880!5m2!1sen!2sro" width="100%" height="100%" style="border:0;" allowfullscreen="" loading="lazy"></iframe>
```

<Image src="/assets/img/dashboards/map_card.jpg" width="653" height="602" alt="Avo Map card" />

## Cards visibility

<VersionReq version="2.28" />

It's common to show the same card to multiple types of users (admins, regular users). In that scenario you might want to hide some cards for the regular users and show them just to the admins.

You can use the `visible` option to do that. It can be a `boolean` or a `block` where you can access the `params`, `current_user`, `context`, `parent`, and `card` object.

```ruby{4-11}
class Avo::Cards::UsersCount < Avo::Cards::MetricCard
  self.id = "users_metric"
  self.label = "Users count"
  self.visible = -> do
    # You have access to:
    # context
    # params
    # parent (the current dashboard or resource)
    # dashboard (will be nil when parent is resource)
    # resource (will be nil when parent is dashboard)
    # current card
    true
  end

  def query
    result User.count
  end
end
```

You may also control the visibility from the parent class.

:::code-group
```ruby [On Dashboards]
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  def cards
    card Avo::Cards::UsersCount, visible: -> { true }
  end
end
```

```ruby [On Resources]
class Avo::Resources::User < Avo::BaseResource
  def cards
    card Avo::Cards::UsersCount, visible: -> { true }
  end
end
```
:::

## Dividers

You may want to separate the cards. You can use dividers to do that.

```ruby [On Dashboards]
class Avo::Dashboards::Dashy < Avo::Dashboards::BaseDashboard
  def cards
    card Avo::Cards::ExampleColumnChart
    card Avo::Cards::ExamplePieChart
    card Avo::Cards::ExampleBarChart
    divider label: "Custom partials"
    card Avo::Cards::ExampleCustomPartial
    card Avo::Cards::MapCard
  end
end
```

<Image src="/assets/img/dashboards/divider.jpg" width="980" height="379" alt="Avo Dashboard Divider" />

Dividers can be a simple line between your cards or have some text on them that you control using the `label` option.
When you don't want to show the line, you can enable the `invisible` option, which adds the divider but does not display a border or label.

## Dividers visibility

<VersionReq version="2.28" />

You might want to conditionally show/hide a divider based on a few factors. You can do that using the `visible` option.

```ruby
divider label: "Custom partials", visible: -> {
  # You have access to:
  # context
  # params
  # parent (the current dashboard or resource)
  # dashboard (will be nil when parent is resource)
  # resource (will be nil when parent is dashboard)
  true
}
```

---

# Kanban boards

:::warning
The feature and docs are both work in progress. Please read the `info` sections below.
:::

Having a kanban board is a great way to organize your work and keep track of your records.

## Overview

The Kanban Board feature is a way to create a kanban board for your resources. They support multiple resources. Think about GitHub's Projects. You can have Issues, PRs, and simple tasks on them.

The boards and columns and items are database backed and you can create them on the fly.

## Requirements

Some of these requirements might change over time.

- We tested this on an app with Avo Advanced license
- [`acts_as_list`](https://github.com/brendon/acts_as_list) gem (comes automatically as a requirement)
- [`hotwire_combobox`](https://github.com/josefarias/hotwire_combobox) gem (comes automatically as a requirement)

## Installation

To install the `avo-kanban` gem, follow the steps below:

1. Add the following line to your Gemfile:
    ```ruby
    gem "avo-kanban", source: "https://packager.dev/avo-hq/"
    ```

2. Run the `bundle install` command to install the gem:
    ```bash
    bundle install
    ```

3. Generate the necessary resources and controllers by running:
    ```bash
    rails generate avo:kanban install
    ```

    This command will create pre-configured resources and controllers for managing boards, columns, and items in your application. You can further customize the generated code to suit your needs.

    This command will also generate the item's partial and a migration.

4. Run the migration to apply the database changes:
    ```bash
    rails db:migrate
    ```

## DB schema

`Avo::Kanban::Board` -> has_many `Avo::Kanban::Column` -> has_many `Avo::Kanban::Item`

The `Avo::Kanban::Column` has a polymorphic `belongs_to` association with any other model you might have in your app.

## Create a kanban board

We can create a kanban board by going to the Boards resource and clicking on the `Create board` button.

Once you create the board, add it to the menu using the `link_to` option (for now. we'll add `board` soon).

## Create columns

For now you can create the columns from the resource view.

By default, each column will have a `name` and `value` assigned to it. It will also have a `position` that you can use to sort the columns.

The `value` is what is being used to update the record when it's dropped into a new column.

## Configure the board

Each board has a configuration attached to it.
We can configure what kind of resources can be added to the board.

Similar we can change the column names and the value from the settings screen.

## Adding items to the board

This is best done on the board. Under each column you'll find the new field. This will search throught the resources that you've selected in the configuration.
It will use the `self.search[:query]` block to search for the records. It will send two `for_kanban_board` and `board_id` arguments to the block so you can customize the query.

When an item is added to the a column, it will have an `Avo::Kanban::Item` record created for it. This `Item` record is responsible for keeping track of the board, column, position properties and more.

When an item is added to the a column it will update the property on the record to the column's `value`. More on what this means in the next section.

## How does it work?

Each board updates one `property` on the `record`, and each column represents a `value`.
The record is the actual record from the database (User, Project, To Do, etc.).

Let's say we are replicating the GitHub Projects boards.

### `Board` and `Column`s

We should have a `Board` record with the following columns:

- `No status` with an empty string as value
- `Backlog` with the value `backlog`
- `In progress` with the value `in_progress`
- `Done` with the value `done`

The board has the `property` option set to `status` so we ensure that the `status` property of the record is updated when we move the item to a new column.

### `Resource`s and `Item`s

We should have `Issue`, `PullRequest`, and `ToDo` models and resources. The resources should have the `self.search[:query]` block configured.

Each resource must have the `self.title` method configured. This title will be used as a label to identify records throughout the kanban board, including in the search box and on individual entries.

Next in our board we should select these resources as allowed from the board settings.

### Add items to the board

At the bottom of the `No status` column we can search for an `Issue`. When we select that issue, an `Avo::Kanban::Item` record will be created for it with references to the board, column, and record (that issue).
This automatically triggers the issue to change the status to an empty string because we added it to the `No status` column which has the `value` set to an empty string.

If we were to add it to the `Backlog` column, it would change the status to `backlog`.

### Move items between columns

Now, if we move the item to the `In progress` column, it will change the status to `in_progress`.

### Items without that property

Some models might belong on the same board but have different properties to show the status.
Some models might use a timestamp like `published_at` to show the status.
Or some models might belong to a a status but that isn't dictated by a single property but a collection of properties.

In order to mitigate that we can create virtual properties on the model.

Let's imagine that a new board that displays the posts in columns based on their "published" status. the board uses the `status` property to but the `Post` model doesn't have the `status` property as a column in the database.
We can create a virtual property on the model.

```ruby
class Post < ApplicationRecord
  def status
    if published_at.present?
      "published"
    elsif published_status == "draft"
      "draft"
    else
      "private"
    end
  end

  def status=(value)
    if value == "published"
      published_at = Time.now
      published_status = "draft"
    elsif value == "draft"
      published_at = nil
      published_status = "draft"
    elsif value == "draft"
      published_at = nil
      published_status = nil
    end

    save!
  end
end
```

## Customize the card

:::warning
This might change in the future.
:::

In order to customize the card, you can eject the `Avo::Kanban::Items::ItemComponent` component.

```bash
rails generate avo:eject --component Avo::Kanban::Items::ItemComponent
```

Then customize it at `app/components/avo/kanban/items/item_component.html.erb`

```erb
<%= item.record.name %>
```

The `item` is the `Avo::Kanban::Item` and the `record` is the actual record from the database.

## Authorization

This section assumes that you have already set up authorization in your application using Pundit.

1. Generate a policy for the `Board` resource by running:
```bash
rails generate pundit:policy board
```

### Authorization Methods

You can control access to various parts of the Kanban board by defining the following methods in your `BoardPolicy`:

- `manage_column?`

  Controls the visibility of the three-dot menu on each column (used for column management).

- `edit?`

  Controls the "Edit board" button on the board itself.
  :::warning
    Also controls the ability to edit the board in the resource view.
  :::

- `add_item?`

  Controls the visibility of the "Add item" button on the board, which allows users to add new items to a column.
  :::warning
    Doesn't impact the ability to add items via the bottom of each column.
  :::

---

# Collaboration

Keep your team in sync with built-in comments and status updates. No more scattered communication across multiple tools.

:::info
Docs are a work in progress
:::

---

# Audit Logging

Avo's Audit Logging feature provides a seamless way to track and visualize user activity and changes within your applications. It seamlessly integrates with [`paper_trail`](https://github.com/paper-trail-gem/paper_trail), offering flexible installation and customization options.

Captures user activities on Avo resources and actions, recording details such as the author and the performed event.

The installation process will automatically generate the necessary migrations, resources, and controllers that power activity tracking. Additionally [`paper_trail`](https://github.com/paper-trail-gem/paper_trail) will be installed if it is not already present in your project.

## Requirements

- `avo-advanced`

## Installation

:::info
When installing `avo-audit_logging` on an application, we strongly recommend following this documentation page step-by-step without skipping sections, as it was designed with that approach in mind.
:::

### 1. Install the gem

Start by adding the following to your `Gemfile`:

```bash
gem "avo-audit_logging", source: "https://packager.dev/avo-hq/"
```

Then
```bash
bundle install
```

### 2. Run the installer

```bash
bin/rails generate avo:audit_logging install
```

### 3. Migrate

At this stage, all migrations, resources, and controllers required for the audit logging feature are set up and ready, it's time to migrate:

```bash
bin/rails db:migrate
```

## Enable and configure audit logging

### Global enable

After installation, audit logging is disabled by default. To enable it, navigate to your `avo.rb` initializer file and update the configuration for the `Avo::AuditLogging` module.

Set `config.enabled` to `true` within this configuration.

```ruby
# config/initializers/avo.rb # [!code focus]

Avo.configure do |config|
  # ...
end

Avo::AuditLogging.configure do |config| # [!code focus]
  # config.enabled = false # [!code --] # [!code focus]
  config.enabled = true # [!code ++] # [!code focus]
  # config.author_model = "User"
end # [!code focus]
```

:::info
Setting this configuration to `false` will disable the audit logging feature entirely, overriding any other specific settings. We'll cover those specific settings in the next steps.
:::

:::warning
Setting this configuration to `false` will not prevent previously registered activity from being displayed.

To control the display behavior when this configuration is set to `false`,
you can wrap the relevant fields or tools within an `Avo::AuditLogging.configuration.enabled?` condition, like this:

```ruby{6-8}
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :text, link_to_record: true
    field :products, as: :has_many
    if Avo::AuditLogging.configuration.enabled?
      field :avo_authored, as: :has_many, name: "Activity"
    end
  end
end
```
:::

### Configure author models

:::info
If `User` is your only author model, you can skip this step as it will be automatically set by default.
:::

Avo must determine the potential author models to correctly establish associations in the background. This setup enables the retrieval of all activities associated with a specific author via the `avo_authored` association. To designate a model as an author, use `config.author_model`, for multiple models, utilize `config.author_models`.

```ruby
# config/initializers/avo.rb # [!code focus]

Avo.configure do |config|
  # ...
end

Avo::AuditLogging.configure do |config| # [!code focus]
  config.enabled = true

  # config.author_model = "User" # [!code --] # [!code focus]
  config.author_model = "Account" # [!code ++] # [!code focus]

  # Or for multiples models # [!code focus]
  config.author_models = ["User", "Account"] # [!code ++] # [!code focus]
end # [!code focus]
```

### Enable specific resources and actions

At this stage, the audit logging feature should be enabled, but activities are not yet being saved. By default, only resources and actions that are explicitly enabled for auditing will be tracked.

To enable audit logging for specific resources or actions, use the `self.audit_logging` class attribute.

:::code-group
```ruby [Resource]{2-4}
class Avo::Resources::Product < Avo::BaseResource # [!code focus]
  self.audit_logging = { # [!code ++] # [!code focus]
    activity: true # [!code ++] # [!code focus]
  } # [!code ++] # [!code focus]

  def fields
    field :id, as: :id, link_to_record: true
    field :name, as: :text, link_to_record: true
    field :price, as: :number, step: 1
    # ...
  end

  def actions
    action Avo::Actions::ChangePrice
  end
end # [!code focus]
```

```ruby [Action]{4-6}
class Avo::Actions::ChangePrice < Avo::BaseAction # [!code focus]
  self.name = "Change Price"

  self.audit_logging = { # [!code ++] # [!code focus]
    activity: true # [!code ++] # [!code focus]
  } # [!code ++] # [!code focus]

  def fields
    field :price, as: :number, default: -> { resource.record.price rescue nil }
  end

  def handle(query:, fields:, current_user:, resource:, **args)
    query.each do |record|
      record.update!(price: fields[:price])
    end
  end
end # [!code focus]
```
:::

All resources and actions with audit logging activity enabled are being tracked now.

But these activities aren't visible yet, right? Let's look at how to display them in the next step.

## Display logged activities

### Resource-Specific Activities

The `Avo::ResourceTools::Timeline` tool, provided by the `avo-audit_logging` gem, is designed for use in the sidebar. It offers a compact view of activities that have occurred on a specific resource, presenting them in a streamlined format:

<Image src="/assets/img/3_0/audit-logging/sidebar-activities.png" width="1915" height="719" alt="Avo compact activities on sidebar image" />

### Configuring the Sidebar for Activity Tracking

To enable this feature, configure the resource to include the resource tool in the main menu sidebar:

```ruby{7,12-15}
class Avo::Resources::Product < Avo::BaseResource # [!code focus]
  self.audit_logging = {
    activity: true
  }

  def fields # [!code focus]
    main_panel do # [!code ++] # [!code focus]
      field :id, as: :id, link_to_record: true
      field :name, as: :text, link_to_record: true
      field :price, as: :number, step: 1

      sidebar do # [!code ++] # [!code focus]
        tool Avo::ResourceTools::Timeline # [!code ++] # [!code focus]
      end # [!code ++] # [!code focus]
    end # [!code ++] # [!code focus]

    field :avo_activities, as: :has_many # [!code focus]
  end # [!code focus]

  def actions
    action Avo::Actions::ChangePrice
  end
end # [!code focus]
```

### Viewing and Navigating Activity Logs

Hovering over an entry reveals the precise timestamp in UTC. Clicking on an entry navigates to a detailed page displaying the full payload.

<Image src="/assets/img/3_0/audit-logging/hover-activities.png" width="657" height="284" alt="Hover on activity" />

### Enabling Change Logs and Reverting Changes

By default, update activities do not display a change log, and there is no way to revert changes. This is because PaperTrail has not yet been enabled on the model. To enable it, simply add `has_paper_trail` to the model:

```ruby
# app/models/product.rb # [!code focus]

class Product < ApplicationRecord # [!code focus]
  has_paper_trail # [!code ++] # [!code focus]

  belongs_to :user, optional: true

  validates_presence_of :price
end # [!code focus]
```

Once enabled, the changelog will be visible, along with an action to revert changes.

<Image src="/assets/img/3_0/audit-logging/activity-details.png" width="2010" height="1152" alt="Activity details page" />

### Troubleshooting: Missing `changeset` Field

:::warning
If the `changeset` field in the versions table consistently appears as `nil`, ensure you add the following configuration in your `application.rb` file:

```ruby
config.active_record.yaml_column_permitted_classes = [Symbol, Date, Time, ActiveSupport::TimeWithZone, ActiveSupport::TimeZone]
```
:::

### Display author logged activities

Weâ€™ve already covered how to view all activity on a specific record. Now, letâ€™s display a table within `Avo::Resources::User` to view all tracked activity for a particular user.

<Image src="/assets/img/3_0/audit-logging/authored.png" width="1921" height="754" alt="Authored table image" />

:::warning
If you're using a model other than `User`, make sure you have already [configured the author models](#configure-author-models).
:::

```ruby
class Avo::Resources::User < Avo::BaseResource # [!code focus]
  def fields # [!code focus]
    field :id, as: :id, link_to_record: true
    field :email, as: :text, link_to_record: true
    field :products, as: :has_many
    field :avo_authored, as: :has_many, name: "Activity" # [!code ++] # [!code focus]
  end # [!code focus]
end # [!code focus]
```

### Overview of all activities

We've covered how to view activities for specific records and how to view all actions made by a particular author. However, having an overview of all the activities in one place can also be useful. This can be achieved by configuring the menu to include a section with an entry for all activities.

```ruby
# config/initializers/avo.rb

Avo.configure do |config|
  config.main_menu = -> {
    section "AuditLogging", icon: "presentation-chart-bar" do # [!code ++]
      resource :avo_activity # [!code ++]
    end # [!code ++]
  }
end
```

## Disable specific actions logging

By default, when audit logging is enabled for a resource or action, all actions, such as `index` visits, `show` visits, `edit`, `update`, etc. are logged.

If you prefer not to log all of these actions, configure the `actions` key within the `self.audit_logging` class attribute.

Let's turn off `edit` and `show` logging for the `Avo::Resources::Product`:

```ruby
class Avo::Resources::Product < Avo::BaseResource # [!code focus]
  self.audit_logging = { # [!code focus]
    activity: true, # [!code focus]
    actions: { # [!code ++] # [!code focus]
      edit: false, # [!code ++] # [!code focus]
      show: false # [!code ++] # [!code focus]
    } # [!code ++] # [!code focus]
  } # [!code focus]

  def fields
    main_menu do
      field :id, as: :id, link_to_record: true
      field :name, as: :text, link_to_record: true
      field :price, as: :number, step: 1

      sidebar do
        tool Avo::ResourceTools::Timeline
      end
    end
    # ...
    field :avo_activities, as: :has_many
  end

  def actions
    action Avo::Actions::ChangePrice
  end
end # [!code focus]
```

The default value for `actions` is:

```ruby
{
  index: true,
  new: true,
  create: true,
  edit: true,
  update: true,
  show: true,
  destroy: true,
  attach: true,
  detach: true,
  handle: true
}
```

## Conclusion

With Avo's Audit Logging, you gain a powerful tool to track and visualize user actions and record changes seamlessly across your application. By carefully following the setup steps and configuring logging to fit your needs, you can establish a robust and transparent audit system, enhancing accountability and preserving data integrity.

Happy auditing!

---

# Filters

Most content management systems need a way to filter the data.

Avo provides two types of filters you can use when building your app.

1. Basic filters
2. Dynamic filters

## Differences

### 1. Basic filters

- configured as one filter per file
- there are four types of filters (Text, Boolean, Select, Multiple select)
- they are more configurable
- you can scope out the information better
- you can use outside APIs or configurations
- you must add and configure each filter for a resource

### 2. Dynamic filters

- easier to set up. They only require one option on the field
- the user can choose the condition on which they filter the records
- a lot more conditions than basic filters
- the user can add multiple conditions per attribute
- they are more composable

---

# Filters

Filters allow you to better scope the index queries for records you are looking for.

Each filter is configured in a class with a few dedicated [methods and options](#filter-options). To use a filter on a resource you must [register it](#register-filters) and it will be displayed on the <Index /> view.

## Filter options

<Option name="`self.name`">

`self.name` is what is going to be displayed to the user in the filters panel.

```ruby
self.name = "User names filter"
```

<VersionReq version="3.14.0" />

```ruby
self.name = -> { I18n.t("avo.filter.name") }
```
Within this block, you gain access to all attributes of `Avo::ExecutionContext` along with the `arguments`.

</Option>

<Option name="`self.button_label`">

The value of `self.button_label` is the label displayed on the button that applies the filter.

```ruby
self.button_label = "Filter by user names"
```

<VersionReq version="3.14.0" />

```ruby
self.button_label = -> { I18n.t("avo.filter.button_label") }
```
Within this block, you gain access to all attributes of `Avo::ExecutionContext` along with the `arguments`.

</Option>

<Option name="`self.visible`">

You may want to show/hide the filter in some scenarios. You can do that using the `self.visible` attribute.

Inside the visible block you can acces the following variables and you should return a boolean (`true`/`false`).

```ruby
  self.visible = -> do
    #   You have access to:
    #   block
    #   context
    #   current_user
    #   params
    #   parent_model
    #   parent_resource
    #   resource
    #   view
    #   view_context
    true
  end
```
</Option>

<Option name="`self.empty_message`">

There might be times when you will want to show a message to the user when you're not returning any options.

More on this in the [Empty message guide](#empty-message-text).
</Option>
<Option name="`options`">

Some filters allow you to pass options to the user. For example on the [select filter](#select_filter) you can set the options in the dropdown, and on the [boolean filter](#boolean_filter) you may set the checkbox values.
Each filter type has their own `options` configuration explained below.

In the `options` method you have access to the `request`, `params`, `context`, `view_context`, and `current_user` objects.
</Option>

<Option name="`apply`">

The `apply` method is what is going to be run when Avo fetches the records on the <Index /> view.

It recieves the `request` form which you can get all the `params` if you need them, it gets the `query` which is the query Avo made to fetch the records. It's a regular [Active Record](https://guides.rubyonrails.org/active_record_querying.html) which you can manipulate.

It also receives the `values` variable which holds the actual choices the user made on the front-end for the [options](#options) you set.
</Option>

<Option name="`default`">

You may set default values for the `options` you set. For example you may set which option to be selected for the [select filter](#select_filter) and which checkboxes to be set for the [boolean filter](#boolean_filter).

In the `default` method you have access to the `request`, `params`, `context`, `view_context`, and `current_user` objects.
</Option>

<Option name="`react`">

This is a hook in which you can change the value of the filter based on what other filters have for values.

More on this in the [React to filters guide](#react-to-filters)
</Option>

## Register filters

In order to use a filter you must register it on a `Resource` using the `filter` method inside the `filters` method.

```ruby{9}
class Avo::Resources::Post < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id
  end

  def filters
    filter Avo::Filters::Published
  end
end
```

## Filter types

Avo has several types of filters available [Boolean filter](#Boolean%20Filter), [Select filter](#Select%20Filter), [Multiple select filter](#Multiple%20select%20filter), [Text filter](#Text%20Filter) and since version <Version version="3.11.8" /> [Date time filter](#Date%20time%20Filter).

<Image src="/assets/img/filters.png" width="404" height="727" alt="Avo filters" />

### Filter values

Because the filters get serialized back and forth, the final `value`/`values` in the `apply` method will be stringified or have the stringified keys if they are hashes. You can declare them as regular hashes in the `options` method, but they will get stringified.

<Option name="Boolean Filter">

The boolean filter is a filter where the user can filter the records using one or more checkboxes.

To generate one run:

```bash
bin/rails generate avo:filter featured
```
or
```bash
bin/rails generate avo:filter featured --type boolean
```

Here's a sample filter

```ruby
class Avo::Filters::Featured < Avo::Filters::BooleanFilter
  self.name = 'Featured filter'

  # `values` comes as a hash with stringified keys
  # Eg:
  # {
  #   'is_featured': true
  # }
  def apply(request, query, values)
    return query if values['is_featured'] && values['is_unfeatured']

    if values['is_featured']
      query = query.where(is_featured: true)
    elsif values['is_unfeatured']
      query = query.where(is_featured: false)
    end

    query
  end

  def options
    {
      is_featured: "Featured",
      is_unfeatured: "Unfeatured"
    }
  end

  # Optional method to set the default state.
  # def default
  #   {
  #     is_featured: true
  #   }
  # end
end
```

Each filter file comes with a `name`, `apply`, and `options` methods.

The `name` method lets you set the name of the filter.

The `apply` method is responsible for filtering out the records by giving you access to modify the `query` object. The `apply` method also gives you access to the current `request` object and the passed `values`. The `values` object is a `Hash` containing all the configured `options` with the option name as the key and `true`/`false` as the value.

```ruby
# Example values payload
{
  'is_featured': true,
  'is_unfeatured': false,
}
```

The `options` method defines the available values of your filter. They should return a `Hash` with the option id as a key and option label as value.

### Default value

You can set a default value to the filter, so it has a predetermined state on load. To do that, return the state you desire from the `default` method.

```ruby{23-27}
class Avo::Filters::Featured < Avo::Filters::BooleanFilter
  self.name = 'Featured status'

  def apply(request, query, values)
    return query if values['is_featured'] && values['is_unfeatured']

    if values['is_featured']
      query = query.where(is_featured: true)
    elsif values['is_unfeatured']
      query = query.where(is_featured: false)
    end

    query
  end

  def options
    {
      is_featured: "Featured",
      is_unfeatured: "Unfeatured"
    }
  end

  def default
    {
      is_featured: true
    }
  end
end
```
</Option>

<Option name="Select Filter">

Select filters are similar to Boolean ones but they give the user a dropdown with which to filter the values.

```bash
rails generate avo:filter published --type select
```

The most significant difference from the **Boolean filter** is in the `apply` method. You only get back one `value` attribute, which represents which entry from the `options` method is selected.

A finished, select filter might look like this.

```ruby
class Avo::Filters::Published < Avo::Filters::SelectFilter
  self.name = 'Published status'

  # `value` comes as a string
  # Eg: 'published'
  def apply(request, query, value)
    case value
    when 'published'
      query.where.not(published_at: nil)
    when 'unpublished'
      query.where(published_at: nil)
    else
      query
    end
  end

  def options
    {
      published: "Published",
      unpublished: "Unpublished"
    }
  end

  # Optional method to set the default state.
  # def default
  #   :published
  # end
end
```

### Default value

The select filter supports setting a default too. That should be a string or symbol with the select item. It will be stringified by Avo automatically.

```ruby{22-24}
class Avo::Filters::Published < Avo::Filters::SelectFilter
  self.name = 'Published status'

  def apply(request, query, value)
    case value
    when 'published'
      query.where.not(published_at: nil)
    when 'unpublished'
      query.where(published_at: nil)
    else
      query
    end
  end

  def options
    {
      'published': 'Published',
      'unpublished': 'Unpublished',
    }
  end

  def default
    :published
  end
end
```
</Option>

<Option name="Multiple select filter">

You may also use a multiple select filter.

```bash
rails generate avo:filter post_status --type multiple_select
```

```ruby
class Avo::Filters::PostStatus < Avo::Filters::MultipleSelectFilter
  self.name = "Status"

  # `value` comes as an array of strings
  # Ex: ['admins', 'non_admins']
  def apply(request, query, value)
    if value.include? 'admins'
      query = query.admins
    end

    if value.include? 'non_admins'
      query = query.non_admins
    end

    query
  end

  def options
    {
      admins: "Admins",
      non_admins: "Non admins",
    }
  end

  # Optional method to set the default state.
  # def default
  #   ['admins', 'non_admins']
  # end
end
```

<Image src="/assets/img/multiple-select-filter.png" width="404" height="310" alt="Avo multiple select filter" />

### Dynamic options

The select filter can also take dynamic options:

```ruby{15-17}
class Avo::Filters::Author < Avo::Filters::SelectFilter
  self.name = 'Author'

  def apply(request, query, value)
    query = query.where(author_id: value) if value.present?
    query
  end

  # Example `applied_filters`
  # applied_filters = {
  #   "Avo::Filters::CourseCountryFilter" => {
  #     "USA" => true,
  #     "Japan" => true,
  #     "Spain" => false,
  #     "Thailand" => false,
  #   }
  # }
  def options
    # Here you have access to the `applied_filters` object too
    Author.select(:id, :name).each_with_object({}) { |author, options| options[author.id] = author.name }
  end
end
```
</Option>

<Option name="Text Filter">

You can add complex text filters to Avo using the Text filter

```bash
rails generate avo:filter name --type text
```

```ruby
class Avo::Filters::Name < Avo::Filters::TextFilter
  self.name = "Name filter"
  self.button_label = "Filter by name"

  # `value` comes as text
  # Eg: 'avo'
  def apply(request, query, value)
    query.where('LOWER(name) LIKE ?', "%#{value}%")
  end

  # def default
  #   'avo'
  # end
end
```
</Option>

<Option name="Date time Filter">

<VersionReq version="3.11.8" />

The ideal filter for date selection. This filter allows you to generate a date input, with options to include time selection and even a range selection mode. Customizable to suit your specific needs.

:::warning Timezone Handling
This filter sends the selected value exactly as selected, without any timezone adjustments. If you need to apply timezone conversion or adjustments, please ensure to handle it during the [`apply`](#apply) method.
:::

Generate one by using:
```bash
rails generate avo:filter created_at --type date_time
```

The generated file should be following a similar format:
```ruby
# frozen_string_literal: true

class Avo::Filters::CreatedAt < Avo::Filters::DateTimeFilter
  self.name = "Created at"
  # self.type = :date_time
  # self.mode = :range
  # self.visible = -> do
  #   true
  # end

  def apply(request, query, value)
    query
  end

  # def format
  #   case type
  #   when :date_time
  #     'yyyy-LL-dd TT'
  #   when :date
  #     'yyyy-LL-dd'
  #   end
  # end

  # def picker_format
  #   case type
  #   when :date_time
  #     'Y-m-d H:i:S'
  #   when :time
  #     'Y-m-d'
  #   end
  # end
end

```

### Type
Determines the format of the input field.

##### Default value

`:date_time`

By default, the input allows users to select both a date and a time.

##### Possible values

- `:date`
  - This option restricts the input to date selection only, ideal for scenarios where time input is unnecessary.
  <Image src="/assets/img/date_type.png" class="mt-2" width="385" height="377" alt="Avo date time filter date type" />

- `:time`
  - This option limits the input to time selection only, suitable to apply where only the time is relevant.
  <Image src="/assets/img/time_type.png" class="mt-2" width="385" height="50" alt="Avo date time filter time type" />

- `:date_time`
  - This combined option enables both date and time selection, providing a comprehensive input for more detailed needs.
  <Image src="/assets/img/date_time_type.png" class="mt-2" width="385" height="427" alt="Avo date time filter date_time type" />

### Mode
Defines whether the input allows selection of a single date or a range of dates.

##### Default value

`:range`

By default, the input permits users to select a range of dates, ideal for scenarios such as booking periods or event durations.

##### Possible values
- `:range`
  - Allows users to choose a start and end date, making it suitable for applications that require a time span, such as reservations or scheduling.
  <Image src="/assets/img/range_mode.png" class="mt-2" width="385" height="377" alt="Avo date time filter range mode" />
  :::info
  In `:range` mode the `value` will be formatted as `"2024-08-13 to 2024-08-16"`.

  To separate the start and end dates, use `date_1, date_2 = value.split(" to ")`, which will split the value into `["2024-08-13", "2024-08-16"]`
  :::

- `:single`
  - Limits the selection to a single date, perfect for use cases where only one specific day needs to be selected, such as an appointment or event date.
  <Image src="/assets/img/single_mode.png" class="mt-2" width="385" height="370" alt="Avo date time filter single mode" />

### `picker_options`

This filter uses [flatpickr](https://flatpickr.js.org) as the date and time picker. If you wish to customize the pickerâ€™s options, you can do so by overriding the [`picker_options(value)`](https://github.com/avo-hq/avo/blob/menu/lib/avo/filters/date_time_filter.rb#L22) method. You can merge your custom options with those provided by [flatpickr](https://flatpickr.js.org), which are detailed [here](https://flatpickr.js.org/options/).

```ruby{10-14}
# frozen_string_literal: true

class Avo::Filters::StartingAt < Avo::Filters::DateTimeFilter
  self.name = "The starting at filter"
  self.button_label = "Filter by start time"
  self.empty_message = "Search by start time"
  self.type = :time
  self.mode = :single

  def picker_options(value)
    super.merge({
      minuteIncrement: 3
    })
  end

  def apply(request, query, value)
    query.where("to_char(starting_at, 'HH24:MI:SS') = ?", value)
  end
end
```
</Option>

## Dynamic filter options

<DemoVideo demo-video="https://youtu.be/M2RsNPPFOio" />

You might want to compose more advanced filters, like when you have two filters, one for the country and another for cities, and you'd like to have the cities one populated with cities from the selected country.

Let's take the `Avo::Resources::Course` as an example.

```ruby{3-5,7-14}
# app/models/course.rb
class Course < ApplicationRecord
  def self.countries
    ["USA", "Japan", "Spain", "Thailand"]
  end

  def self.cities
    {
      USA: ["New York", "Los Angeles", "San Francisco", "Boston", "Philadelphia"],
      Japan: ["Tokyo", "Osaka", "Kyoto", "Hiroshima", "Yokohama", "Nagoya", "Kobe"],
      Spain: ["Madrid", "Valencia", "Barcelona"],
      Thailand: ["Chiang Mai", "Bangkok", "Phuket"]
    }
  end
end
```

We will create two filtersâ€”one for choosing countries and another for cities.

```ruby{4-5}
# app/avo/resources/course.rb
class Avo::Resources::Course < Avo::BaseResource
  def filters
    filter Avo::Filters::CourseCountryFilter
    filter Avo::Filters::CourseCityFilter
  end
end
```

The country filter is pretty straightforward. Set the query so the `country` field to be one of the selected countries and the `options` are the available countries as `Hash`.

```ruby{6,10}
# app/avo/filters/course_country.rb
class Avo::Filters::CourseCountry < Avo::Filters::BooleanFilter
  self.name = "Course country filter"

  def apply(request, query, values)
    query.where(country: values.select { |country, selected| selected }.keys)
  end

  def options
    Course.countries.map { |country| [country, country] }.to_h
  end
end
```

The cities filter has a few more methods to manage the data better, but the gist is the same. The `query` makes sure the records have the city value in one of the cities that have been selected.

The `options` method gets the selected countries from the countries filter (`Avo::Filters::CourseCountryFilter`) and formats them to a `Hash`.

```ruby{6,10}
# app/avo/filters/course_city.rb
class Avo::Filters::CourseCity < Avo::Filters::BooleanFilter
  self.name = "Course city filter"

  def apply(request, query, values)
    query.where(city: values.select { |city, selected| selected }.keys)
  end

  def options
    cities_for_countries countries
  end

  private

  # Get a hash of cities for certain countries
  # Example payload:
  # countries = ["USA", "Japan"]
  def cities_for_countries(countries_array = [])
    countries_array
      .map do |country|
        # Get the cities for this country
        Course.cities.stringify_keys[country]
      end
      .flatten
      # Prepare to transform to a Hash
      .map { |city| [city, city] }
      # Turn to a Hash
      .to_h
  end

  # Get the value of the selected countries
  # Example payload:
  # applied_filters = {
  #   "Avo::Filters::CourseCountryFilter" => {
  #     "USA" => true,
  #     "Japan" => true,
  #     "Spain" => false,
  #     "Thailand" => false,
  #   }
  # }
  def countries
    if applied_filters["Avo::Filters::CourseCountryFilter"].present?
      # Fetch the value of the countries filter
      applied_filters["Avo::Filters::CourseCountryFilter"]
        # Keep only the ones selected
        .select { |country, selected| selected }
        # Pluck the name of the coutnry
        .keys
    else
      # Return empty array
      []
    end
  end
end
```

<Image src="/assets/img/filters/dynamic-options.png" width="688" height="1042" alt="Avo filters" />

The `countries` method above will check if the `Avo::Filters::CourseCountryFilter` has anything selected. If so, get the names of the chosen ones. This way, you show only the cities from the selected countries and not all of them.

## React to filters

<DemoVideo demo-video="https://youtu.be/M2RsNPPFOio?t=219" />

Going further with the example above, a filter can react to other filters. For example, let's say that when a user selects `USA` from the list of countries, you want to display a list of cities from the USA (that's already happening in `options`), and you'd like to select the first one on the list. You can do that with the `react` method.

```ruby{21-36}
# app/avo/filters/course_city.rb
class Avo::Filters::CourseCity < Avo::Filters::BooleanFilter
  self.name = "Course city filter"

  def apply(request, query, values)
    query.where(city: values.select { |city, selected| selected }.keys)
  end

  def options
    cities_for_countries countries
  end

  # applied_filters = {
  #   "Avo::Filters::CourseCountryFilter" => {
  #     "USA" => true,
  #     "Japan" => true,
  #     "Spain" => false,
  #     "Thailand" => false,
  #   }
  # }
  def react
    # Check if the user selected a country
    if applied_filters["Avo::Filters::CourseCountryFilter"].present? && applied_filters["Avo::Filters::CourseCityFilter"].blank?
      # Get the selected countries, get their cities, and select the first one.
      selected_countries = applied_filters["Avo::Filters::CourseCountryFilter"].select do |name, selected|
        selected
      end

      # Get the first city
      cities = cities_for_countries(selected_countries.keys)
      first_city = cities.first.first

      # Return the first city as selected
      [[first_city, true]].to_h
    end
  end

  private

  # Get a hash of cities for certain countries
  # Example payload:
  # countries = ["USA", "Japan"]
  def cities_for_countries(countries_array = [])
    countries_array
      .map do |country|
        # Get the cities for this country
        Course.cities.stringify_keys[country]
      end
      .flatten
      # Prepare to transform to a Hash
      .map { |city| [city, city] }
      # Turn to a Hash
      .to_h
  end

  # Get the value of the selected countries
  # Example `applied_filters` payload:
  # applied_filters = {
  #   "Avo::Filters::CourseCountryFilter" => {
  #     "USA" => true,
  #     "Japan" => true,
  #     "Spain" => false,
  #     "Thailand" => false,
  #   }
  # }
  def countries
    if applied_filters["Avo::Filters::CourseCountryFilter"].present?
      # Fetch the value of the countries filter
      applied_filters["Avo::Filters::CourseCountryFilter"]
        # Keep only the ones selected
        .select { |country, selected| selected }
        # Pluck the name of the coutnry
        .keys
    else
      # Return empty array
      []
    end
  end
end
```

After all, filters are applied, the `react` method is called, so you have access to the `applied_filters` object.
Using the applied filter payload, you can return the value of the current filter.

```ruby
def react
  # Check if the user selected a country
  if applied_filters["Avo::Filters::CourseCountryFilter"].present? && applied_filters["Avo::Filters::CourseCityFilter"].blank?
    # Get the selected countries, get their cities, and select the first one.
    selected_countries = applied_filters["Avo::Filters::CourseCountryFilter"]
      .select do |name, selected|
        selected
      end

    # Get the first city
    cities = cities_for_countries(selected_countries.keys)
    first_city = cities.first.first

    # Return the first city selected as a Hash
    [[first_city, true]].to_h
  end
end
```

Besides checking if the countries filter is populated (`applied_filters["Avo::Filters::CourseCountryFilter"].present?`), we also want to allow the user to customize the cities filter further, so we need to check if the user has added a value to that filter (`applied_filters["Avo::Filters::CourseCountryFilter"].blank?`).
If these conditions are true, the country filter has a value, and the user hasn't selected any values from the cities filter, we can react to it and set a value as the default one.

<Image src="/assets/img/filters/dynamic-options.gif" width="528" height="800" alt="Avo filters" />

Of course, you can modify the logic and return all kinds of values based on your needs.

## Empty message text

<DemoVideo demo-video="https://youtu.be/M2RsNPPFOio?t=347" />

There might be times when you will want to show a message to the user when you're not returning any options. You may customize that message using the `empty_message` option.

<Image src="/assets/img/filters/empty-message.gif" width="528" height="800" alt="Avo filters" />

```ruby{4}
# app/avo/filters/course_city.rb
class Avo::Filters::CourseCity < Avo::Filters::BooleanFilter
  self.name = "Course city filter"
  self.empty_message = "Please select a country to view options."

  def apply(request, query, values)
    query.where(city: values.select { |city, selected| selected }.keys)
  end

  def options
    if countries.present?
      []
    else
      ["Los Angeles", "New York"]
    end
  end

  private

  def countries
    # logic to fetch the countries
  end
end
```

## Keep filters panel open

<DemoVideo demo-video="https://youtu.be/M2RsNPPFOio?t=374" />

There are scenarios where you wouldn't want to close the filters panel when you change the values. For that, you can use the `keep_filters_panel_open` resource option.

More on this on the `keep_filters_panel_open` resource option.

## Filter arguments

Filters can have different behaviors according to their host resource. In order to achieve that, arguments must be passed like on the example below:

```ruby{12-14}
class Avo::Resources::Fish < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id
    field :name, as: :text
    field :user, as: :belongs_to
    field :type, as: :text, hide_on: :forms
  end

  def filters
    filter Avo::Filters::NameFilter, arguments: {
      case_insensitive: true
    }
  end
end
```

Now, the arguments can be accessed inside `Avo::Filters::NameFilter` ***`apply` method***, ***`options` method*** and on the ***`visible` block***!

```ruby{4-6,8-14}
class Avo::Filters::Name < Avo::Filters::TextFilter
  self.name = "Name filter"
  self.button_label = "Filter by name"
  self.visible = -> do
    arguments[:case_insensitive]
  end

  def apply(request, query, value)
    if arguments[:case_insensitive]
      query.where("LOWER(name) LIKE ?", "%#{value.downcase}%")
    else
      query.where("name LIKE ?", "%#{value}%")
    end
  end
end
```

## Manually create encoded URLs

You may want to redirect users to filtered states of the <Index /> view from other places in your app. In order to create those filtered states you may use these helpers functions or Rails helpers.

### Rails helpers

<Option name="`decode_filter_params`">

Decodes the `filters` param. This Rails helper can be used anywhere in a view or off the `view_context`.

#### Usage

```ruby
# in a view
decode_filter_params params[:filters] # {"NameFilter"=>"Apple"}

# Or somewhere in an Avo configuration file

class Avo::Actions::DummyAction < Avo::BaseAction
  self.name = "Dummy action"

  def handle(**args)
    filters = view_context.decode_filter_params(params[:filters])

    do_something_important_with_the_filters filters
  end
end
```
</Option>

<Option name="`encode_filter_params`">

Encodes a `filters` object into a serialized state that Avo understands. This Rails helper can be used anywhere in a view or off the `view_context`.

#### Usage

```ruby
# in a view
filters = {"NameFilter"=>"Apple"}
encode_filter_params filters # eyJOYW1lRmlsdGVyIjoiQXBwbGUifQ==

# Or somewhere in an Avo configuration file

class Avo::Actions::DummyAction < Avo::BaseAction
  self.name = "Dummy action"

  def handle(**args)
    do_something_important

    redirect_to avo.resources_users_path(filters: view_context.decode_filter_params({"NameFilter"=>"Apple"}))
  end
end
```
</Option>

### Standalone helpers

<Option name="`Avo::Filters::BaseFilter.decode_filters`">

Decodes the `filters` param. This standalone method can be used anywhere.

#### Usage

```ruby
class Avo::Actions::DummyAction < Avo::BaseAction
  self.name = "Dummy action"

  def handle(**args)
    filters = Avo::Filters::BaseFilter.decode_filters(params[:filters])

    do_something_important_with_the_filters filters
  end
end
```
</Option>

<Option name="`Avo::Filters::BaseFilter.encode_filters`">

Encodes a `filters` object into a serialized state that Avo understands. This standalone method can be used anywhere.

#### Usage

```ruby
class Avo::Actions::DummyAction < Avo::BaseAction
  self.name = "Dummy action"

  def handle(**args)
    do_something_important

    redirect_to avo.resources_users_path(encoded_filters: Avo::Filters::BaseFilter.encode_filters({"Avo::Filters::NameFilter"=>"Apple"}))
  end
end
```
</Option>

---

# Dynamic filters

The Dynamic filters make it so easy to add multiple, composable, and dynamic filters to the <Index /> view.

The first thing you need to do is add the `filterable: true` attribute to the fields you need to filter through. We use `ransack` behind the scenes so it's essential to configure the `ransackable_attributes` list to ensure that every filterable field is incorporated within it.

:::info Filter Combination Logic
When multiple filters are applied:
- Filters on the same attribute are combined using OR conditions
- Filters on different attributes are combined using AND conditions

For example, if you have two filters on the `name` field (one for "John" and one for "Jane"), the query will find records where the name is either "John" OR "Jane". However, if you have one filter on `name` for "John" and another on `status` for "active", the query will find records where the name is "John" AND the status is "active".
:::

```ruby{4-6} [Fields]
class Avo::Resources::Project < Avo::BaseResource
  def fields
    field :name, as: :text
    field :status, as: :status, filterable: true
    field :stage, as: :badge, filterable: true
    field :country, as: :country, filterable: true
  end
end
```

Authorize ransackable_attributes
```ruby{3,11}
class Project < ApplicationRecord
  def self.ransackable_attributes(auth_object = nil)
    ["status", "stage", "country"] # the array items should be strings not symbols
  end
end

# Or authorize ALL attributes at once

class Project < ApplicationRecord
  def self.ransackable_attributes(auth_object = nil)
    authorizable_ransackable_attributes
  end
end
```

:::warning
  Ensure the array items are strings, not symbols.
:::

This will make Avo add this new "Filters" button to the <Index /> view of your resource.

When the user clicks the button, a new filters bar will appear below enabling them to add filters based on the attributes you marked as filterable.
The user can add multiple filters for the same attribute if they desire so.

## Filter types

The filter type determines the kind of input provided by the filter.

For instance, a [text](#text) type filter will render a text input field, while a [select](#select) type filter will render a dropdown menu with predefined options fetched from the field.

#### Conditions
Each filter type also offers a different set of conditions. Conditions specify how the input value should be applied to filter the data. For example, [text](#text) filters have conditions such as `Contains` or `Starts with`, while number filters include `=` (equals) or `>` (greater than).

#### Query
Avo uses the input value and the specified condition to build a Ransack query. The filter conditions and input values are translated into Ransack predicates, which are then used to fetch the filtered data.

For instance, in the text filter example above, the `Contains` condition and the input value `John` are translated into a Ransack query resulting into the SQL `LIKE` operator to find all records where the name contains `John`.

<Option name="Boolean">

### Conditions

 - Is true
 - Is false
 - Is null
 - Is not null

```ruby
{
  is_true: "Is true",
  is_false: "Is false",
  is_null: "Is null",
  is_not_null: "Is not null",
}.invert
```

<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_boolean.png" width="241" height="176" alt="" />
  <Image src="/assets/img/dynamic_filter_boolean2.png" width="241" height="192" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/users?filters[is_admin?][is_true][]=), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/user.rb#L38)
</Option>

<Option name="Date">

### Conditions

- Is
- Is not
- Is on or before
- Is on or after
- Is within
- Is null
- Is not null

```ruby
{
  is: "Is",
  is_not: "Is not",
  lte: "Is on or before",
  gte: "Is on or after",
  is_within: "Is within",
  is_null: "Is null",
  is_not_null: "Is not null",
}.invert
```

<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_date3.png" width="340" height="500" alt="" />
  <Image src="/assets/img/dynamic_filter_date2.png" width="244" height="213" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/teams?filters[created_at][lte][]=2024-07-02%2012%3A00), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/team.rb#L50)
</Option>

<Option name="Number">

### Conditions

 - `=` (equals)
 - `!=` (is different)
 - `>` (greater than)
 - `>=` (greater than or equal to)
 - `<` (lower than)
 - `<=` (lower than or equal to)
 - Is within <VersionReq version="3.10.11"/>
 - Is null
 - Is not null

```ruby
{
  is: "=",
  is_not: "!=",
  gt: ">",
  gte: ">=",
  lt: "<",
  lte: "<=",
  is_within: "Is within",
  is_null: "Is null",
  is_not_null: "Is not null",
}.invert
```

<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_number.png" width="244" height="205" alt="" />
  <Image src="/assets/img/dynamic_filter_number2.png" width="244" height="234" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/teams?filters[id][gte][]=2), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/team.rb#L27)
</Option>

<Option name="Select">

### Conditions

 - Is
 - Is not
 - Is null
 - Is not null

```ruby
{
  is: "Is",
  is_not: "Is not",
  is_null: "Is null",
  is_not_null: "Is not null",
}.invert
```

<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_select.png" width="244" height="204" alt="" />
  <Image src="/assets/img/dynamic_filter_select2.png" width="244" height="204" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/courses?filters[country][is][]=USA), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/course.rb#L55)
</Option>

<Option name="Text">

### Conditions

 - Contains
 - Does not contain
 - Is
 - Is not
 - Starts with
 - Ends with
 - Is null
 - Is not null
 - Is present
 - Is blank

```ruby
{
  contains: "Contains",
  does_not_contain: "Does not contain",
  is: "Is",
  is_not: "Is not",
  starts_with: "Starts with",
  ends_with: "Ends with",
  is_null: "Is null",
  is_not_null: "Is not null",
  is_present: "Is present",
  is_blank: "Is blank",
}.invert
```

<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_text.png" width="244" height="203" alt="" />
  <Image src="/assets/img/dynamic_filter_text2.png" width="244" height="327" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/users?filters[first_name][contains][]=Avo), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/user.rb#L33)
</Option>
<Option name="Tags">

### Conditions

 - Are
 - Contain
 - Overlap
 - Contained in ([`active_record_extended`](https://github.com/GeorgeKaraszi/ActiveRecordExtended) gem required)

 ```ruby
{
  array_is: "Are",
  array_contains: "Contain",
  array_overlap: "Overlap",
  array_contained_in: "Contained in" # (active_record_extended gem required)
}.invert
```

:::warning
Contained in will not work when using the `acts-as-taggable-on` gem.
:::
<div class="flex justify-between items-start flex-wrap">
  <Image src="/assets/img/dynamic_filter_tags.png" width="244" height="204" alt="" />
  <Image src="/assets/img/dynamic_filter_tags2.png" width="244" height="204" alt="" />
</div>

Test it on [avodemo](https://main.avodemo.com/avo/resources/courses?filters[skills][array_contains][]=), check the [source code](https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/course.rb#L46)

:::info
The source code uses custom dynamic filters DSL available <VersionReq version="3.10.0" />

Check how to do a more advanced configuration on the [custom dynamic filters](#custom-dynamic-filters) section.
:::

</Option>

## Options

You can have a few customization options available that you can add in your `avo.rb` initializer file.

```ruby
Avo.configure do |config|
  # Other Avo configurations
end

if defined?(Avo::DynamicFilters)
  Avo::DynamicFilters.configure do |config|
    config.button_label = "Advanced filters"
    config.always_expanded = true
  end
end
```

<Option name="`button_label`">

This will change the label on the expand label.
</Option>

<Option name="`always_expanded`">

You may opt-in to have them always expanded and have the button hidden.
</Option>

## Field to filter matching
On versions **lower** than <Version version="3.10.0" /> the filters are not configurable so each field will have a dedicated filter type. Check how to do a more advanced configuration on the [custom dynamic filters](#custom-dynamic-filters) section.

Field-to-filter matching in versions **lower** than <Version version="3.10.0" />:

```ruby
def field_to_filter(type)
  case type.to_sym
  when :boolean
    :boolean
  when :date, :date_time, :time
    :date
  when :id, :number, :progress_bar
    :number
  when :select, :badge, :country, :status
    :select
  when :text, :textarea, :code, :markdown, :password, :trix
    :text
  else
    :text
  end
end
```

## Caveats

At some point we'll integrate the Basic filters into the dynamic filters bar. Until then, if you have both basic and dynamic filters on your resource you'll have two `Filters` buttons on your <Index /> view.

To mitigate that you can toggle the `always_expanded` option to true.

## Custom Dynamic Filters

<BetaStatus label="Beta" />
<VersionReq version="3.10.0" />

Dynamic filters are great but strict, as each field creates a specific filter type, each with its own icon and query. The query remains static, targeting only that particular field. Since version <Version version="3.10" />, dynamic filters have become customizable and, even better, can be declared without being bound to a field.

There are two ways to define custom dynamic filters: the field's `filterable` option and the `dynamic_filter` method.

### Defining custom dynamic filters

To start customizing a dynamic filter from the `filterable` option, change its value to a hash:

```ruby
field :first_name,
  as: :text,
  filterable: true # [!code --]
  filterable: { } # [!code ++]
```

From this hash, you can configure several options specified below.

Alternatively, you can define a custom dynamic filter using the `dynamic_filter` method, which should be called inside the `filters` method:

```ruby
def filters
  # ...
  dynamic_filter :first_name
  # ...
end
```

Each option specified below can be used as a key in the hash definition or as a keyword argument in the method definition.

:::info Filters order
The filter order is computed. Dynamic filters defined by the `dynamic_filter` method will respect the definition order and will be rendered first in the filter list. Filters declared using the field's `filterable` option will be sorted by label.
:::

:::warning Custom Dynamic Filter IDs
When using a custom dynamic filter, the generated filter ID may not directly correspond to a database column. In such cases, you should use the [`query_attributes`](#query_attributes) option to specify which database columns the filter should apply to.

For example, consider a `City` model with a `population` column in the database:
```ruby
# The filter ID is custom_population
# However, the filter should apply the query to the population attribute.
dynamic_filter :custom_population, query_attributes: :population
```
:::
<Option name="`label`">

Customize filter's label

##### Default value

Field's / filter's ID humanized.

#### Possible values

Any string
</Option>

<Option name="`icon`">

Customize filter's icon. Check icons documentation

##### Default value

Boolean filter - `heroicons/outline/check-circle`<br>
Calendar filter - `heroicons/outline/calendar-days`<br>
Number filter - `heroicons/outline/hashtag`<br>
Select filter - `heroicons/outline/arrow-down-circle`<br>
Tags filter - `heroicons/outline/tag`<br>
Text filter - `avo/font`<br>

#### Possible values

Any icon from [avo](https://github.com/avo-hq/avo/tree/feature/allow_actions_to_render_turbo_streams/app/assets/svgs/avo) or [heroicons](https://heroicons.com/).
</Option>

<Option name="`type`">

Customize filter's type

##### Default value

Computed from field using [`field_to_filter` method](#field-to-filter-matching).

#### Possible values

- [`:boolean`](#boolean)<br>
- [`:date`](#date)<br>
- [`:number`](#number)<br>
- [`:select`](#select)<br>
- [`:text`](#text)<br>
- [`:tags`](#tags)<br>
</Option>

<Option name="`query`">

:::info
<VersionReq version="3.11.8" /> the default filtering system is no longer applied when a `query` is specified on a dynamic filter.
:::

Customize filter's query

##### Default value

Applies the condition to the field's attribute. For example, if the field is `first_name`, the condition is `contains`, and the value is `Bill`, the query will restrict to all records where the first name contains `Bill`.

#### Possible values

Any lambda function.

Within the function, you have access to `query` and `filter_param` as well as all attributes of `Avo::ExecutionContext`.

`filter_param` is an Avo object that stores the filter's `id`, the applied `condition` and the `value`.

Usage example:

```ruby {6-13,19-26}
# Using field's filterable option
field :first_name,
  as: :text,
  filterable: {
    # ...
    conditions: {
      case_sensitive: "Is (case sensitive)",
      not_case_sensitive: "Is (case insensitive)"
    }.invert,
    query: -> {
      case filter_param.condition.to_sym
      when :case_sensitive
        query.where("name = ?", filter_param.value)
      when :not_case_sensitive
        query.where("LOWER(name) = ?", filter_param.value.downcase)
      end
    }
    # ...
  }

# Using dynamic_filter method
dynamic_filter :first_name,
  conditions: {
    case_sensitive: "Is (case sensitive)",
    not_case_sensitive: "Is (case insensitive)"
  }.invert,
  query: -> {
    case filter_param.condition.to_sym
    when :case_sensitive
      query.where("name = ?", filter_param.value)
    when :not_case_sensitive
      query.where("LOWER(name) = ?", filter_param.value.downcase)
    end
  }
```
</Option>

<Option name="`conditions`">

Customize filter's conditions

##### Default value

Check default conditions for each filter type above on this page.

#### Possible values

A hash with the desired key-values.

Usage example:
```ruby {6-9,15-18}
# Using field's filterable option
field :first_name,
  as: :text,
  filterable: {
    # ...
    conditions: {
      case_sensitive: "Case sensitive",
      not_case_sensitive: "Not case sensitive"
    }.invert
    # ...
  }

# Using dynamic_filter method
dynamic_filter :first_name,
  conditions: {
    case_sensitive: "Case sensitive",
    not_case_sensitive: "Not case sensitive"
  }.invert
```
</Option>

<Option name="`query_attributes`">

Customize filter's query attributes

##### Default value

Field's / filter's id

#### Possible values

Any model DB column(s). Use an array of symbols for multiple columns or a single symbol for a single column. If your model has DB columns like `first_name` and `last_name`, you can combine both on a single filter:

```ruby {6,13}
# Using field's filterable option
field :name,
  as: :text,
  filterable: {
    # ...
    query_attributes: [:first_name, :last_name]
    # ...
  }

# Using dynamic_filter method
dynamic_filter :name,
  type: :text,
  query_attributes: [:first_name, :last_name]
```

You can also add query attributes for a `belongs_to` association. For example, with a model that belongs to `User`:

```ruby {7,13}
# Using field's filterable option
field :user,
  as: :belongs_to,
  filterable: {
    label: "User (email & first_name)",
    icon: "heroicons/solid/users",
    query_attributes: [:user_email, :user_first_name]
  }

# Using dynamic_filter method
dynamic_filter label: "User (email & first_name)",
  icon: "heroicons/solid/users",
  query_attributes: [:user_email, :user_first_name]
```

This is possible due to a Ransack feature. To use it, you need to add the association name before the attribute.
</Option>

<Option name="`suggestions`">

Suggestions work on filters that provide text input, enhancing the user experience by offering relevant options. This functionality is especially useful in scenarios where users might need guidance or where the filter values are numerous or complex.

##### Default value

`nil`

:::info
<VersionReq version="3.11.8" /> on `tags` fields the `suggestions` are fetched from the field.
:::

#### Possible values

- Array of strings
```ruby {6,12}
# Using field's filterable option
field :first_name,
  as: :text,
  filterable: {
    # ...
    suggestions: ["Avo", "Cado"]
    # ...
  }

# Using dynamic_filter method
dynamic_filter :first_name,
  suggestions: ["Avo", "Cado"]
```

- Proc that returns an array of strings

<VersionReq version="3.15.1" /> when the filter is applied to an association, the `parent_record` becomes accessible within the `suggestions` block.

```ruby {6,12}
# Using field's filterable option
field :first_name,
  as: :text,
  filterable: {
    # ...
    suggestions: -> { ["Avo", "Cado", params[:extra_suggestion]] }
    # ...
  }

# Using dynamic_filter method
dynamic_filter :first_name,
  suggestions: -> { ["Avo", "Cado", params[:extra_suggestion]] }
```

- Array of hashes with the keys `value`, `label` and optionally an `avatar`
<VersionReq version="3.11.8" />
:::warning Applicable only to filters with type tags.
:::

:::code-group
```ruby {6-13,19-26} [Direct assign]
# Using field's filterable option
field :tags,
  as: :tags,
  filterable: {
    # ...
    suggestions: [
      {
        value: 1,
        label: 'one',
        avatar: 'https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
      },
      # ...
    ]
    # ...
  }

# Using dynamic_filter method
dynamic_filter :tags,
  suggestions: [
    {
      value: 1,
      label: 'one',
      avatar: 'https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
    },
    # ...
  ]
```

```ruby {6-15,21-30} [Proc]
# Using field's filterable option
field :tags,
  as: :tags,
  filterable: {
    # ...
    suggestions: -> {
      [
        {
          value: 1,
          label: 'one', # or params[:something]
          avatar: 'https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
        },
        # ...
      ]
    }
    # ...
  }

# Using dynamic_filter method
dynamic_filter :tags,
  suggestions: -> {
    [
      {
        value: 1,
        label: 'one', # or params[:something]
        avatar: 'https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop',
      },
      # ...
    ]
  }
```
:::

</Option>

<Option name="`fetch_values_from`">

<VersionReq version="3.13" />

:::warning
This option is compatible **only** with `tags` filters.
:::

In some cases, you may need to retrieve values dynamically from an API. The `fetch_values_from` option allows you to provide a URL from which the filter will suggest values, functioning similarly to the `fetch_values_from` option in the tags field.

When a user searches for a record, the filter's input will send a request to the server to fetch records that match the query.

##### Default value

`nil`

:::info
If you're using a `filterable` field the `fetch_values_from` are fetched from the field.

```ruby
field :tags, as: :tags,
  fetch_values_from: -> { "/avo-filters/resources/cities/tags" }
  filterable: true
```
:::

#### Possible values

- String
```ruby
fetch_values_from: "/avo-filters/resources/cities/tags"
```

- Proc that evaluates to a string.
```ruby
fetch_values_from: -> { "/avo-filters/resources/cities/tags" }
```

The string should resolve to an endpoint that returns an array of objects with the keys `value`, `label` and optionally `avatar`.

The endpoint will receive the user input as `q` in the params. It is accessible by using `params["q"]`.

::: code-group
```ruby{3-20} [app/controllers/avo/cities_controller.rb]
class Avo::CitiesController < Avo::ResourcesController
  def tags
    # You can access the user input by using params["q"]
    render json: [
      {
        value: 1,
        label: "one",
        avatar: "https://images.unsplash.com/photo-1560363199-a1264d4ea5fc?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop"
      },
      {
        value: 2,
        label: "two",
        avatar: "https://images.unsplash.com/photo-1567254790685-6b6d6abe4689?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop"
      },
      {
        value: 3,
        label: "three",
        avatar: "https://images.unsplash.com/photo-1560765447-da05a55e72f8?ixlib=rb-1.2.1&ixid=MnwxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8&auto=format&w=256&h=256&fit=crop"
      }
    ]
  end
end
```

```ruby{5-11} [config/routes.rb]
Rails.application.routes.draw do
  # your routes...
end

if defined? ::Avo
  Avo::Engine.routes.draw do
    scope :resources do
      get "cities/tags", to: "cities#tags"
    end
  end
end
```
:::

</Option>

<Option name="`options`">

<VersionReq version="3.10.10" />

Customize the options **for select type filters**. **This is available only for select type filters** and determines the options visible in the select dropdown.

##### Default value

Fetched from field if bond to a field or `[]`

#### Possible values

An array or hash where the key-value pairs represent the options.

- If a hash is provided, the key is the option label and the value is the option value.
- If an array is provided, the array elements are used as both the option value and the option label.

##### Usage examples
###### Array
```ruby{3}
dynamic_filter :version,
  type: :select,
  options: ["Label 1", "Label 2"]
```

###### Hash (with invert)
```ruby{3-6}
dynamic_filter :version,
  type: :select,
  options: {
    value_1: "Label 1",
    value_2: "Label 2"
  }.invert
```

###### Hash (without invert)
```ruby{3-6}
dynamic_filter :version,
  type: :select,
  options: {
    "Label 1" => :value_1,
    "Label 2" => :value_2
  }
```
</Option>

## Guides & Tutorials

<Option name="How to filter associations">

Learn how to effectively filter records based on their associations in Avo. This video tutorial demonstrates how to set up and use dynamic filters to query records through the attributes of their associations, enabling powerful and flexible data filtering capabilities.

<div style="position: relative; padding-bottom: 56.25%; height: 0;"><iframe src="https://www.loom.com/embed/d8bd49086d014d77a3013796c8480339?sid=aaaec555-b19f-429b-b0a7-e998a2d2128e" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen style="position: absolute; top: 0; left: 0; width: 100%; height: 100%;"></iframe></div>
</Option>

#### `belongs_to` example

```ruby{5-11,16-18}
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  # Using field's filterable option
  def fields
    field :user,
      as: :belongs_to,
      filterable: {
        label: "User (email & first_name)",
        icon: "heroicons/solid/users",
        query_attributes: [:user_email, :user_first_name]
      }
  end

  # OR using dynamic_filter method
  def filters
    dynamic_filter label: "User (email & first_name)",
      icon: "heroicons/solid/users",
      query_attributes: [:user_email, :user_first_name]
  end
end
```

### `has_many` example

```ruby{19-22}
class Avo::Resources::Author < Avo::BaseResource
  self.record_selector = false

  def fields
    field :preview, as: :preview
    field :book_list, only_on: :preview do
      tag.div do
        tag.ul do
          safe_join(
            record.books.map do |book|
              tag.li("#{book.title} (#{book.genre})")
            end
          )
        end
      end
    end

    field :name, filterable: true
    # Filter the books by title and genre
    field :books, as: :has_many, filterable: {
      query_attributes: [:books_title, :books_genre]
    }
  end
end
```

---

# Audit Logging

Avo's Audit Logging feature provides a seamless way to track and visualize user activity and changes within your applications. It seamlessly integrates with [`paper_trail`](https://github.com/paper-trail-gem/paper_trail), offering flexible installation and customization options.

Captures user activities on Avo resources and actions, recording details such as the author and the performed event.

The installation process will automatically generate the necessary migrations, resources, and controllers that power activity tracking. Additionally [`paper_trail`](https://github.com/paper-trail-gem/paper_trail) will be installed if it is not already present in your project.

## Requirements

- `avo-advanced`

## Installation

:::info
When installing `avo-audit_logging` on an application, we strongly recommend following this documentation page step-by-step without skipping sections, as it was designed with that approach in mind.
:::

### 1. Install the gem

Start by adding the following to your `Gemfile`:

```bash
gem "avo-audit_logging", source: "https://packager.dev/avo-hq/"
```

Then
```bash
bundle install
```

### 2. Run the installer

```bash
bin/rails generate avo:audit_logging install
```

### 3. Migrate

At this stage, all migrations, resources, and controllers required for the audit logging feature are set up and ready, it's time to migrate:

```bash
bin/rails db:migrate
```

## Enable and configure audit logging

### Global enable

After installation, audit logging is disabled by default. To enable it, navigate to your `avo.rb` initializer file and update the configuration for the `Avo::AuditLogging` module.

Set `config.enabled` to `true` within this configuration.

```ruby
# config/initializers/avo.rb # [!code focus]

Avo.configure do |config|
  # ...
end

Avo::AuditLogging.configure do |config| # [!code focus]
  # config.enabled = false # [!code --] # [!code focus]
  config.enabled = true # [!code ++] # [!code focus]
  # config.author_model = "User"
end # [!code focus]
```

:::info
Setting this configuration to `false` will disable the audit logging feature entirely, overriding any other specific settings. We'll cover those specific settings in the next steps.
:::

:::warning
Setting this configuration to `false` will not prevent previously registered activity from being displayed.

To control the display behavior when this configuration is set to `false`,
you can wrap the relevant fields or tools within an `Avo::AuditLogging.configuration.enabled?` condition, like this:

```ruby{6-8}
class Avo::Resources::User < Avo::BaseResource
  def fields
    field :id, as: :id, link_to_record: true
    field :email, as: :text, link_to_record: true
    field :products, as: :has_many
    if Avo::AuditLogging.configuration.enabled?
      field :avo_authored, as: :has_many, name: "Activity"
    end
  end
end
```
:::

### Configure author models

:::info
If `User` is your only author model, you can skip this step as it will be automatically set by default.
:::

Avo must determine the potential author models to correctly establish associations in the background. This setup enables the retrieval of all activities associated with a specific author via the `avo_authored` association. To designate a model as an author, use `config.author_model`, for multiple models, utilize `config.author_models`.

```ruby
# config/initializers/avo.rb # [!code focus]

Avo.configure do |config|
  # ...
end

Avo::AuditLogging.configure do |config| # [!code focus]
  config.enabled = true

  # config.author_model = "User" # [!code --] # [!code focus]
  config.author_model = "Account" # [!code ++] # [!code focus]

  # Or for multiples models # [!code focus]
  config.author_models = ["User", "Account"] # [!code ++] # [!code focus]
end # [!code focus]
```

### Enable specific resources and actions

At this stage, the audit logging feature should be enabled, but activities are not yet being saved. By default, only resources and actions that are explicitly enabled for auditing will be tracked.

To enable audit logging for specific resources or actions, use the `self.audit_logging` class attribute.

:::code-group
```ruby [Resource]{2-4}
class Avo::Resources::Product < Avo::BaseResource # [!code focus]
  self.audit_logging = { # [!code ++] # [!code focus]
    activity: true # [!code ++] # [!code focus]
  } # [!code ++] # [!code focus]

  def fields
    field :id, as: :id, link_to_record: true
    field :name, as: :text, link_to_record: true
    field :price, as: :number, step: 1
    # ...
  end

  def actions
    action Avo::Actions::ChangePrice
  end
end # [!code focus]
```

```ruby [Action]{4-6}
class Avo::Actions::ChangePrice < Avo::BaseAction # [!code focus]
  self.name = "Change Price"

  self.audit_logging = { # [!code ++] # [!code focus]
    activity: true # [!code ++] # [!code focus]
  } # [!code ++] # [!code focus]

  def fields
    field :price, as: :number, default: -> { resource.record.price rescue nil }
  end

  def handle(query:, fields:, current_user:, resource:, **args)
    query.each do |record|
      record.update!(price: fields[:price])
    end
  end
end # [!code focus]
```
:::

All resources and actions with audit logging activity enabled are being tracked now.

But these activities aren't visible yet, right? Let's look at how to display them in the next step.

## Display logged activities

### Resource-Specific Activities

The `Avo::ResourceTools::Timeline` tool, provided by the `avo-audit_logging` gem, is designed for use in the sidebar. It offers a compact view of activities that have occurred on a specific resource, presenting them in a streamlined format:

<Image src="/assets/img/3_0/audit-logging/sidebar-activities.png" width="1915" height="719" alt="Avo compact activities on sidebar image" />

### Configuring the Sidebar for Activity Tracking

To enable this feature, configure the resource to include the resource tool in the main menu sidebar:

```ruby{7,12-15}
class Avo::Resources::Product < Avo::BaseResource # [!code focus]
  self.audit_logging = {
    activity: true
  }

  def fields # [!code focus]
    main_panel do # [!code ++] # [!code focus]
      field :id, as: :id, link_to_record: true
      field :name, as: :text, link_to_record: true
      field :price, as: :number, step: 1

      sidebar do # [!code ++] # [!code focus]
        tool Avo::ResourceTools::Timeline # [!code ++] # [!code focus]
      end # [!code ++] # [!code focus]
    end # [!code ++] # [!code focus]

    field :avo_activities, as: :has_many # [!code focus]
  end # [!code focus]

  def actions
    action Avo::Actions::ChangePrice
  end
end # [!code focus]
```

### Viewing and Navigating Activity Logs

Hovering over an entry reveals the precise timestamp in UTC. Clicking on an entry navigates to a detailed page displaying the full payload.

<Image src="/assets/img/3_0/audit-logging/hover-activities.png" width="657" height="284" alt="Hover on activity" />

### Enabling Change Logs and Reverting Changes

By default, update activities do not display a change log, and there is no way to revert changes. This is because PaperTrail has not yet been enabled on the model. To enable it, simply add `has_paper_trail` to the model:

```ruby
# app/models/product.rb # [!code focus]

class Product < ApplicationRecord # [!code focus]
  has_paper_trail # [!code ++] # [!code focus]

  belongs_to :user, optional: true

  validates_presence_of :price
end # [!code focus]
```

Once enabled, the changelog will be visible, along with an action to revert changes.

<Image src="/assets/img/3_0/audit-logging/activity-details.png" width="2010" height="1152" alt="Activity details page" />

### Troubleshooting: Missing `changeset` Field

:::warning
If the `changeset` field in the versions table consistently appears as `nil`, ensure you add the following configuration in your `application.rb` file:

```ruby
config.active_record.yaml_column_permitted_classes = [Symbol, Date, Time, ActiveSupport::TimeWithZone, ActiveSupport::TimeZone]
```
:::

### Display author logged activities

Weâ€™ve already covered how to view all activity on a specific record. Now, letâ€™s display a table within `Avo::Resources::User` to view all tracked activity for a particular user.

<Image src="/assets/img/3_0/audit-logging/authored.png" width="1921" height="754" alt="Authored table image" />

:::warning
If you're using a model other than `User`, make sure you have already [configured the author models](#configure-author-models).
:::

```ruby
class Avo::Resources::User < Avo::BaseResource # [!code focus]
  def fields # [!code focus]
    field :id, as: :id, link_to_record: true
    field :email, as: :text, link_to_record: true
    field :products, as: :has_many
    field :avo_authored, as: :has_many, name: "Activity" # [!code ++] # [!code focus]
  end # [!code focus]
end # [!code focus]
```

### Overview of all activities

We've covered how to view activities for specific records and how to view all actions made by a particular author. However, having an overview of all the activities in one place can also be useful. This can be achieved by configuring the menu to include a section with an entry for all activities.

```ruby
# config/initializers/avo.rb

Avo.configure do |config|
  config.main_menu = -> {
    section "AuditLogging", icon: "presentation-chart-bar" do # [!code ++]
      resource :avo_activity # [!code ++]
    end # [!code ++]
  }
end
```

## Disable specific actions logging

By default, when audit logging is enabled for a resource or action, all actions, such as `index` visits, `show` visits, `edit`, `update`, etc. are logged.

If you prefer not to log all of these actions, configure the `actions` key within the `self.audit_logging` class attribute.

Let's turn off `edit` and `show` logging for the `Avo::Resources::Product`:

```ruby
class Avo::Resources::Product < Avo::BaseResource # [!code focus]
  self.audit_logging = { # [!code focus]
    activity: true, # [!code focus]
    actions: { # [!code ++] # [!code focus]
      edit: false, # [!code ++] # [!code focus]
      show: false # [!code ++] # [!code focus]
    } # [!code ++] # [!code focus]
  } # [!code focus]

  def fields
    main_menu do
      field :id, as: :id, link_to_record: true
      field :name, as: :text, link_to_record: true
      field :price, as: :number, step: 1

      sidebar do
        tool Avo::ResourceTools::Timeline
      end
    end
    # ...
    field :avo_activities, as: :has_many
  end

  def actions
    action Avo::Actions::ChangePrice
  end
end # [!code focus]
```

The default value for `actions` is:

```ruby
{
  index: true,
  new: true,
  create: true,
  edit: true,
  update: true,
  show: true,
  destroy: true,
  attach: true,
  detach: true,
  handle: true
}
```

## Conclusion

With Avo's Audit Logging, you gain a powerful tool to track and visualize user actions and record changes seamlessly across your application. By carefully following the setup steps and configuring logging to fit your needs, you can establish a robust and transparent audit system, enhancing accountability and preserving data integrity.

Happy auditing!

---

# Custom pages (custom tools)

You may use custom tools to create custom sections or views to add to your app.

## Generate tools

`bin/rails generate avo:tool dashboard` will generate the necessary files to show the new custom tool.

```bash{2-6}
â–¶ bin/rails generate avo:tool dashboard
      create  app/views/avo/sidebar/items/_dashboard.html.erb
      insert  app/controllers/avo/tools_controller.rb
      create  app/views/avo/tools/dashboard.html.erb
       route  namespace :avo do
  get "dashboard", to: "tools#dashboard"
end
```

### Controller

If this is your first custom tool, a new `ToolsController` will be generated for you. Within this controller, Avo created a new method.

```ruby
class Avo::ToolsController < Avo::ApplicationController
  def dashboard
  end
end
```

You can keep this action in this controller or move it to another controller and organize it differently.

### Route

```ruby{2-4}
Rails.application.routes.draw do
  namespace :avo do
    get "dashboard", to: "tools#dashboard"
  end

  authenticate :user, ->(user) { user.admin? } do
    mount_avo
  end
end
```

The route generated is wrapped inside a namespace with the `Avo.configuration.root_path` name. Therefore, you may move it inside your authentication block next to the Avo mounting call.

### Sidebar item

The `_dashboard.html.erb` partial will be added to the `app/views/avo/sidebar/items` directory. All the files in this directory will be loaded by Avo and displayed in the sidebar. They are displayed alphabetically, so you may change their names to reorder the items.

### Customize the sidebar

If you want to customize the sidebar partial further, you can eject and update it to your liking. We're planning on creating a better sidebar customization experience later this year.

## Add assets

You might want to import assets (javascript and stylesheets files) when creating custom tools or fields. You can do that so easily from v1.3. Please follow this guide to bring your assets with your asset pipeline.

## Using helpers from your app

You'll probably want to use some of your helpers in your custom tools. To have them available inside your custom controllers inherited from Avo's `ApplicationController`, you need to include them using the `helper` method.

```ruby{3-5,10}
# app/helpers/home_helper.rb
module HomeHelper
  def custom_helper
    'hey from custom helper'
  end
end

# app/controllers/avo/tools_controller.rb
class Avo::ToolsController < Avo::ApplicationController
  helper HomeHelper

  def dashboard
    @page_title = "Dashboard"
  end
end
```

```erb{13}
# app/views/avo/tools/dashboard.html.erb
<div class="flex flex-col">
  <%= render Avo::PanelComponent.new title: 'Dashboard', display_breadcrumbs: true do |c| %>
    <% c.with_tools do %>
      <div class="text-sm italic">This is the panels tools section.</div>
    <% end %>

    <% c.with_body do %>
      <div class="flex flex-col justify-between py-6 min-h-24">
        <div class="px-6 space-y-4">
          <h3>What a nice new tool ðŸ‘‹</h3>

          <%= custom_helper %>
        </div>
      </div>
    <% end %>
  <% end %>
</div>
```

### Using path helpers

Because you're in a Rails engine, you will have to prepend the engine object to the path.

#### For Avo paths

Instead of writing `resources_posts_path(1)` you have to write `avo.resources_posts_path(1)`.

#### For the main app paths

When you want to reference paths from your main app, instead of writing `posts_path(1)`, you have to write `main_app.posts_path`.

---

# Custom fields

Avo ships with 20+ well polished and ready to be used, fields out of the box.

When you need a field that is not provided by default, Avo makes it easy to add it.

## Generate a new field

Every new field comes with three [view components](https://viewcomponent.org/), `Edit` (which is also used in the `New` view), and `Show` and `Index`. There's also a `Field` configuration file.

`bin/rails generate avo:field progress_bar` generates the files for you.

:::info
Please restart your rails server after adding a new custom field.
:::

```bash{2-9}
â–¶ bin/rails generate avo:field progress_bar
      create  app/components/avo/fields/progress_bar_field
      create  app/components/avo/fields/progress_bar_field/edit_component.html.erb
      create  app/components/avo/fields/progress_bar_field/edit_component.rb
      create  app/components/avo/fields/progress_bar_field/index_component.html.erb
      create  app/components/avo/fields/progress_bar_field/index_component.rb
      create  app/components/avo/fields/progress_bar_field/show_component.html.erb
      create  app/components/avo/fields/progress_bar_field/show_component.rb
      create  app/avo/fields/progress_bar_field.rb
```

The `ProgressBarField` file is what registers the field in your admin.

```ruby
class Avo::Fields::ProgressBarField < Avo::Fields::BaseField
  def initialize(name, **args, &block)
    super(name, **args, &block)
  end
end
```

Now you can use your field like so:

```ruby{7}
# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :progress, as: :progress_bar
  end
end
```
<Image src="/assets/img/custom-fields/progress-show.jpg" width="1046" height="180" alt="Progress custom field" />

The generated view components are basic text fields for now.

```erb{1,9,14}
# app/components/avo/fields/progress_bar_field/edit_component.html.erb
<%= edit_field_wrapper field: @field, index: @index, form: @form, resource: @resource, displayed_in_modal: @displayed_in_modal do %>
  <%= @form.text_field @field.id,
    class: helpers.input_classes('w-full', has_error: @field.model_errors.include?(@field.id)),
    placeholder: @field.placeholder,
    disabled: @field.readonly %>
<% end %>

# app/components/avo/fields/progress_bar_field/index_component.html.erb
<%= index_field_wrapper field: @field do %>
  <%= @field.value %>
<% end %>

# app/components/avo/fields/progress_bar_field/show_component.html.erb
<%= show_field_wrapper field: @field, index: @index do %>
  <%= @field.value %>
<% end %>
```

You can customize them and add as much or as little content as needed. More on customization [below](#customize-the-views).

<Option name="Use existent field template">

There may be times when you want to duplicate an existing field and start from there.

To achieve this behavior, use the `--field_template` argument and pass the original field as a value.

Now, all components will have the exact same code (except the name) as the original field.

```bash
$ bin/rails generate avo:field super_text --field_template text
      create  app/components/avo/fields/super_text_field
      create  app/components/avo/fields/super_text_field/edit_component.html.erb
      create  app/components/avo/fields/super_text_field/edit_component.rb
      create  app/components/avo/fields/super_text_field/index_component.html.erb
      create  app/components/avo/fields/super_text_field/index_component.rb
      create  app/components/avo/fields/super_text_field/show_component.html.erb
      create  app/components/avo/fields/super_text_field/show_component.rb
      create  app/avo/fields/super_text_field.rb
```

We can verify that all components have the text field code. From here there are endless possibilities to extend the original field features.

```ruby
# app/avo/fields/super_text_field.rb
module Avo
  module Fields
    class SuperTextField < BaseField
      attr_reader :link_to_record
      attr_reader :as_html
      attr_reader :protocol

      def initialize(id, **args, &block)
        super(id, **args, &block)

        add_boolean_prop args, :link_to_record
        add_boolean_prop args, :as_html
        add_string_prop args, :protocol
      end
    end
  end
end

# lib/avo/fields/text_field.rb
module Avo
  module Fields
    class TextField < BaseField
      attr_reader :link_to_record
      attr_reader :as_html
      attr_reader :protocol

      def initialize(id, **args, &block)
        super(id, **args, &block)

        add_boolean_prop args, :link_to_record
        add_boolean_prop args, :as_html
        add_string_prop args, :protocol
      end
    end
  end
end
```
</Option>

## Field options

This file is where you may add field-specific options.

 ```ruby{3-6,11-14}
# app/avo/fields/progress_bar_field.rb
class Avo::Fields::ProgressBarField < Avo::Fields::BaseField
  attr_reader :max
  attr_reader :step
  attr_reader :display_value
  attr_reader :value_suffix

  def initialize(name, **args, &block)
    super(name, **args, &block)

    @max = 100
    @step = 1
    @display_value = false
    @value_suffix = nil
  end
end
```

The field-specific options can come from the field declaration as well.

```ruby{11-14,24}
# app/avo/fields/progress_bar_field.rb
class Avo::Fields::ProgressBarField < Avo::Fields::BaseField
  attr_reader :max
  attr_reader :step
  attr_reader :display_value
  attr_reader :value_suffix

  def initialize(name, **args, &block)
    super(name, **args, &block)

    @max = args[:max] || 100
    @step = args[:step] || 1
    @display_value = args[:display_value] || false
    @value_suffix = args[:value_suffix] || nil
  end
end

# app/avo/resources/project.rb
class Avo::Resources::Project < Avo::BaseResource
  self.title = :name

  def fields
    field :id, as: :id, link_to_record: true
    field :progress, as: :progress_bar, step: 10, display_value: true, value_suffix: "%"
  end
end
```

## Field Visibility

If you need to hide the field in some view, you can use the visibility helpers.

```ruby{16}
# app/avo/fields/progress_bar_field.rb
class Avo::Fields::ProgressBarField < Avo::Fields::BaseField
  attr_reader :max
  attr_reader :step
  attr_reader :display_value
  attr_reader :value_suffix

  def initialize(name, **args, &block)
    super(name, **args, &block)

    @max = args[:max] || 100
    @step = args[:step] || 1
    @display_value = args[:display_value] || false
    @value_suffix = args[:value_suffix] || nil

    hide_on :forms
  end
end
```

## Customize the views

No let's do something about those views. Let's add a progress bar to the `Index` and `Show` views.

```erb{1,15}
# app/components/avo/fields/progress_bar_field/show_component.html.erb
<%= show_field_wrapper field: @field, index: @index do %>
  
  <% if @field.display_value %>
    <div class="text-center text-sm font-semibold w-full leading-none mb-1">
      
      <%= @field.value %><%= @field.value_suffix if @field.value_suffix.present? %>
    </div>
  <% end %>

  
  <progress max="<%= @field.max %>" value="<%= @field.value %>" class="block w-full"></progress>
<% end %>

# app/components/avo/fields/progress_bar_field/index_component.html.erb
<%= index_field_wrapper field: @field do %>
  
  <% if @field.display_value %>
    <div class="text-center text-sm font-semibold w-full leading-none mb-1">
      
      <%= @field.value %><%= @field.value_suffix if @field.value_suffix.present? %>
    </div>
  <% end %>

  
  <progress max="<%= @field.max %>" value="<%= @field.value %>" class="block w-24"></progress>
<% end %>
```

<Image src="/assets/img/custom-fields/progress-index.jpg" width="764" height="212" alt="Progress bar custom field on index" />

For the `Edit` view, we're going to do something different. We'll implement a `range` input.

```erb{1}
# app/components/avo/fields/progress_bar_field/edit_component.html.erb
<%= edit_field_wrapper field: @field, index: @index, form: @form, resource: @resource, displayed_in_modal: @displayed_in_modal do %>
  
  <% if @field.display_value %>
    <div class="text-center text-sm font-semibold w-full leading-none mb-1">
      
      <span class="js-progress-bar-value-<%= @field.id %>"><%= @field.value %></span><%= @field.value_suffix if @field.value_suffix.present? %>
    </div>
  <% end %>
  
  <%= @form.range_field @field.id,
    class: 'w-full',
    placeholder: @field.placeholder,
    disabled: @field.readonly,
    min: 0,
    # add the field-specific options
    max: @field.max,
    step: @field.step,
    %>
<% end %>

<script>
// Get the input and value elements
var input = document.getElementById('project_progress');
// Scope the selector to the current field. You might have more than one progress field on the page.
var log = document.querySelector('.js-progress-bar-value-<%= @field.id %>');

// Add an event listener for when the input is updated
input.addEventListener('input', updateValue);

// Update the value element with the value from the input
function updateValue(e) {
  log.textContent = e.target.value;
}
</script>
```
<Image src="/assets/img/custom-fields/progress-edit.jpg" width="1144" height="182" alt="Progress bar custom field edit" />

## Field assets

Because there isn't just one standardized way of handling assets in Rails, we decided we won't provide **asset loading** support for custom fields for now. That doesn't mean that you can't use custom assets (javascript or CSS files), but you will have to load them in your own pipeline in dedicated Avo files.

In the example above, we added javascript on the page just to demonstrate the functionality. In reality, you might add that to a stimulus controller inside your own Avo dedicated pipeline (webpacker or sprockets).

Some styles were added in the asset pipeline directly.
```css
progress {
  @apply h-2 bg-white border border-gray-400 rounded shadow-inner;
}
progress[value]::-webkit-progress-bar {
  @apply bg-white border border-gray-500 rounded shadow-inner;
}
progress[value]::-webkit-progress-value{
  @apply bg-green-600 rounded;

}
progress[value]::-moz-progress-bar {
  @apply bg-green-600 rounded appearance-none;
}
```

## Use pre-built Stimulus controllers

Avo ships with a few Stimulus controllers that help you build more dynamic fields.

### Hidden input controller

This controller allows you to hide your content and add a trigger to show it. You'll find it in the Trix field.

<Image src="/assets/img/stimulus/hidden_input_trix.gif" width="1000" height="272" alt="Hidden input controller" />

You should add the `:always_show` `attr_reader` and `@always_show` instance variables to your field.

```ruby{3,8}
# app/avo/fields/color_picker_field.rb
class Avo::Fields::ColorPickerField < Avo::Fields::BaseField
  attr_reader :always_show

  def initialize(id, **args, &block)
    super(id, **args, &block)

    @always_show = args[:always_show] || false
    @allow_non_colors = args[:allow_non_colors]
  end
end
```

Next, in your fields `Show` component, you need to do a few things.

1. Wrap the field inside a controller tag
1. Add the trigger that will show the content.
1. Wrap the value in a div with the `hidden` class applied if the condition `@field.always_show` is `false`.
1. Add the `content` target (`data-hidden-input-target="content"`) to that div.

```erb{4-7,8}
# app/components/avo/fields/color_picker_field/show_component.html.erb

<%= show_field_wrapper field: @field, index: @index do %>
  <div data-controller="hidden-input">
    <% unless @field.always_show %>
      <%= link_to t('avo.show_content'), 'javascript:void(0);', class: 'font-bold inline-block', data: { action: 'click->hidden-input#showContent' } %>
    <% end %>
    <div <% unless @field.always_show %> class="hidden" <% end %> data-hidden-input-target="content">
      <div style="background-color: <%= @field.value %>"
        class="h-6 px-1 rounded-md text-white text-sm flex items-center justify-center leading-none"
      >
        <%= @field.value %>
      </div>
    </div>
  </div>
<% end %>
```

<Image src="/assets/img/stimulus/hidden_input_color.gif" width="1000" height="76" alt="Hidden input controller" />

### Non existing model field

To ensure proper rendering of a custom field that lacks getters and setters at the model level, you must implement these methods within the model.

```ruby
  def custom_field
  end

  def custom_field=(value)
  end
```

---

# Custom errors

Actions such as create, update, attach, etc... will not be completed if the record contains any errors. This ensures that only valid data is processed and saved, maintaining the integrity of your application. Custom validations can be added to your models to enforce specific rules and provide meaningful error messages to users.

## Adding Custom Errors

To add custom errors, you can define a validation method in your model. If the validation fails it adds an error to the record. These errors will prevent the action from completing and will be displayed as notifications to the user.

## In a Simple Record

Consider a simple `User` model where you want to enforce a custom validation rule, such as ensuring that the user's age is over a certain value.

```ruby
# app/models/user.rb
class User < ApplicationRecord
  validate :age_must_be_over_18

  private

  def age_must_be_over_18
    # Add a custom error to the record if age is less than 18.
    if age < 18
      errors.add(:age, "must be over 18.")
    end
  end
end
```

In this example, the `age_must_be_over_18` method checks if the user's age is less than 18. If so, it adds an error to the `age` attribute with a custom message. This error prevents any further Avo action on the record and notifies the user of the issue.

## In a Join Table

Consider a join table `TeamMembership` which links `Team` and `User` models. You might want to add a custom validation to ensure some business logic is enforced.

```ruby
# app/models/team_membership.rb
class TeamMembership < ApplicationRecord
  belongs_to :team
  belongs_to :user

  validate :custom_validation

  private

  def custom_validation
    if user.banned?
      errors.add(:user, "is banned.")
    end
  end
end
```

In this example, the `custom_validation` method is called whenever a `TeamMembership` record is validated. If the conditions in this method are not met, an error is added to the `user` attribute with a custom message. This error prevents any further Avo action on the record and notifies the user of the issue.

---

# Resource tools

Similar to adding custom fields to a resource, you can add custom tools. A custom tool is a partial added to your resource's `Show` and `Edit` views.

## Generate a resource tool

Run `bin/rails generate avo:resource_tool post_info`. That will create two files. The configuration file `app/avo/resource_tools/post_info.rb` and the partial file `app/views/avo/resource_tools/_post_info.html.erb`.

The configuration file holds the tool's name and the partial path if you want to override it.

```ruby
class Avo::ResourceTools::PostInfo < Avo::BaseResourceTool
  self.name = "Post info"
  # self.partial = "avo/resource_tools/post_info"
end
```

The partial is ready for you to customize further.

```erb
<div class="flex flex-col">
  <%= render Avo::PanelComponent.new title: "Post info" do |c| %>
    <% c.with_tools do %>
      <%= a_link('/avo', icon: 'heroicons/solid/academic-cap', style: :primary) do %>
        Dummy link
      <% end %>
    <% end %>

    <% c.with_body do %>
      <div class="flex flex-col p-4 min-h-24">
        <div class="space-y-4">
          <h3>ðŸª§ This partial is waiting to be updated</h3>

          <p>
            You can edit this file here <code class="p-1 rounded bg-gray-500 text-white text-sm">app/views/avo/resource_tools/post_info.html.erb</code>.
          </p>

          <p>
            The resource tool configuration file should be here <code class="p-1 rounded bg-gray-500 text-white text-sm">app/avo/resource_tools/post_info.rb</code>.
          </p>

          <%
            # In this partial, you have access to the following variables:
            # tool
            # @resource
            # @resource.model
            # form (on create & edit pages. please check for presence first)
            # params
            # Avo::Current.context
            # current_user
          %>
        </div>
      </div>
    <% end %>
  <% end %>
</div>
```

<Image src="/assets/img/resource-tools/resource-tool-partial.png" width="2034" height="470" alt="Avo resource tool partial" />

## Partial context

You might need access to a few things in the partial.

You have access to the `tool`, which is an instance of your tool `PostInfo`, and the `@resource`, which holds all the information about that particular resource (`view`, `model`, `params`, and others), the `params` of the request, the `Avo::Current.context` and the `current_user`.
That should give you all the necessary data to scope out the partial content.

## Tool visibility

The resource tool is default visible on the `Show` view of a resource. You can change that using the visibility options (`show_on`, `only_on`).

```ruby
# app/avo/resources/post.rb
class Avo::Resources::Post < Avo::BaseResource
  def fields
    tool Avo::ResourceTools::PostInfo, show_on: :edit
  end
end
```

### Using path helpers

Because you're in a Rails engine, you will have to prepend the engine object to the path.

#### For Avo paths

Instead of writing `resources_posts_path(1)` you have to write `avo.resources_posts_path(1)`.

#### For the main app paths

When you want to reference paths from your main app, instead of writing `posts_path(1)`, you have to write `main_app.posts_path`.

## Add custom fields on forms

**From Avo 2.12**

You might want to add a few more fields or pieces of functionality besides the CRUD-generated fields on your forms. Of course, you can already create new custom fields to do it in a more structured way, but you can also use a resource tool to achieve more custom behavior.

You have access to the `form` object that is available on the new/edit pages on which you can attach inputs of your choosing. You can even achieve nested form functionality.

You have to follow three steps to enable this functionality:

1. Add the inputs in a resource tool and enable the tool on the form pages
2. Tell Avo which `params` it should permit to write to the model
3. Make sure the model is equipped to receive the params

In the example below, we'll use the `Avo::Resources::Fish`, add a few input fields (they will be a bit unstyled because this is not the scope of the exercise), and do some actions with some of them.

We first need to generate the tool with `bin/rails g avo:resource_tool fish_information` and add the tool to the resource file.

```ruby{3}
class Avo::ResourcesFish < Avo::BaseResource
  def fields
    tool Avo::ResourceTools::FishInformation, show_on: :forms
  end
end
```

In the `_fish_information.html.erb` partial, we'll add a few input fields. Some are directly on the `form`, and some are nested with `form.fields_for`.

The fields are:

- `fish_type` as a text input
- `properties` as a multiple text input which will produce an array in the back-end
- `information` as nested inputs which will produce a `Hash` in the back-end

```erb{13-36}

<div class="flex flex-col">
  <%= render Avo::PanelComponent.new(title: @resource.model.name) do |c| %>
    <% c.with_tools do %>
      <%= a_link('/admin', icon: 'heroicons/solid/academic-cap', style: :primary) do %>
        Primary
      <% end %>
    <% end %>

    <% c.with_body do %>
      <div class="flex flex-col p-4 min-h-24">
        <div class="space-y-4">
          <% if form.present? %>
            <%= form.label :fish_type %>
            <%= form.text_field :fish_type, value: 'default type of fish', class: input_classes %>
            <br>

            <%= form.label :properties %>
            <%= form.text_field :properties, multiple: true, value: 'property 1', class: input_classes %>
            <%= form.text_field :properties, multiple: true, value: 'property 2', class: input_classes %>
            <br>

            <% form.fields_for :information do |information_form| %>
              <%= form.label :information_name %>
              <%= information_form.text_field :name, value: 'information name', class: input_classes %>
              <div class="text-gray-600 mt-2 text-sm">This is going to be passed to the model</div>
              <br>
              <%= form.label :information_history %>
              <%= information_form.text_field :history, value: 'information history', class: input_classes %>
              <div class="text-gray-600 mt-2 text-sm">This is going to be passed to the model</div>
              <br>
              <%= form.label :information_age %>
              <%= information_form.text_field :age, value: 'information age', class: input_classes %>
              <div class="text-gray-600 mt-2 text-sm">This is NOT going to be passed to the model</div>
            <% end %>
          <% end %>
        </div>
      </div>
    <% end %>
  <% end %>
</div>
```

Next, we need to tell Avo and Rails which params are welcomed in the `create`/`update` request. We do that using the `extra_params` option on the `Avo::Resources::Fish`. Avo's internal implementation is to assign the attributes you specify here to the underlying model (`model.assign_attributes params.permit(extra_params)`).

```ruby{2}
class Avo::Resources::Fish < Avo::BaseResource
  self.extra_params = [:fish_type, :something_else, properties: [], information: [:name, :history]]

  def fields
    tool Avo::ResourceTools::FishInformation, show_on: :forms
  end
end
```

The third step is optional. You must ensure your model responds to the params you're sending. Our example should have the `fish_type`, `properties`, and `information` attributes or setter methods on the model class. We chose to add setters to demonstrate the params are called to the model.

```ruby
class Fish < ApplicationRecord
  self.inheritance_column = nil # required in order to use the type DB attribute

  def fish_type=(value)
    self.type = value
  end

  def properties=(value)
    # properties should be an array
    puts ["properties in the Fish model->", value].inspect
  end

  def information=(value)
    # properties should be a hash
    puts ["information in the Fish model->", value].inspect
  end
end
```

If you run this code, you'll notice that the `information.information_age` param will not reach the `information=` method because we haven't allowed it in the `extra_params` option.

## Where to add logic

It's a good practice not to keep login in view files (partials).
You can hide that logic inside the tool using instance variables and methods, and access it in the partial using the `tool` variable.

[Here's an example](https://github.com/avo-hq/main.avodemo.com/commit/c8ecb9b53a770103a993df4c2b3acec0a1faf737) on how you could do that.

```ruby{8,10}
class Avo::ResourceTools::PostInfo < Avo::BaseResourceTool
  self.name = "Post info"
  # self.partial = "avo/resource_tools/post_info"

  attr_reader :foo

  def initialize(**kwargs)
    super **kwargs # It's important to call super with the same keyword arguments

    # You'll have access to the following objects:
    # resource - when attached to a resource
    # parent - which is the object it's attached to (resource if attached to a resource)
    # view

    @foo = :bar # Add your variables
  end

  def custom_method_call
    :called
  end
end
```

```erb{7,12}
<div class="flex flex-col">
  <%= render Avo::PanelComponent.new title: "Post info" do |c| %>

    <% c.with_body do %>
      <p>
        This variable was declared in the initializer:
        <%= tool.foo %>
      </p>

      <p>
        This is a method called on the tool:
        <%= tool.custom_method_call %>
      </p>
    <% end %>
  <% end %>
</div>
```

---

# Stimulus JS & HTML attributes

:::warning
This feature is in the **beta** phase. The API might change while seeing how the community uses it to build their apps.
This is not the **dependable fields** feature but a placeholder so we can observe and see what we need to ship to make it helpful to you.
:::

_What we'll be able to do at the end of reading these docs_

<Image src="/assets/img/stimulus/country-city-select.gif" width="800" height="344" alt="Debug on input stimulus method" />

:::info
**Please note** that in order to have the JS code from your controllers loaded in Avo you'll need to add your asset pipeline using these instructions. It's really easier than it sounds. It's like you'd add a new JS file to your regular Rails app.
:::

<hr>

One of the most requested features is the ability to make the forms more dynamic. We want to bring the first iteration of this feature through Stimulus JS integration.
This light layer will allow you to hook into the views and inject your functionality with Stimulus JS.

You'll be able to add your Stimulus controllers to the resource views (`Index`, `Show`, `Edit`, and `New`), attach `classes`, `style`, and `data` attributes to the fields and inputs in different views.

## Assign Stimulus controllers to resource views

To enable a stimulus controller to resource view, you can use the `stimulus_controllers` option on the resource file.

```ruby
class Avo::Resources::Course < Avo::BaseResource
  self.stimulus_controllers = "course-resource"
end
```

You can add more and separate them by a space character.

```ruby
class Avo::Resources::Course < Avo::BaseResource
  self.stimulus_controllers = "course-resource select-field association-fields"
end
```

Avo will add a `resource-[VIEW]` (`resource-edit`, `resource-show`, or `resource-index`) controller for each view.

### Field wrappers as targets

By default, Avo will add stimulus target data attributes to all field wrappers. The notation scheme uses the name and field type `[FIELD_NAME][FIELD_TYPE]WrapperTarget`.

```ruby
# Wrappers get the `data-[CONTROLLER]-target="nameTextWrapper"` attribute and can be targeted using nameTextWrapperTarget
field :name, as: :text

# Wrappers get the `data-[CONTROLLER]-target="createdAtDateTimeWrapper"` attribute and can be targeted using createdAtDateTimeWrapperTarget
field :created_at, as: :date_time

# Wrappers get the `data-[CONTROLLER]-target="hasSkillsTagsWrapper"` attribute and can be targeted using hasSkillsTagsWrapperTarget
field :has_skills, as: :tags
```

For example for the following stimulus controllers `self.stimulus_controllers = "course-resource select-field association-fields"` Avo will generate the following markup for the `has_skills` field above on the `edit` view.

```html{4-7}
<div class="relative flex flex-col md:flex-row md:items-center pb-2 md:pb-0 leading-tight min-h-14" data-field-id="has_skills" data-field-type="boolean" data-resource-edit-target="hasSkillsBooleanWrapper" data-course-resource-target="hasSkillsBooleanWrapper" data-select-field-target="hasSkillsBooleanWrapper" data-association-fields-target="hasSkillsBooleanWrapper">
  
</div>
```

You can add those targets to your controllers and use them in your JS code.

### Field inputs as targets

Similar to the wrapper element, inputs in the `Edit` and `New` views get the `[FIELD_NAME][FIELD_TYPE]InputTarget`. On more complex fields like the searchable, polymorphic `belongs_to` field, where there is more than one input, the target attributes are attached to all `input`, `select`, and `button` elements.

```ruby
# Inputs get the `data-[CONTROLLER]-target="nameTextInput"` attribute and can be targeted using nameTextInputTarget
field :name, as: :text

# Inputs get the `data-[CONTROLLER]-target="createdAtDateTimeInput"` attribute and can be targeted using createdAtDateTimeInputTarget
field :created_at, as: :date_time

# Inputs get the `data-[CONTROLLER]-target="hasSkillsTagsInput"` attribute and can be targeted using hasSkillsTagsInputTarget
field :has_skills, as: :tags
```

### All controllers receive the `view` value

All stimulus controllers receive the `view` attribute in the DOM.

```html{4-5}
<div class="space-y-12" data-model-id="280" data-controller="resource-edit course-resource" data-resource-edit-view-value="edit" data-course-resource-view-value="edit">
  
</div>
```

Now you can use that inside your Stimulus JS controller like so:

```js{5,9}
import { Controller } from '@hotwired/stimulus'

export default class extends Controller {
  static values = {
    view: String,
  }

  async connect() {
    console.log('view ->', this.viewValue)
  }
}
```

The possible values are `index`, `show`, `edit`, or `new`

## Assign Stimulus controllers to actions

Similarly as to resource, you can assign stimulus controller to an action. To do that you can use the `stimulus_controllers` option on the action file.

```ruby
class Avo::Actions::ShowCurrentTime < Avo::BaseAction
  self.stimulus_controllers = "city-in-country"
end
```

You can add more and separate them by a space character.

```ruby
class Avo::Actions::ShowCurrentTime < Avo::BaseAction
  self.stimulus_controllers = "course-resource select-field association-fields"
end
```

The same way as for the resources, Avo will add stimulus target data attributes to [all field wrappers](#field-wrappers-as-targets) and [all input fields](#field-inputs-as-targets).

Unlike with the resource, Avo will not add a specific default controller for each type of the view (`index`, `show`, `edit`).
Same way, the controllers will not receive the `view` attribute in the DOM, [as in case of resources](#all-controllers-receive-the-view-value).

## Attach HTML attributes

This section has moved.

## Composing the attributes together

You can use the attributes together to make your fields more dynamic.

```ruby{3-9}
  field :has_skills, as: :boolean, html: {
    edit: {
      input: {
        data: {
          # On click run the toggleSkills method on the toggle-fields controller
          action: "input->toggle-fields#toggleSkills",
        }
      }
    }
  }
  field :skills, as: :tags, html: {
    edit: {
      wrapper: {
        # hide this field by default
        classes: "hidden"
      }
    }
  }
```

```js
// toggle_fields_controller.js
import { Controller } from "@hotwired/stimulus";

export default class extends Controller {
  static targets = ["skillsTagsWrapper"]; // use the target Avo prepared for you

  toggleSkills() {
    this.skillsTagsWrapperTarget.classList.toggle("hidden");
  }
}
```

## Pre-made stimulus methods

Avo ships with a few JS methods you may use on your resources.

### `resource-edit#toggle`

On your `Edit` views, you can use the `resource-edit#toggle` method to toggle the field visibility from another field.

```ruby{5-7}
field :has_country, as: :boolean, html: {
  edit: {
    input: {
      data: {
        action: "input->resource-edit#toggle", # use the pre-made stimulus method on input
        resource_edit_toggle_target_param: "countrySelectWrapper", # target to be toggled
        # resource_edit_toggle_targets_param: ["countrySelectWrapper"] # add more than one target
      }
    }
  }
}
field :country, as: :select, options: Course.countries.map { |country| [country, country] }.to_h
```

<Image src="/assets/img/stimulus/toggle-method.gif" width="800" height="421" alt="Toggle method" />

### `resource-edit#disable`

Disable works similarly to toggle, with the difference that it disables the field instead of hiding it.

```ruby{5-7,16}
field :has_skills, as: :boolean, html: {
  edit: {
    input: {
      data: {
        action: "input->resource-edit#disable", # use the pre-made stimulus method on input
        resource_edit_disable_target_param: "countrySelectInput", # target to be disabled
        # resource_edit_disable_targets_param: ["countrySelectWrapper"] # add more than one target to disable
      }
    }
  }
}
field :country, as: :select, options: Course.countries.map { |country| [country, country] }.to_h
```

<Image src="/assets/img/stimulus/disable-method.gif" width="800" height="421" alt="Disable method" />

You may also target the `wrapper` element for that field if the target field has more than one input like the searchable polymorphic `belongs_to` field.

```ruby{6}
field :has_skills, as: :boolean, html: {
  edit: {
    input: {
      data: {
        action: "input->resource-edit#disable", # use the pre-made stimulus method on input
        resource_edit_disable_target_param: "countrySelectWrapper", # target the wrapper so all inputs are disabled
        # resource_edit_disable_targets_param: ["countrySelectWrapper"] # add more than one target to disable
      }
    }
  }
}
field :country, as: :select, options: Course.countries.map { |country| [country, country] }.to_h
```

### `resource-edit#debugOnInput`

For debugging purposes only, the `resource_edit` Stimulus JS controller provides the `debugOnInput` method that outputs the event and value for an action to the console. Use this just to make sure you targeted your fields correctly. It doesn't have any real use.

<Image src="/assets/img/stimulus/debug-on-input.gif" width="800" height="261" alt="Debug on input stimulus method" />

## Custom Stimulus controllers

<DemoVideo demo-video="https://youtu.be/ZMOz22FaAUg?t=1127" />

:::info Check the source code
If you visit our demo website on the [course edit page](https://main.avodemo.com/avo/resources/courses/1/edit) you can see this in action.

- Demo of the feature in action <br>
https://main.avodemo.com/avo/resources/courses/1/edit
- JS controller that does that change <br>
https://github.com/avo-hq/main.avodemo.com/blob/main/app/javascript/controllers/course_controller.js
- Rails controller that returns the results <br>
https://github.com/avo-hq/main.avodemo.com/blob/main/app/controllers/avo/courses_controller.rb#L3
- Stimulus action that triggers the update <br>
https://github.com/avo-hq/main.avodemo.com/blob/main/app/avo/resources/course.rb#L68
:::

The bigger purpose of this feature is to create your own Stimulus JS controllers to bring the functionality you need to the CRUD interface.

Below is an example of how you could implement a city & country select feature where the city select will have its options changed when the user selects a country:

1. Add an action to the country select to trigger a change.
1. The stimulus method `onCountryChange` will be triggered when the user changes the country.
1. That will trigger a fetch from the server where Rails will return an array of cities for the provided country.
1. The city field will have a `loading` state while we fetch the results.
1. The cities will be added to the `city` select field
1. If the initial value is present in the returned results, it will be selected.
1. All of this will happen only on the `New` and `Edit` views because of the condition we added to the `connect` method.

::: code-group

```ruby [app/avo/resources/course.rb]
# app/avo/resources/course.rb
class Avo::Resources::Course < Avo::BaseResource
  self.stimulus_controllers = "course-resource"

  def fields
    field :id, as: :id
    field :name, as: :text
    field :country, as: :select, options: Course.countries.map { |country| [country, country] }.to_h, html: {
      edit: {
        input: {
          data: {
            course_resource_target: "countryFieldInput", # Make the input a target
            action: "input->course-resource#onCountryChange" # Add an action on change
          }
        }
      }
    }
    field :city, as: :select, options: Course.cities.values.flatten.map { |city| [city, city] }.to_h, html: {
      edit: {
        input: {
          data: {
            course_resource_target: "cityFieldInput" # Make the input a target
          }
        }
      }
    }
  end
end
```

```ruby{4-6} [config/routes.rb]
Rails.application.routes.draw do
  if defined? ::Avo
    Avo::Engine.routes.draw do
      scope :resources do
        get "courses/cities", to: "courses#cities"
      end
    end
  end
end
```

```ruby{3} [app/controllers/avo/courses_controller.rb]
class Avo::CoursesController < Avo::ResourcesController
  def cities
    render json: get_cities(params[:country]) # return an array of cities based on the country we received
  end

  private

  def get_cities(country)
    return [] unless Course.countries.include?(country)

    Course.cities[country.to_sym]
  end
end
```

```ruby [app/models/course.rb]
class Course < ApplicationRecord
  def self.countries
    ["USA", "Japan", "Spain", "Thailand"]
  end

  def self.cities
    {
      USA: ["New York", "Los Angeles", "San Francisco", "Boston", "Philadelphia"],
      Japan: ["Tokyo", "Osaka", "Kyoto", "Hiroshima", "Yokohama", "Nagoya", "Kobe"],
      Spain: ["Madrid", "Valencia", "Barcelona"],
      Thailand: ["Chiang Mai", "Bangkok", "Phuket"]
    }
  end
end
```

```js [course_resource_controller.js]
import { Controller } from "@hotwired/stimulus";

const LOADER_CLASSES = "absolute bg-gray-100 opacity-10 w-full h-full";

export default class extends Controller {
  static targets = ["countryFieldInput", "cityFieldInput", "citySelectWrapper"];

  static values = {
    view: String,
  };

  // Te fields initial value
  static initialValue;

  get placeholder() {
    return this.cityFieldInputTarget.ariaPlaceholder;
  }

  set loading(isLoading) {
    if (isLoading) {
      // create a loader overlay
      const loadingDiv = document.createElement("div");
      loadingDiv.className = LOADER_CLASSES;
      loadingDiv.dataset.target = "city-loader";

      // add the loader overlay
      this.citySelectWrapperTarget.prepend(loadingDiv);
      this.citySelectWrapperTarget.classList.add("opacity-50");
    } else {
      // remove the loader overlay
      this.citySelectWrapperTarget
        .querySelector('[data-target="city-loader"]')
        .remove();
      this.citySelectWrapperTarget.classList.remove("opacity-50");
    }
  }

  async connect() {
    // Add the controller functionality only on forms
    if (["edit", "new"].includes(this.viewValue)) {
      this.captureTheInitialValue();

      // Trigger the change on load
      await this.onCountryChange();
    }
  }

  // Read the country select.
  // If there's any value selected show the cities and prefill them.
  async onCountryChange() {
    if (this.hasCountryFieldInputTarget && this.countryFieldInputTarget) {
      // Get the country
      const country = this.countryFieldInputTarget.value;
      // Dynamically fetch the cities for this country
      const cities = await this.fetchCitiesForCountry(country);

      // Clear the select of options
      Object.keys(this.cityFieldInputTarget.options).forEach(() => {
        this.cityFieldInputTarget.options.remove(0);
      });

      // Add blank option
      this.cityFieldInputTarget.add(new Option(this.placeholder));

      // Add the new cities
      cities.forEach((city) => {
        this.cityFieldInputTarget.add(new Option(city, city));
      });

      // Check if the initial value is present in the cities array and select it.
      // If not, select the first item
      const currentOptions = Array.from(this.cityFieldInputTarget.options).map(
        (item) => item.value
      );
      if (currentOptions.includes(this.initialValue)) {
        this.cityFieldInputTarget.value = this.initialValue;
      } else {
        // Select the first item
        this.cityFieldInputTarget.value =
          this.cityFieldInputTarget.options[0].value;
      }
    }
  }

  // Private

  captureTheInitialValue() {
    this.initialValue = this.cityFieldInputTarget.value;
  }

  async fetchCitiesForCountry(country) {
    if (!country) {
      return [];
    }

    this.loading = true;

    const response = await fetch(
      `${window.Avo.configuration.root_path}/resources/courses/cities?country=${country}`
    );
    const data = await response.json();

    this.loading = false;

    return data;
  }
}
```

:::

This is how the fields behave with this Stimulus JS controller.

<Image src="/assets/img/stimulus/country-city-select.gif" width="800" height="344" alt="Debug on input stimulus method" />

## Use Stimulus JS in a tool

There are a few steps you need to take in order to register the Stimulus JS controller in the current app context.

First, you need to have a JS entrypoint (ex: `avo.custom.js`) and have that loaded in the `_head` partial. For instructions on that please follow these steps to add it to your app (`importmaps` or `esbuild`).

### Set up a controller

```js
// app/javascript/controllers/sample_controller.js
import { Controller } from "@hotwired/stimulus";

export default class extends Controller {
  connect() {
    console.log("Hey from sample controller ðŸ‘‹");
  }
}
```

### Register that controller with the current Stimulus app

```js
// app/javascript/avo.custom.js
import SampleController from "controllers/sample_controller";

// Hook into the stimulus instance provided by Avo
const application = window.Stimulus;
application.register("course-resource", SampleController);

// eslint-disable-next-line no-console
console.log("Hi from Avo custom JS ðŸ‘‹");
```

### Use the controller in the Avo tool

```erb

<div data-controller="sample">
  
</div>
```

Done ðŸ™Œ Now you have a controller connecting to a custom Resource tool or Avo tool (or Avo views).

## StimulusJS in actions

Currently, Avo doesn't support the use of StimulusJS in the same manner in action modals. Please follow [this](https://github.com/avo-hq/avo/issues/2811) issue to get updates on when it will be available.

This is not very prio on our near roadmap, but we will take a contribution in the form of a PR or a sponsorship in order to prioritize it on our end.

---

# Custom asset pipeline

Avo plays well with most Rails asset pipelines.

| Asset pipeline | Avo compatibility |
|---------------|------------|
| [importmap](https://github.com/rails/importmap-rails) | âœ… Fully supported |
| [Propshaft](https://github.com/rails/propshaft)       | âœ… Fully supported |
| [Sprockets](https://github.com/rails/sprockets)       | âœ… Fully supported |
| [Webpacker](https://github.com/rails/webpacker)       | ðŸ›» Only with Sprockets or Propshaft |

There are two things we need to mention when communicating about assets.

1. Avo's assets
2. You custom assets

## Avo's assets

We chose to impact your app, and your deploy processes as little as possible. That's why we bundle up Avo's assets when we publish on [rubygems](https://rubygems.org/gems/avo), so you don't have to do anything else when you deploy your app. Avo doesn't require a NodeJS, or any kind of any other special environment in your deploy process.

Under the hood Avo uses TailwindCSS 3.0 with the JIT engine and bundles the assets using [`jsbundling`](https://github.com/rails/jsbundling-rails) with `esbuild`.

## Exclude servings Avo assets from a CDN?
If you utilize a Content Delivery Network (CDN) for serving assets and you want to exclude Avo paths from the default asset host you may use the following code snippet.

```ruby
config.action_controller.asset_host = Proc.new do |source|
  # Exclude assets under the "/avo" path from CDN
  next nil if source.start_with?("/avo")

  # Set the general asset host (CDN) using an environment variable
  ENV.fetch("ASSET_HOST")
end
```

This configuration ensures that assets are served through the specified CDN, except for those under the `/avo` path. Adjust the paths and environment variable as needed for your application.

## Your custom assets

Avo makes it easy to use your own styles and javascript through your already set up asset pipeline. It just hooks on to it to inject the new assets to be used in Avo.

## Use TailwindCSS utility classes

Please follow the dedicated TailwindCSS integration guide.

## Add custom JS code and Stimulus controllers

There are more ways of dealing with JS assets, and Avo handles that well.

## Use Importmap to add your assets

Importmap has become the default way of dealing with assets in Rails 7. For you to start using custom JS assets with Avo and importmap you should run this install command `bin/rails generate avo:js:install`. That will:

- create your `avo.custom.js` file as your JS entrypoint;
- add it to the `app/views/avo/partials/_head.html.erb` partial so Avo knows to load it;
- pin it in your `importmap.rb` file so `importmap-rails` knows to pick it up.

## Use `js-bundling` with `esbuild`

`js-bundling` gives you a bit more flexibility and power when it comes to assets. We use that under the hood and we'll use it to expose your custom JS assets.

When you install `js-bundling` with `esbuild` you get this npm script `"build": esbuild app/javascript/*.* --bundle --sourcemap --outdir=app/assets/builds --public-path=assets`. That script will take all your JS entrypoint files under `app/javascript` and bundle them under `assets/builds`.

```bash
bin/rails generate avo:js:install --bundler esbuild
```

That command will:

- eject the `_head.html.erb` file;
- add the `avo.custom.js` asset to it;
- create the `avo.custom.js` file under `app/javascript` which will be your entrypoint.

That will be picked up by the `build` script and create it's own `assets/builds/avo.custom.js` file that will, in turn, be picked up by sprockets or propshaft and loaded into your app.

## Use `js-bundling` with `rollup` or `webpack`

Avo supports the other bundlers too but we just don't have a generator command to configure them for you. If you use the other bundlers and have configured them to use custom assets, then please [open up a PR](https://github.com/avo-hq/avo) and help the community get started faster.

## Manually add your CSS and JS assets

In order to manually add your assets you have to eject the `_pre_head.html.erb` partial (`bin/rails generate avo:eject --partial :pre_head`), create the asset files (examples below), and add the asset files from your pipeline to the `_pre_head` partial. Then, your asset pipeline will pick up those assets and use add them to your app.

:::warning
You should add your custom styles to `_pre_head.html.erb`, versus `_head.html.erb` to avoid overriding Avo's default styles. This

The order in which Avo loads the partials and asset files is this one:

1. `_pre_head.html.erb`
2. Avo's CSS and JS assets
3. `_head.html.erb`
:::

<Image src="/assets/img/asset-pipeline.jpg" width="2258" height="1874" alt="Avo and the asset pipeline" />

### Sprockets and Propshaft

Create `avo.custom.js` to the `app/javascripts` directory and `avo.custom.css` to `app/assets/stylesheets` with the desired scripts and styles.
Then add them to Avo using the `_pre_head.html.erb` partial (`rails generate avo:eject --partial :pre_head`).

```erb
# app/views/avo/partials/_pre_head.html.erb

<%= javascript_include_tag 'avo.custom', defer: true %>
<%= stylesheet_link_tag 'avo.custom', media: 'all' %>
```

:::warning
Please ensure that when using `javascript_include_tag` you add the `defer: true` option so the browser will use the same loading strategy as Avo's and the javascript files are loaded in the right order.
:::

### Webpacker

:::warning
We removed support for webpacker. In order to use Avo with your assets you must install Sprockets or Propshaft in order to serve assets like SVG, CSS, or JS files.
:::

:::info
Instructions below are for Webpacker version 6. Version 5 has different paths (`app/javascript/packs`).
:::

Create `avo.custom.js` and `avo.custom.css` inside `app/packs/entrypoints` with the desired scripts and styles.
Then add them to Avo using the `_pre_head.html.erb` partial (`rails generate avo:eject --partial :pre_head`).

```erb
# app/views/avo/partials/_pre_head.html.erb

<%= javascript_pack_tag 'avo.custom', defer: true %>
<%= stylesheet_pack_tag 'avo.custom', media: 'all' %>
```

---

# TailwindCSS integration

We use TailwindCSS 3.0 with the JIT engine to style Avo, so on release we only pack the used Tailwind classes in our final css file. That's why, when you want to style your custom content (tools, resource tools, fields, or ejected partials), you won't have access to all of Tailwind's utility classes. It's a feature, not a bug. It's a performance optimization.

But there's an easy way to overcome that. You can add your own TailwindCSS process to watch for your the utility classes you use.

In versions prior to Avo 3, we maintained separate pre-compiled assets and provided a way to inject your Tailwind CSS assets into Avo's application. This often led to stylesheet conflicts. Now, we've improved integration by compiling a single stylesheet during the build process. If you want to add Tailwind configurations to Avo, your application will compile Avo's assets alongside your own in one build.

```bash
bin/rails generate avo:tailwindcss:install
```

That command will:

- install `tailwindcss-rails` gem if you haven't installed it yet;
- generate Avo's tailwind config.js `config/avo/tailwind.config.js`
- generate tailwind `base`, `components` and `utilities` under `app/assets/stylesheets/avo/tailwind` directory (workaround to import avo's base css after tailwind's base)
- create a custom `app/assets/stylesheets/avo/tailwind.css` file where you can further customize your Avo space;
- generate or enhance your `Procfile.dev` with the required compile `yarn avo:tailwindcss --watch` command, as per default `tailwindcss-rails` practices;
- add the build script to your `package.json`. **Ensure a `package.json` file is present;`yarn init` will generate one if your project doesn't have one**.
- add the following code to your `Rakefile`:
```ruby
# When running `rake assets:precompile` this is the order of events:
# 1 - Task `avo:yarn_install`
# 2 - Task `avo:sym_link`
# 3 - Cmd  `yarn avo:tailwindcss`
# 4 - Task `assets:precompile`
Rake::Task["assets:precompile"].enhance(["avo:sym_link"])
Rake::Task["avo:sym_link"].enhance(["avo:yarn_install"])
Rake::Task["avo:sym_link"].enhance do
  `yarn avo:tailwindcss`
end
```

Now, instead of running `bin/rails server`, you can run that Procfile with `bin/dev`.

:::info
You mileage may vary when running these tasks depending with your setup. The gist is that you need to run `yarn avo:tailwindcss` on deploy0time to compile the css file and `yarn avo:tailwindcss --watch` to watch for changes in development.
:::

Inside `app/assets/stylesheets/avo` you'll have a new `tailwind.css` file that's waiting for you to customize. The default `config/avo/tailwind.config.js` file should have the proper paths set up for purging and should be ready to go. Notice that it utilizes an preset that we manage, that preset is essential to build all avo's styles.

```css
@import 'tailwindcss/base';
/* Have all of Avo's custom and plugins styles available. */
@import '../../../../tmp/avo/avo.base.css';
@import 'tailwindcss/components';
@import 'tailwindcss/utilities';

/*

@layer components {
  .btn-primary {
    @apply py-2 px-4 bg-blue-200;
  }
}

*/
```

:::warning Avo Task Dependencies
You must ensure that the `avo:sym_link` and `avo:yarn_install` tasks are executed before building the Avo assets.

These tasks are responsible for creating various symbolic links within the `tmp/avo` directory and installing necessary Node modules within Avo's path. These modules are essential for utilizing the Avo Tailwind preset. And the symbolic links are essentials for purging all Avo's tailwind classes.
:::

---

# Media Library

<Image src="/assets/img/3_0/media-library/media-library.gif" alt="Media Library" size="800x453" />

If you run an asset-intensive, having a place to view all those asses would be great. It's becoming easier with Avo and it's Media Library feature.

The Media Library has two goals in mind.

1. Browse and manage all your assets
2. Use it to inject assets in all three of Avo's rich text editors (trix, rhino, and markdown).

:::warning
The Media Library feature is still in alpha and future releases might contain breaking changes so keep an eye out for the upgrade guide.

This is just the initial version and we'll be adding more features as we progress and get more feedback on usage.
:::

<div class="aspect-video">
  <iframe width="100%" height="100%" src="https://www.youtube.com/embed/wnWvzQyyo6A?start=1698" title="Avo 3.17 - Media Library, new Markdown field &amp; the Array Adapter" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
</div>

## How to enable it

The Media Library feature is disabled by default (until we release the stable version). To enable it, you need to do the following:

```ruby{4}
# config/initializers/avo.rb
if defined?(Avo::MediaLibrary)
  Avo::MediaLibrary.configure do |config|
    config.enabled = true
  end
end
```

This is the killswitch of the whole feature.
When disabled, the Media Library will not be available to anyone. It will hide the menu item, block the all the routes, and hide media the library icons from the editors.

## Hide menu item

You can hide the menu item from the sidebar by setting the `visible` option to `false`.

```ruby
# config/initializers/avo.rb
if defined?(Avo::MediaLibrary)
  Avo::MediaLibrary.configure do |config|
    config.visible = false
  end
end
```

You may also use a block to conditionally show the menu item. You'll have access to the `Avo::Current` object and you can use it to show the menu item based on the current user.

```ruby
# config/initializers/avo.rb
if defined?(Avo::MediaLibrary)
  Avo::MediaLibrary.configure do |config|
    config.visible = -> { Avo::Current.user.is_developer? }
  end
end
```

This will hide the menu item from the sidebar if the current user is not a developer.

## Add it to the menu editor

The Media Library is a menu item in the sidebar. You can add it to the menu editor by using the `media_library` helper.

```ruby
# config/initializers/avo.rb
Avo.configure do |config|
  config.main_menu = lambda {
    link_to 'Media Library', avo.media_library_index_path
  }
end
```

## Use it with the rich text editors

The Media Library will seamlessly integrate with all the rich text editors.

<Image src="/assets/img/3_0/media-library/media-library-rhino.gif" alt="Media Library with Rhino field" size="800x453" />

```ruby
field :body, as: :trix
field :body, as: :rhino
field :body, as: :markdown
```

The editors will each have a button to open the Media Library modal.
Once open, after the user selects the asset, it will be injected into the editor.

---

# Cache

Avo uses the application's cache system to enhance performance. The cache system is especially beneficial when dealing with resource index tables and license requests.

## Cache store selection

The cache system dynamically selects the appropriate cache store based on the application's environment:

### Production

In production, if the existing cache store is one of the following: `ActiveSupport::Cache::MemoryStore` or `ActiveSupport::Cache::NullStore` it will use the default `:file_store` with a cache path of `tmp/cache`. Otherwise, the existing cache store `Rails.cache` will be used.

### Test

In testing, it directly uses the `Rails.cache` store.

### Development and other environments

In all other environments the `:memory_store` is used.

### Custom selection

You can force Avo to use a particular store.

```ruby
# config/initializers/avo.rb
config.cache_store = -> {
  ActiveSupport::Cache.lookup_store(:solid_cache_store)
}

# or

config.cache_store = ActiveSupport::Cache.lookup_store(:solid_cache_store)
```

`cache_store` configuration option is expecting a cache store object, the lambda syntax can be useful if different stores are desired on different environments.

:::warning `MemoryStore` in production
Our recomendation is to not use MemoryStore in production because it will not be shared between multiple processes (when using Puma).
:::

<Option name="`cache_hash`">

The `cache_hash` method is used to compute the cache key for each row.

More about this on the resource options page.
</Option>

## Caching caveats

Avo caches each record on the <Index /> view for improved performance. However side-effects may occur from this strategy. We'll try to outline some of them below and keep this page up to date as we find them or as they get reported to us.

These are things that may happen to regular Rails apps, not just in the Avo context.

### Rows may not be automatically updated when certain associations change

There are two things you could do to prevent this:

#### Option 1: Use `touch: true` on association

Example with Parent Model and Association
```ruby
  class Post < ApplicationRecord
    has_many :comments, dependent: :destroy
  end
```
Example with Child Model and Association with `touch: true`
```ruby
  class Comment < ApplicationRecord
    belongs_to :post, touch: true
  end
```

#### Option 2: override `cache_hash` method on resource to take associations in consideration

Avo, internally, uses the `cache_hash` method to compute the hash that will be remembered by the caching driver when displaying the rows.

You can take control and override it on that particular resource to take the association into account.
```ruby
  class Avo::Resources::User < Avo::BaseResource
    def fields
      # your fields
    end

    def cache_hash(parent_record)
      # record.post will now be taken under consideration
      result = [record, file_hash, record.post]

      if parent_record.present?
        result << parent_record
      end

      result
    end
  end
```

### `root_path` change won't break the cache keys

When the rows are cached, the links from the controls, `belongs_to` and `record_link` fields, and maybe others will be cached along.

The best solution here is to clear the cache with this ruby command `Rails.cache.clear`. If that's not an option then you can try to add the `root_path` to the `cache_hash` method in your particular resource.

## Solid Cache

Avo seamlessly integrates with [Solid Cache](https://github.com/rails/solid_cache). To setup Solid Cache follow these essential steps

Add this line to your application's Gemfile:

```ruby
gem "solid_cache"
```

And then execute:
```bash
$ bundle
```

Or install it yourself as:
```bash
$ gem install solid_cache
```

Add the migration to your app:

```bash
$ bin/rails solid_cache:install:migrations
```

Then run it:
```bash
$ bin/rails db:migrate
```

To set Solid Cache as your Rails cache, you should add this to your environment config:

```ruby
# config/environments/production.rb

config.cache_store = :solid_cache_store
```

Check [Solid Cache repository](https://github.com/rails/solid_cache) for additional valuable information.

---

# Views performance

## Log ViewComponent loading times and allocations

Sometimes, you may want to track the loading times and memory allocations of ViewComponents, similar to how you do with partials. Follow these two steps to enable this functionality.

#### 1. Enable ViewComponent Instrumentation

First, you need to enable instrumentation for ViewComponents. Add the following configuration to your `application.rb` or `development.rb` file:

```ruby
# application.rb or development.rb
config.view_component.instrumentation_enabled = true
```

#### 2. Add Logging

Next, set up logging to capture the performance data. Create or update the `config/initializers/view_component.rb` file with the following code:

```ruby
# config/initializers/view_component.rb
module ViewComponent
  class LogSubscriber < ActiveSupport::LogSubscriber
    define_method :'!render' do |event|
      info do
        message = +"  Rendered #{event.payload[:name]}"
        message << " (Duration: #{event.duration.round(1)}ms"
        message << " | Allocations: #{event.allocations})"
      end
    end
  end
end

ViewComponent::LogSubscriber.attach_to :view_component
```

<Image src="/assets/img/3_0/performance/views-performance/view-component-logs.png" size="2236xâ€Š462" alt="View Component logging" />

:::warning
Enabling this logging can negatively impact your applicationâ€™s performance. We recommend using it in the development environment or disabling it in production once you have completed debugging.
:::

---

# `Avo::PanelComponent`

The panel component is one of the most used components in Avo.

```erb
<%= render Avo::PanelComponent.new(title: @product.name, description: @product.description) do |c| %>
  <% c.with_tools do %>
    <%= a_link(@product.link, icon: 'heroicons/solid/academic-cap', style: :primary, color: :primary) do %>
      View product
    <% end %>
  <% end %>

  <% c.with_body do %>
    <div class="flex flex-col p-4 min-h-24">
      <div class="space-y-4">
        <h3>Product information</h3>

        <p>Style: shiny</p>
      </div>
    </div>
  <% end %>
<% end %>
```

<Image src="/assets/img/native-components/avo-panel-component/index.jpg" width="773" height="276" alt="" />

## Options

All options are optional. You may render a panel without options.

```erb
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_body do %>
    Something here.
  <% end %>
<% end %>
```

<Option name="`name`">

The name of the panel. It's displayed on the top under the breadcrumbs.

#### Type
`String`

<Image src="/assets/img/native-components/avo-panel-component/name.jpg" width="773" height="411" alt="" />
</Option>

<Option name="`description`">

Small text under the name that speaks a bit about what the panel does.

#### Type
`String`

<Image src="/assets/img/native-components/avo-panel-component/description.jpg" width="773" height="533" alt="" />
</Option>

<Option name="`classes`">

A list of classes that should be applied to the panel container.

#### Type
`String`

<Image src="/assets/img/native-components/avo-panel-component/classes.jpg" width="773" height="533" alt="" />
</Option>

<Option name="`body_classes`">

A list of classes that should be applied to the body of panel.

#### Type
`String`

<Image src="/assets/img/native-components/avo-panel-component/body_classes.jpg" width="773" height="533" alt="" />
</Option>

<Option name="`data`">

A hash of data attributes to be forwarded to the panel container.

#### Type
`Hash`

<Image src="/assets/img/native-components/avo-panel-component/classes.jpg" width="773" height="533" alt="" />
</Option>

<Option name="`display_breadcrumbs`">

Toggles the breadcrumbs visibility. You can't customize the breadcrumbs yet.

#### Type
`Boolean`

<Image src="/assets/img/native-components/avo-panel-component/display_breadcrumbs.jpg" width="773" height="720" alt="" />
</Option>

## Slots

The component has a few slots where you customize the content in certain areas.

<Option name="`tools`">

We created this slot as a place to put resource controls like the back, edit, delete, and detach buttons.
This slot will collapse under the title and description when the screen resolution falls under `1024px`.

The section is automatically aligned to the right using `justify-end` class.

```erb
<%= render Avo::PanelComponent.new(name: "Dashboard") do |c| %>
  <% c.with_tools do %>
    <%= a_link('/admin', icon: 'heroicons/solid/academic-cap', style: :primary) do %>
      Admin
    <% end %>
  <% end %>
<% end %>
```

<Image src="/assets/img/native-components/avo-panel-component/tools-slot.jpg" width="1014" height="226" alt="" />
</Option>

<Option name="`body`">

This is one of the main slots of the component where the bulk of the content is displayed.

```erb{2-4}
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_body do %>
    Something here.
  <% end %>
<% end %>
```

<Image src="/assets/img/native-components/avo-panel-component/body-slot.jpg" width="773" height="720" alt="" />
</Option>

<Option name="`bare_content`">

Used when displaying the Grid view, it displays the data flush in the container and with no background.

```erb{2-4}
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_bare_content do %>
    Something here.
  <% end %>
<% end %>
```

<Image src="/assets/img/native-components/avo-panel-component/grid-view.jpg" width="1312" height="1096" alt="" />
</Option>

<Option name="`footer_tools`">

This is pretty much the same slot as `tools` but rendered under the `body` or `bare_content` slots.

```erb{2-4}
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_footer_controls do %>
    Something here.
  <% end %>
<% end %>
```

<Image src="/assets/img/native-components/avo-panel-component/footer-controls.jpg" width="1013" height="295" alt="" />
</Option>

<Option name="`footer`">

The lowest available area at the end of the component.

```erb{2-4}
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_footer do %>
    Something here.
  <% end %>
<% end %>
```
</Option>

<Option name="`sidebar`">

The sidebar will conveniently show things in a smaller area on the right of the `body`.

```erb{2-4}
<%= render Avo::PanelComponent.new do |c| %>
  <% c.with_Sidebar do %>
    Something tiny here.
  <% end %>
<% end %>
```
<Image src="/assets/img/native-components/avo-panel-component/sidebar.png" width="2032" height="1294" alt="" />
</Option>

---

# Native field components

One of the most important features of Avo is the ability to extend it pass the DSL. It's very important to us to enable you to add the features you need and create the best experience for your users.

That's why you can so easily create custom fields, resource tools, and custom tools altogether. When you need to augment the UI even more you can use your custom CSS and JS assets too.

When you start adding those custom views you might want to add your own fields, and you'd like to make them look like the rest of the app.
That's why Avo provides a way to use those fields beyond the DSL, in your own custom Rails partials.

## Declaring fields

When you generate a new resource tool you get access to the resource partial.

:::details Sample resource tool
```erb
<div class="flex flex-col">
  <%= render Avo::PanelComponent.new title: "Post info" do |c| %>
    <% c.with_tools do %>
      <%= a_link('/avo', icon: 'heroicons/solid/academic-cap', style: :primary) do %>
        Dummy link
      <% end %>
    <% end %>
    <% c.with_body do %>
      <div class="flex flex-col p-4 min-h-24">
        <div class="space-y-4">
          <h3>ðŸª§ This partial is waiting to be updated</h3>
          <p>
            You can edit this file here <code class='p-1 rounded bg-gray-500 text-white text-sm'>app/views/avo/resource_tools/post_info.html.erb</code>.
          </p>
          <p>
            The resource tool configuration file should be here <code class='p-1 rounded bg-gray-500 text-white text-sm'>app/avo/resource_tools/post_info.rb</code>.
          </p>
          <%
            # In this partial, you have access to the following variables:
            # tool
            # @resource
            # @resource.model
            # form (on create & edit pages. please check for presence first)
            # params
            # Avo::Current.context
            # current_user
          %>
        </div>
      </div>
    <% end %>
  <% end %>
</div>
```
:::

You may add new fields using the `avo_show_field`, or `avo_edit_field` methods and use the arguments you are used to from resources.

```ruby
# In your resource file
field :name, as: :text
```

```erb

<%= avo_edit_field :name, as: :text %>
```

## The `form` option

If this is an <Edit /> or a <New /> view, you should pass it the `form` object that an Avo resource tool provides for you.

```erb
<%= avo_edit_field :name, as: :text, form: form %>
```

## The `value` option

When you are building a show field and you want to give it a value to show, use the `value` options

```erb
<%= avo_show_field(:photo, as: :external_image, value: record.cdn_image) %>
```

## Other field options

The fields take all the field options you are used to like, `help`, `required`, `readonly`, `placeholder`, and more.

```erb
<%= avo_edit_field :name, as: :text, form: form, help: "The user's name", readonly: -> { !current_user.is_admin? }, placeholder: "John Doe", nullable: true %>
```

## Component options

The field taks a new `component_options` argument that will be passed to the view component for that field. Please check out the field wrapper documentation for more details on that.

## `avo_field` helper

You may use the `avo_field` helper to conditionally switch from `avo_show_field` and `avo_edit_field`.

```erb
<%= avo_field :name, as: :text, view: :show %>
<%= avo_field :name, as: :text, view: :edit %>
<%= avo_field :name, as: :text, view: ExampleHelper.view_conditional %>
```

---

# Field wrappers

Each field display in your Avo resource has a field wrapper that helps display it in a cohesive way across the whole app.
This not only helps with a unitary design, but also with styling in a future theming feature.

:::info
You'll probably never have to use these components and helpers by themselves, but we'd like to document how they work as a future reference for everyone.
:::

# Index field wrapper

<Image src="/assets/img/field-wrappers/index_field_wrapper.jpg" width="1024" height="639" alt="" />

Each field displayed on the <Index /> view is wrapped in this component that regulates the way content is displayed and makes it easy to control some options.

You may use the component `Avo::Index::FieldWrapperComponent` or the helper `index_field_wrapper`.

<Option name="`dash_if_blank`">

This option renders a dash `â€”` if the content inside responds to true on the `blank?` method.
In the example below, we'd like to show the field as a red checkmark even if the content is `nil`.

#### Default

`true`

```erb
<%= index_field_wrapper **field_wrapper_args, dash_if_blank: false do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`center_content`">

Wraps the content in a container with `flex items-center justify-center` classes making everything centered horizontally and vertically.

#### Default

`false`

```erb
<%= index_field_wrapper **field_wrapper_args, center_content: true do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`flush`">

Removes the padding around the field allowing it to flow from edge to edge.

#### Default

`false`

```erb
<%= index_field_wrapper **field_wrapper_args, flush: false do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`field`">

The instance of the field. It's usually passed in with the `field_wrapper_args`.

```erb
<%= index_field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`resource`">

The instance of the resource. It's usually passed in with the `field_wrapper_args`.

```erb
<%= index_field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

# Show & Edit field wrapper

<Image src="/assets/img/field-wrappers/show_field_wrapper.jpg" width="1024" height="639" alt="" />
<Image src="/assets/img/field-wrappers/edit_field_wrapper.jpg" width="1024" height="639" alt="" />

The <Show /> and <Edit /> field wrappers are actually the same component.

You may use the component `Avo::Index::FieldWrapperComponent` or the helper `field_wrapper`.

## Field wrapper areas

<Image src="/assets/img/field-wrappers/field_wrapper_areas.jpg" width="1024" height="639" alt="" />

Each field wrapper is divided in three areas.

### Label

This is where the field name is being displayed. This is also where the required asterisk is added for required fields.

### Value

This area holds the actual value of the field or it's representation. The falue can be simple text or more advanced types like images, advanced pickers, and content editors.

At the bottom the help text is going to be shown on the <Edit /> view and below it the validation error.

### Extra

This space is rarely used and it's there just to fill some horizontal space so the content doesn't span to the whole width and maintain its readability. With the introduction of the sidebar, this space will be ignored

## Options

<Option name="`dash_if_blank`">

This option renders a dash `â€”` if the content inside responds to true on the `blank?` method.
In the example below, we'd like to show the field as a red checkmark even if the content is `nil`.

#### Default

`true`

```erb
<%= field_wrapper **field_wrapper_args, dash_if_blank: false do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`compact`">

This renders the field in a more compact way by removing the **Extra** area and decresing the width of the **Label** and **Content** areas.

This is enabled on the fields displayed in actions.

#### Default

`false`

```erb
<%= field_wrapper **field_wrapper_args, compact: true do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`data`">

Pass in some data attributes. Perhaps you would like to attach a StimulusJS controller to this field.

```erb
<%= field_wrapper **field_wrapper_args, data: {controller: "boolean-check"} do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`full_width`">

This removes the **Extra** area and renders the **Value** area full width.

This is used on fields that require a larger area to be displayed like WYSIWYG editors, `KeyValue`, or file fields.

#### Default

`false`

```erb
<%= field_wrapper **field_wrapper_args, full_width: true do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`form`">

The instance of the form that is going to be populated. It's usually passed in with the `field_wrapper_args` on the <Edit /> view.

```erb
<%= field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`field`">

The instance of the field. It's usually passed in with the `field_wrapper_args`.

```erb
<%= field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`help`">

The text that is going to be displayed below the actual field on the <Edit /> view.

```erb
<%= field_wrapper **field_wrapper_args, help: "Specify if the post is published or not." do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`label`">

The text that is going to be displayed in the **Label** area. You might want to override it.

```erb
<%= field_wrapper **field_wrapper_args, label: "Post is published" do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`resource`">

The instance of the resource. It's usually passed in with the `field_wrapper_args`.

```erb
<%= field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`stacked`">

Display the field in a column layout with the label on top of the value

```erb
<%= field_wrapper **field_wrapper_args, style: "background: red" do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Image src="/assets/img/field-wrappers/stacked_field.jpg" width="1024" height="639" alt="" />

<Option name="`style`">

The you might want to pass some styles to the wrapper to change it's looks.

```erb
<%= field_wrapper **field_wrapper_args, style: "background: red" do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

<Option name="`view`">

The view where the field is diplayed so it knows if it's a <Show /> or <Edit /> view. It's usually passed in with the `field_wrapper_args`.

```erb
<%= field_wrapper **field_wrapper_args do %>
  <%= render Avo::Fields::Common::BooleanCheckComponent.new checked: @field.value %>
<% end %>
```
</Option>

---

# Internals

This section documents on how we think about the internals of Avo and hwo much you could/should hook into them to extend it.

### Public Methods and Internal Usage

Not all public methods within the Avo codebase are meant for direct user consumption. Some methods are publicly accessible but primarily intended for internal use by various components of the Avo framework itself. This distinction arises due to the complex nature of building a framework or an ecosystem of gems, where numerous moving parts require public interfaces for framework developers rather than for end users.

---

# Testing

:::info
We know the testing guides aren't very detailed, and some testing helpers are needed. So please send your feedback [here](https://github.com/avo-hq/avo/discussions/1168).
:::

Testing is an essential aspect of your app. Most Avo DSLs are Ruby classes, so regular testing methods should apply.

## Testing helpers

We prepared a few testing helpers for you to use in your apps. They will help with opening/closing datepickers, choosing the date, saving the records, add/remove tags, and also select a lot of elements throughout the UI.

You can find them all [here](https://github.com/avo-hq/avo/blob/main/lib/avo/test_helpers.rb),

## Testing Actions

Given this `Avo::Actions::ReleaseFish`, this is the `spec` that tests it.

```ruby

class Avo::Actions::ReleaseFish < Avo::BaseAction
  self.name = "Release fish"
  self.message = "Are you sure you want to release this fish?"

  def fields
    field :message, as: :textarea, help: "Tell the fish something before releasing."
  end

  def handle(query:, fields:, **_)
    query.each(&:release)

    succeed "#{query.count} fish released with message '#{fields[:message]}'."
  end
end

```

```ruby
require 'rails_helper'

RSpec.feature Avo::Actions::ReleaseFish, type: :feature do
  let(:fish) { create :fish }
  let(:current_user) { create :user }
  let(:resource) { Avo::Resources::User.new.hydrate model: fish }

  it "tests the dummy action" do
    args = {
      fields: {
        message: "Bye fishy!"
      },
      current_user: current_user,
      resource: resource,
      query: [fish]
    }

    action = described_class.new(resource: resource, user: current_user, view: :edit)

    expect(action).to receive(:succeed).with "1 fish released with message 'Bye fishy!'."
    expect(fish).to receive(:release)

    action.handle **args
  end
end
```

---

# `Avo::Current`

`Avo::Current` is based on the `Current` pattern Rails exposes using [`ActiveSupport/CurrentAttributes`](https://api.rubyonrails.org/classes/ActiveSupport/CurrentAttributes.html).

On each request Avo will set some values on it.

<Option name="`user`">

This is what will be returned by the `current_user_method` that you've set in your initializer.
</Option>

<Option name="`params`">

Equivalent of `request.params`.
</Option>

<Option name="`request`">

The Rails `request`.
</Option>

<Option name="`context`">

The `context` that you configured in your initializer evaluated in `Avo::ApplicationController`.
</Option>

<Option name="`view_context`">

An instance of [`ActionView::Rendering`](https://api.rubyonrails.org/classes/ActionView/Rendering.html#method-i-view_context) off of which you can run any methods or variables that are available in your partials.

```ruby
view_context.link_to "Avo", "https://avohq.io"
```
</Option>

<Option name="`locale`">

The `locale` of the app.
</Option>

<Option name="`tenant_id`">

You can set the `tenant_id` for the current request.
</Option>

<Option name="`tenant`">

You can set the `tenant` for the current request.
</Option>

**Related:**
  - Multitenancy

---

# Execution context

Avo enables developers to hook into different points of the application lifecycle using blocks.
That functionality can't always be performed in void but requires some pieces of state to set up some context.

Computed fields are one example.

```ruby
field :full_name, as: :text do
  "#{record.first_name} #{record.last_name}"
end
```

In that block we need to pass the `record` so you can compile that value. We send more information than just the `record`, we pass on the `resource`, `view`, `view_context`, `request`, `current_user` and more depending on the block that's being run.

## How does the `ExecutionContext` work?

The `ExecutionContext` is an object that holds some pieces of state on which we execute a lambda function.

```ruby
module Avo
  class ExecutionContext

    attr_accessor :target, :context, :params, :view_context, :current_user, :request

    def initialize(**args)
      # If target don't respond to call, handle will return target
      # In that case we don't need to initialize the others attr_accessors
      return unless (@target = args[:target]).respond_to? :call

      args.except(:target).each do |key,value|
        singleton_class.class_eval { attr_accessor "#{key}" }
        instance_variable_set("@#{key}", value)
      end

      # Set defaults on not initialized accessors
      @context      ||= Avo::Current.context
      @params       ||= Avo::Current.params
      @view_context ||= Avo::Current.view_context
      @current_user ||= Avo::Current.current_user
      @request      ||= Avo::Current.request
    end

    delegate :authorize, to: Avo::Services::AuthorizationService

    # Return target if target is not callable, otherwise, execute target on this instance context
    def handle
      target.respond_to?(:call) ? instance_exec(&target) : target
    end
  end
end

# Use it like so.
SOME_BLOCK = -> {
  "#{record.first_name} #{record.last_name}"
}

Avo::ExecutionContext.new(target: &SOME_BLOCK, record: User.first).handle
```

This means you could throw any type of object at it and it it responds to a `call` method wil will be called with all those objects.

<Option name="`target`">

The block you'll pass to be evaluated. It may be anything but will only be evaluated if it responds to a `call` method.
</Option>

<Option name="`context`">

Aliased to `Avo::Current.context`.
</Option>

<Option name="`current_user`">

Aliased to `Avo::Current.user`.
</Option>

<Option name="`view_context`">

Aliased to `Avo::Current.view_context`.
</Option>

<Option name="`request`">

Aliased to `Avo::Current.request`.
</Option>

<Option name="`params`">

Aliased to `Avo::Current.params`.
</Option>

<Option name="Custom variables">

You can pass any variable to the `ExecutionContext` and it will be available in that block.
This is how we can expose `view`, `record`, and `resource` in the computed field example.

```ruby
Avo::ExecutionContext.new(target: &SOME_BLOCK, record: User.first, view: :index, resource: resource).handle
```
</Option>

<Option name="`helpers`">

Within the `ExecutionContext` you might want to use some of your already defined helpers. You can do that using the `helpers` object.

```ruby
# products_helper.rb
class ProductsHelper
  # Strips the "CODE_" prefix from the name
  def simple_name(name)
    name.gsub "CODE_", ""
  end
end

field :name, as: :text, format_using: -> { helpers.simple_name(value) }
```
</Option>

---

# Execution context

[`Avo::Services::EncryptionService`](https://github.com/avo-hq/avo/blob/main/lib/avo/services/encryption_service.rb) it's used internally by Avo when is needed to encrypt sensible params.

One example is the select all feature, where we pass the query, encrypted, through params.

## How does the [`Avo::Services::EncryptionService`](https://github.com/avo-hq/avo/blob/main/lib/avo/services/encryption_service.rb) work?

The `EncryptionService` is an service that can be called anywhere on the app.

### Public methods

<Option name="`encrypt`">

Used to encrypt data
</Option>

<Option name="`decrypt`">

Used to decrypt data
</Option>

<br><br>

### Mandatory arguments:

<Option name="`message`">

Object to be encrypted
</Option>

<Option name="`purpose`">

A symbol with the purpose of encryption, can be anything, it just ***need to match when decrypting***.
</Option>

<br><br>

### Optional arguments
This service uses [`ActiveSupport::MessageEncryptor`](https://api.rubyonrails.org/v5.2.3/classes/ActiveSupport/MessageEncryptor.html) as encryptor so [`Avo::Services::EncryptionService`](https://github.com/avo-hq/avo/blob/main/lib/avo/services/encryption_service.rb) accepts any argument specified on [`ActiveSupport::MessageEncryptor` documentation](https://api.rubyonrails.org/v5.2.3/classes/ActiveSupport/MessageEncryptor.html)

## Usage example

### Basic text:
```ruby
secret_encryption = Avo::Services::EncryptionService.encrypt(message: "Secret string", purpose: :demo)
# "x+rnETtClF2cb80PtYzlULnVB0vllf+FvwoqBpPbHWa8q6vlml5eRWrwFMcYrjI6--h2MiT1P5ctTUjwfQ--k2WsIRknFVE53QwXADDDJw=="

Avo::Services::EncryptionService.decrypt(message: secret_encryption, purpose: :demo)
# "Secret string"
```

### Objects with custom serializer:
```ruby
secret_encryption = Avo::Services::EncryptionService.encrypt(message:Course::Link.first, purpose: :demo, serializer: Marshal)
# "1UTtkhu9BDywzz8yl8/7cBZnOoM1wnILDJbT7gP+zz8M/t1Dve4QTFQP5nfHZdYK9KvFDwkizm8DTHyNZdixDtCO/M7yNMlzL8Mry1RQ3AF0qhhTzFeqb5UqyQv/Cuq+NWvQ+GXv3gFckXaNqsFSX5yDccEpRDpyNkYT4MFxOa+8hVR4roebkNKB89lb73anBDTHsTAd37y2LFiv2YaiFguPQ/...

Avo::Services::EncryptionService.decrypt(message: secret_encryption, purpose: :demo, serializer: Marshal)
# #<Course::Link:0x00007fd28dc44c00 id: 1, link: "http://ortiz.com/cher_mohr", course_id: 1, created_at: Thu, 07 Dec 2023 11:05:13.779644000 UTC +00:00, updated_at: Thu, 07 Dec 2023 11:05:13.779644000 UTC +00:00, position: 1>
```

## Secret key base
:::warning
[`Avo::Services::EncryptionService`](https://github.com/avo-hq/avo/blob/main/lib/avo/services/encryption_service.rb) fetches a secret key base to be used on the encrypt / decrypt process. Make sure that you have it defined in any of the following:

`ENV["SECRET_KEY_BASE"] || Rails.application.credentials.secret_key_base || Rails.application.secrets.secret_key_base`
:::

---

# Select All

The "Select All" feature is designed to enable users to select all queried records and perform actions on the entire selection. This feature is particularly useful when dealing with large datasets, allowing users to trigger actions on all queried records, not just the ones visible on the current page.

## How does it work?

<Image src="/assets/img/3_0/select_all.gif" width="687" height="289" alt="Select all demonstration" />

When a user toggles the "Select all" checkbox, Avo will first check to see if there are more records than just those displayed on that page, and if there are, it will ask if the user if they want to select all the records or not.

This is being done through serializing the query to be unserialized back in the action.

## Serializing the query

The query might include various filters, sorting parameters, and other custom elements. Reconstructing this query at the time of the action request can be complex. Therefore, the system serializes the entire query object into a secure format before sending it with the action request.

- **Security**: To ensure that sensitive data is protected, the serialized query is encrypted before it is transmitted.
- **Efficiency**: This approach allows the system to accurately and efficiently reconstruct the original query when the action is executed, ensuring that all relevant records are included.

:::warning
<VersionReq version="3.12.0" />
If an error occurs during the serialization process, the "Select All" feature is automatically disabled. This safeguard ensures that the page will not crash because of a coding error.
We listed a few reasons on why it might crash below.
:::

## Serialization known issues

In this section, we outline common serialization problems and provide guidance on how to resolve them effectively.

##### `normalize`

If your model includes any `normalize` proc, such as:

```ruby
normalizes :status, with: ->(status) { status }
```

Serialization may fail when a filter is applied to the normalized attribute (e.g., `status` in this example). This can result in the error `TypeError: no _dump_data is defined for class Proc`, which causes the "Select All" feature to be automatically disabled.

For applications created before Rails `7.1`, configuring the `marshalling_format_version` to `7.1` or higher will resolve the issue:

```ruby
# config/application.rb

config.active_record.marshalling_format_version = 7.1
```

More details on [`normalizes` documentation](https://api.rubyonrails.org/classes/ActiveRecord/Normalization/ClassMethods.html#method-i-normalizes).

---

# Icons

Avo provides a collection of SVG icons organized into two directories: [`avo`](https://github.com/avo-hq/avo/tree/main/app/assets/svgs/avo) and [`heroicons`](https://github.com/avo-hq/avo/tree/main/app/assets/svgs/heroicons) ([check heroicons](https://heroicons.com/)). These icons are easily accessible using the [`svg` method](https://github.com/avo-hq/avo/blob/main/app/helpers/avo/application_helper.rb#L63).

To render an icon in your application, use the svg method. This method allows you to specify the icon's path and class.

Examples:
```ruby
# in a View Component
helpers.svg("avo/editor-strike")

# in a Rails helper
svg("heroicons/outline/magnifying-glass-circle", class: "block h-6 text-gray-600")
```

```erb
<%= svg 'avo/bell.svg', class: "h-4" %>
```

There are some places where Avo have custom DSL accepting the `icon` option. There you only need to specify the `icon`'s path (`avo/...` or `heroicons/...`). Behind the scenes Avo applies the [`svg` method](https://github.com/avo-hq/avo/blob/main/app/helpers/avo/application_helper.rb#L63).

## Avo icons

Avo uses a [set of custom icons](https://github.com/avo-hq/avo/tree/main/app/assets/svgs/avo) which you can use yourself with this notation: `avo/ICON_NAME`.

#### Example:

```erb
<%= svg "avo/bell.svg", class: "h-4" %>
```

## Using heroicons

Avo uses the delightful [`heroicons` library](https://heroicons.com/) which is kept up to date by the team.

Heroicons come in 4 variants `outline`, `solid`, `mini`, and `micro`.

You can use these icons with this notation: `heroicons/VARIANT/ICON_NAME`.
We usually use the `outline` variant.

#### Examples:

```erb
<%= svg "heroicons/outline/academic-cap.svg" %>

<%= svg "heroicons/mini/arrow-path-rounded-square.svg" %>
```

---

# Reserved model names and routes

When defining models in an Avo-powered application, certain names should be avoided as they are used by Avoâ€™s internal controllers. Using these names may lead to conflicts, routing issues, or unexpected behavior.

## Model names to avoid

Avo uses the following names for its internal controllers:

- `action`
- `application`
- `association`
- `attachment`
- `base_application`
- `base`
- `chart`
- `debug`
- `home`
- `private`
- `resource`
- `search`

Using these names for models may override built-in functionality, cause routing mismatches, or introduce other conflicts.

## Why these names are reserved

Avo relies on these names for its controller and routing system. For example:
- `resource` is essential for managing Avo resources.
- `chart` is used for analytics and visualizations.
- `search` handles search functionality.

Since Avo dynamically maps models and controllers, using these names may interfere with how Avo processes requests and displays resources.

## Alternative approaches

If your application requires one of these names, consider the following alternatives:
- **Use a prefix or suffix**
  - `user_resource` instead of `resource`
  - `advanced_search` instead of `search`
- **Choose a synonym**
  - `graph` instead of `chart`

### Using Avo with existing models

If your application already has models with these names, you can generate an Avo resource with a different name while keeping the same model class.

For example for `Resource` run the following command:

```sh
bin/rails generate avo:resource user_resource --model-class resource
```

This will generate:

- `Avo::Resources::UserResource`
- `Avo::UserResourcesController`

However, it will still use the existing `Resource` model, ensuring no conflicts arise.

## Route Conflicts with `resources :resources`

If your application has a route definition like:

```ruby
resources :resources
```

This will create path helpers such as `resources_path`, which **conflicts with [Avoâ€™s internal routing helpers](https://github.com/avo-hq/avo/blob/main/app/helpers/avo/url_helpers.rb#L3)**. Avo uses `resources_path` internally, and having this route in your application **will override Avoâ€™s default helpers**, potentially breaking parts of the admin panel.

### How to Fix It

To prevent conflicts, rename the route helpers to something more specific:

```ruby
resources :resources, as: 'articles'
```

This allows you to maintain the desired URL structure (`/resources`) without interfering with Avoâ€™s internals.

---

# `Avo::ApplicationController`

## On extending the `ApplicationController`

You may sometimes want to add functionality to Avo's `ApplicationController`. That functionality may be setting attributes to `Current` or multi-tenancy scenarios.

When you need to do that, you may feel the need to override it with your own version. That means you go into the source code, find `AVO_REPO/app/controllers/avo/application_controller.rb`, copy the whole thing into your own `YOUR_APP/app/controllers/avo/application_controller.rb` file inside your app, and add your own piece of functionality.

```ruby{10,14-16}
# Copied from Avo to `app/controllers/avo/application_controller.rb`
module Avo
  class ApplicationController < ::ActionController::Base
    include Pagy::Backend
    include Avo::ApplicationHelper
    include Avo::UrlHelpers

    protect_from_forgery with: :exception
    around_action :set_avo_locale
    before_action :multitenancy_detector

    # ... more Avo::ApplicationController methods

    def multitenancy_detector
      # your logic here
    end
  end
end
```

That will work just fine until the next time we update it. After that, we might add a method, remove one, change the before/after actions, update the helpers and do much more to it.
**That will definitely break your app the next time when you upgrade Avo**. Avo's private controllers are still considered private APIs that may change at any point. These changes will not appear in the changelog or the upgrade guide.

## Responsibly extending the `ApplicationController`

There is a right way of approaching this scenario using Ruby modules or concerns.

First, you create a concern with your business logic; then you include it in the parent `Avo::ApplicationController` like so:

```ruby{6-8,11-13,18}
# app/controllers/concerns/multitenancy.rb
module Multitenancy
  extend ActiveSupport::Concern

  included do
    before_action :multitenancy_detector
    # or
    prepend_before_action :multitenancy_detector
  end

  def multitenancy_detector
    # your logic here
  end
end

# configuration/initializers/avo.rb
Rails.configuration.to_prepare do
  Avo::ApplicationController.include Multitenancy
end
```

With this technique, the `multitenancy_detector` method and its `before_action` will be included safely in `Avo::ApplicationController`.

:::info
If you'd like to add a `before_action` before all of Avo's before actions, use `prepend_before_action` instead. That will run that code first and enable you to set an account or do something early on.
:::

## Override `ApplicationController` methods

Sometimes you don't want to add methods but want to override the current ones.

For example, you might want to take control of the `Avo::ApplicationController.fill_record` method and add your own behavior.

TO do that you should change a few things in the approach we mentioned above. First we want to `prepend` the concern instead of `include` it and next, if we want to run a class method, we used `prepended` instead of `included`.

```ruby{5-8,10-12,14-17,23}
# app/controllers/concerns/application_controller_overrides.rb
module ApplicationControllerOverrides
  extend ActiveSupport::Concern

  # we use the `prepended` block instead of `included`
  prepended do
    before_action :some_hook
  end

  def some_hook
    # your logic here
  end

  def fill_record
    # do some logic here
    super
  end
end

# configuration/initializers/avo.rb
Rails.configuration.to_prepare do
  # we will prepend instead of include
  Avo::ApplicationController.prepend ApplicationControllerOverrides
end
```

**Related:**
  - Multitenancy

---

# Asset manager

In your plugins or custom content you might want to add a new stylesheet or javascript file to be loaded inside Avo.

You can manually add them to the `_head.html.erb` or `_pre_head.html.erb` files or you can use the `AssetManager`.

Next, the asset manager will add them to the `<head>` element of Avo's layout file.

## Add a stylesheet file

Use `Avo.asset_manager.add_stylesheet PATH`

Example:

```ruby
Avo.asset_manager.add_stylesheet "/public/magic_file.css"
Avo.asset_manager.add_stylesheet Avo::Engine.root.join("app", "assets", "stylesheets", "magic_file.css")
```

## Add a javascript file

Use `Avo.asset_manager.add_javascript PATH`

Example:

```ruby
Avo.asset_manager.add_javascript "/public/magic_file.js"
Avo.asset_manager.add_javascript Avo::Engine.root.join("app", "javascripts", "magic_file.js")
```

---

# Plugins

:::warning
This feature is in beta and we might change the API as we develop it.

These docs are in beta too, so please [ask for more information](https://github.com/avo-hq/avo/discussions) when you need it.
:::

## Overview

Plugins are a way to extend the functionality of Avo.

### Light layer

We are in the early days of the plugin system and we're still figuring out the best way to do it. This is why we have a light layer that you can use to extend the functionality of Avo.

This means we provide two hooks that you can use to extend the functionality of the Rails app, and a few Avo APIs to add scrips and stylesheets.

## Register the plugin

The way we do it is through an initializer. We mostly use the `engine.rb` file to register the plugin.

```ruby{8-15}
# lib/avo/feed_view/engine.rb
module Avo
  module FeedView
    class Engine < ::Rails::Engine
      isolate_namespace Avo::FeedView

      initializer "avo-feed-view.init" do
        # Avo will run this hook on boot time
        ActiveSupport.on_load(:avo_boot) do
          # Register the plugin
          Avo.plugin_manager.register :feed_view

          # Register the mounting point
          Avo.plugin_manager.mount_engine Avo::FeedView::Engine, at: "/feed_view"
        end
      end
    end
  end
end
```

This will add the plugin to a list of plugins which Avo will run the hooks on.

## Hook into Avo

```ruby
module Avo
  module FeedView
    class Engine < ::Rails::Engine
      isolate_namespace Avo::FeedView

      initializer "avo-feed-view.init" do
        ActiveSupport.on_load(:avo_boot) do
          Avo.plugin_manager.register :feed_view

          # Add some concerns
          Avo::Resources::Base.include Avo::FeedView::Concerns::FeedViewConcern

          # Remove some concerns
          Avo::Resources::Base.included_modules.delete(Avo::Concerns::SOME_CONCERN)

          # Add asset files to be loaded by Avo
          # These assets will be added to Avo's `application.html.erb` layout file
          Avo.asset_manager.add_javascript "/avo-advanced-assets/avo_advanced"
          Avo.asset_manager.add_stylesheet "/avo-kanban-assets/avo_kanban"
        end

        ActiveSupport.on_load(:avo_init) do
          # Run some code on each request
          Avo::FeedView::Current.something = VALUE
        end
      end
    end
  end
end
```

## Hooks

<Option name="`avo_boot`">

The `avo_boot` hook is called when the parent Rails application boots up. This is where you can register your scripts and stylesheets and also add your functionality to Avo.

We use it heavily to add our own concerns to the `Avo::BaseResource` and `Avo::BaseController` classes and even extend the `Avo::ApplicationController` class.

</Option>

<Option name="`avo_init`">

The `avo_init` hook is called on every request done inside Avo. You can use this hook to attach some code to the `Avo::App.context` object or do other things.

:::info
We don't use it as much in our plugins as we do in the `avo_boot` hook.
:::

</Option>

## Avo `AssetManager`

We use the `AssetManager` to add our own asset files (JavaScript and CSS) to be loaded by Avo. They will be added in the `<head>` section of Avo's layout file.

It has two methods:

<Option name="`add_javascript`">

```ruby
Avo.asset_manager.add_javascript "/avo-kanban-assets/avo_kanban"
```

This snippet will add the `/avo-kanban-assets/avo_kanban.js` file to the `<head>` section of Avo's layout file.

</Option>

<Option name="`add_stylesheet`">

```ruby
Avo.asset_manager.add_stylesheet "/avo-kanban-assets/avo_kanban"
```

This snippet will add the `/avo-kanban-assets/avo_kanban.css` file to the `<head>` section of Avo's layout file.

</Option>

## Using a middleware to surface asset files

One tricky thing to do with Rails Engines is to expose some asset files to the parent Rails app.
The way we do it is by using a middleware that will serve the files from the Engine's `app/assets/builds` directory.

So `app/assets/builds/feed_view.js` from the `feed_view` engine will be served by the parent Rails app at `/feed-view-assets/feed_view.js` with the following middleware added to your `engine.rb` file.

```ruby
module Avo
  module FeedView
    class Engine < ::Rails::Engine
      isolate_namespace Avo::FeedView

      initializer "avo-feed-view.init" do
        ActiveSupport.on_load(:avo_boot) do
          Avo.plugin_manager.register :feed_view
        end
      end

      config.app_middleware.use(
        Rack::Static,
        urls: ["/feed-view-assets"], # ðŸ‘ˆ This is the path where the files will be served
        root: root.join("app", "assets", "builds") # ðŸ‘ˆ This is the path where the files are located
      )
    end
  end
end
```

:::info
Avo doesn't compile the assets in any way, but just adds them to the layout file. This means that the assets should be compiled and ready for the browser to use them.

We use [`jsbundling-rails`](https://github.com/rails/jsbundling-rails)  with `esbuild` to compile the assets before packaging them in the `gem` file.

Please check out [the scripts](https://github.com/avo-hq/avo/blob/main/package.json) we use.
:::

## Create your own plugin

We don't yet have a generator for that but what we do is to create a new Rails Engine and add the plugin to it.

1. Run `rails plugin new feed-view`
1. Add the plugin to the `engine.rb` file
1. Register the plugin to the `lib/avo/feed_view/engine.rb` file
1. Optionally add assets
1. Add the plugin to your app's `Gemfile` using the `path` option to test it out
---

## Generation Information

- **Generated at:** 2025-06-22T18:59:54.154Z
- **Total sections:** 88

### Source Files

- docs/3.0/index.md
- docs/3.0/avo-3.md
- docs/3.0/upgrade.md
- docs/3.0/avo-2-avo-3-upgrade.md
- docs/3.0/technical-support.md
- docs/3.0/best-practices.md
- docs/4.0/editor.md
- docs/3.0/index.md
- docs/3.0/rails-and-hotwire.md
- docs/3.0/upgrade.md
- docs/3.0/installation.md
- docs/3.0/gem-server-authentication.md
- docs/3.0/license-troubleshooting.md
- docs/3.0/authentication.md
- docs/3.0/authorization.md
- docs/3.0/resources.md
- docs/3.0/array-resources.md
- docs/3.0/fields.md
- docs/3.0/field-options.md
- docs/3.0/field-discovery.md
- docs/3.0/controllers.md
- docs/3.0/record-previews.md
- docs/3.0/scopes.md
- docs/3.0/records-reordering.md
- docs/3.0/discreet-information.md
- docs/3.0/customizable-controls.md
- docs/3.0/cover-and-profile-photos.md
- docs/3.0/associations.md
- docs/3.0/associations/belongs_to.md
- docs/3.0/associations/has_one.md
- docs/3.0/associations/has_many.md
- docs/3.0/associations/has_and_belongs_to_many.md
- docs/3.0/resource-panels.md
- docs/3.0/resource-clusters.md
- docs/3.0/resource-sidebar.md
- docs/3.0/tabs.md
- docs/3.0/views.md
- docs/3.0/table-view.md
- docs/3.0/grid-view.md
- docs/3.0/map-view.md
- docs/3.0/customization.md
- docs/3.0/eject-views.md
- docs/3.0/custom-view-types.md
- docs/3.0/menu-editor.md
- docs/3.0/search.md
- docs/3.0/i18n.md
- docs/3.0/branding.md
- docs/3.0/routing.md
- docs/3.0/multitenancy.md
- docs/3.0/actions/overview.md
- docs/3.0/actions/generate.md
- docs/3.0/actions/registration.md
- docs/3.0/actions/execution.md
- docs/3.0/actions/customization.md
- docs/3.0/actions/guides-and-tutorials.md
- docs/3.0/dashboards.md
- docs/3.0/cards.md
- docs/3.0/kanban-boards.md
- docs/3.0/collaboration.md
- docs/3.0/audit-logging/overview.md
- docs/3.0/filters.md
- docs/3.0/basic-filters.md
- docs/3.0/dynamic-filters.md
- docs/3.0/audit-logging/overview.md
- docs/3.0/custom-tools.md
- docs/3.0/custom-fields.md
- docs/3.0/custom-errors.md
- docs/3.0/resource-tools.md
- docs/3.0/stimulus-integration.md
- docs/3.0/custom-asset-pipeline.md
- docs/3.0/tailwindcss-integration.md
- docs/3.0/media-library.md
- docs/3.0/cache.md
- docs/3.0/views-performance.md
- docs/3.0/native-components/avo-panel-component.md
- docs/3.0/native-field-components.md
- docs/3.0/field-wrappers.md
- docs/3.0/internals.md
- docs/3.0/testing.md
- docs/3.0/avo-current.md
- docs/3.0/execution-context.md
- docs/3.0/encryption-service.md
- docs/3.0/select-all.md
- docs/3.0/icons.md
- docs/3.0/internal-model-names.md
- docs/3.0/avo-application-controller.md
- docs/3.0/asset-manager.md
- docs/3.0/plugins.md

